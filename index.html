<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaikh's Enhanced Arcade</title>
    <style>
        /* ====== STYLE ====== */
        :root {
            /* Light Theme Colors - Refined & Enhanced */
            --color-primary-light: #3498db;       /* Softer, more vibrant blue */
            --color-secondary-light: #e74c3c;     /* Vibrant red/orange */
            --color-accent-light: #2ecc71;        /* Brighter green */
            --color-warning-light: #f39c12;       /* Warm orange */
            --color-background-light: #f0f4f8;    /* Softer off-white */
            --color-surface-light: #ffffff;       /* Pure White */
            --color-text-light: #2c3e50;          /* Darker, richer text */
            --color-text-secondary-light: #7f8c8d; /* Softer gray */
            --color-border-light: #d6dee6;        /* Softer border */
            --color-shadow-light: rgba(0, 0, 0, 0.08); /* Lighter shadow */

            /* Dark Theme Colors (Neon) - Kept as is for contrast */
            --color-background-dark: #121212;
            --color-surface-dark: #1e1e1e;
            --color-text-dark: #e0e0e0;
            --color-text-secondary-dark: #b0b0b0;
            --color-border-dark: #333333;
            --neon-pink: #ff2d95;
            --neon-blue: #00c2ff;
            --neon-yellow: #fff000;
            --neon-green: #00ff66;

            /* Active Theme Variables (will be set by JS) */
            --color-primary: var(--color-primary-light);
            --color-secondary: var(--color-secondary-light);
            --color-accent: var(--color-accent-light);
            --color-warning: var(--color-warning-light);
            --color-background: var(--color-background-light);
            --color-surface: var(--color-surface-light);
            --color-text: var(--color-text-light);
            --color-text-secondary: var(--color-text-secondary-light);
            --color-border: var(--color-border-light);
            --color-shadow: var(--color-shadow-light);

            /* Spacing */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --spacing-xxl: 3rem;

            /* Border radius */
            --border-radius-sm: 8px;
            --border-radius-md: 12px;
            --border-radius-lg: 18px;
            --border-radius-xl: 24px;
            --border-radius-circle: 50%;

            /* Shadows - Slightly deeper for light mode */
            --shadow-sm: 0 2px 4px 0 var(--color-shadow);
            --shadow-md: 0 6px 12px -2px var(--color-shadow);
            --shadow-lg: 0 10px 25px -5px var(--color-shadow);
            --shadow-focus: 0 0 0 3px rgba(52, 152, 219, 0.3); /* Adjusted for new primary */

            /* Animation */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;

            /* Z-index */
            --z-dropdown: 100;
            --z-sticky: 200;
            --z-modal: 300;
            --z-toast: 400;
            --z-sidebar: 500; /* For game drawer */
        }

        /* Dark Theme Overrides */
        .theme-dark {
            --color-background: var(--color-background-dark);
            --color-surface: var(--color-surface-dark);
            --color-text: var(--color-text-dark);
            --color-text-secondary: var(--color-text-secondary-dark);
            --color-border: var(--color-border-dark);
            --color-shadow: rgba(0, 0, 0, 0.3);
            --color-primary: var(--neon-blue);
            --color-secondary: var(--neon-yellow);
            --color-accent: var(--neon-pink);
            --color-warning: var(--neon-green);
            --shadow-sm: 0 2px 4px 0 var(--color-shadow);
            --shadow-md: 0 6px 12px -2px var(--color-shadow);
            --shadow-lg: 0 10px 25px -5px var(--color-shadow);
            --shadow-focus: 0 0 0 3px rgba(0, 194, 255, 0.4);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Slightly different font stack */
            background-color: var(--color-background);
            color: var(--color-text);
            line-height: 1.6;
            overflow-x: hidden;
            transition: background-color var(--transition-normal), color var(--transition-normal);
            position: relative;
        }

        /* ===== Enhanced Doodle Background with More Detail ===== */
        .doodle-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .doodle {
            position: absolute;
            opacity: 0.05; /* Subtle in light mode */
            /* Add subtle animations or effects */
        }

        .doodle.circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px dashed var(--color-primary);
            animation: float 25s infinite ease-in-out;
        }

        .doodle.square {
            width: 60px;
            height: 60px;
            border: 2px dotted var(--color-accent);
            animation: rotate 35s infinite linear;
        }

        .doodle.triangle {
            width: 0;
            height: 0;
            border-left: 40px solid transparent;
            border-right: 40px solid transparent;
            border-bottom: 70px solid var(--color-secondary);
            opacity: 0.04;
            animation: float 30s infinite ease-in-out reverse;
        }

        .doodle.zigzag {
            width: 100px;
            height: 20px;
            background: repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 10px,
                var(--color-accent) 10px,
                var(--color-accent) 20px
            );
            animation: moveRight 45s infinite linear;
        }

        /* New doodle types for more detail */
        .doodle.star {
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 35px solid var(--color-warning);
            opacity: 0.03;
            animation: twinkle 4s infinite ease-in-out;
        }

        .doodle.blob {
            width: 70px;
            height: 70px;
            border-radius: 50% 40% 60% 30% / 30% 60% 40% 50%;
            background: var(--color-primary);
            opacity: 0.04;
            animation: morph 15s infinite ease-in-out;
        }

        /* Enhance doodles in dark mode */
        .theme-dark .doodle {
            opacity: 0.12;
        }

        .theme-dark .doodle.circle {
            border: 3px dashed var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .theme-dark .doodle.square {
            border: 2px dotted var(--neon-pink);
            box-shadow: 0 0 8px var(--neon-pink);
        }

        .theme-dark .doodle.triangle {
            border-bottom: 70px solid var(--neon-yellow);
            filter: drop-shadow(0 0 5px var(--neon-yellow));
            opacity: 0.08;
        }

        .theme-dark .doodle.zigzag {
            background: repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 10px,
                var(--neon-green) 10px,
                var(--neon-green) 20px
            );
        }

        .theme-dark .doodle.star {
            border-bottom: 35px solid var(--neon-green);
            filter: drop-shadow(0 0 5px var(--neon-green));
            opacity: 0.1;
        }

        .theme-dark .doodle.blob {
            background: var(--neon-blue);
            opacity: 0.08;
        }


        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(15px, 20px) rotate(5deg); }
            50% { transform: translate(0, 40px) rotate(0deg); }
            75% { transform: translate(-15px, 20px) rotate(-5deg); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes moveRight {
            from { transform: translateX(-100px); }
            to { transform: translateX(calc(100vw + 100px)); }
        }

        /* New animations for detail */
        @keyframes twinkle {
            0%, 100% { opacity: 0.03; transform: scale(1); }
            50% { opacity: 0.1; transform: scale(1.2); }
        }

        .theme-dark @keyframes twinkle {
            0%, 100% { opacity: 0.1; transform: scale(1); }
            50% { opacity: 0.2; transform: scale(1.2); }
        }

        @keyframes morph {
            0% { border-radius: 50% 40% 60% 30% / 30% 60% 40% 50%; }
            25% { border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; }
            50% { border-radius: 40% 50% 30% 70% / 60% 30% 70% 40%; }
            75% { border-radius: 60% 30% 50% 60% / 40% 70% 50% 30%; }
            100% { border-radius: 50% 40% 60% 30% / 30% 60% 40% 50%; }
        }


        button {
            background: none;
            border: none;
            cursor: pointer;
            font-family: inherit;
            color: inherit;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* App Layout */
        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: var(--spacing-md);
            max-width: 1400px; /* Slightly wider */
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            position: relative;
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--color-border);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 1.75rem; /* Slightly larger */
            font-weight: 800; /* Bolder */
            color: var(--color-text);
            background: linear-gradient(90deg, var(--color-primary), var(--color-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .logo-icon {
            width: 48px; /* Slightly larger */
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
            color: white;
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-md);
            font-size: 1.75rem; /* Slightly larger */
            animation: pulse-glow 2s infinite ease-in-out; /* Add subtle glow */
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: var(--shadow-md); }
            50% { box-shadow: var(--shadow-md), 0 0 15px var(--color-primary); }
        }

        .theme-dark .logo-icon {
            box-shadow: 0 0 10px var(--color-primary);
            animation: pulse-neon 2s infinite ease-in-out;
        }

        @keyframes pulse-neon {
            0%, 100% { box-shadow: 0 0 10px var(--color-primary); }
            50% { box-shadow: 0 0 20px var(--color-primary), 0 0 30px var(--color-primary); }
        }


        .controls {
            display: flex;
            gap: var(--spacing-sm);
        }

        .icon-button {
            width: 48px;
            height: 48px;
            border-radius: var(--border-radius-circle);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
            border: 1px solid var(--color-border);
            color: var(--color-text);
            font-size: 1.2rem; /* Slightly larger icon */
        }

        .icon-button:hover, .icon-button:focus {
            background-color: var(--color-primary);
            color: white;
            box-shadow: var(--shadow-md);
            transform: translateY(-3px);
            border-color: var(--color-primary);
        }

        .icon-button:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .icon-button:active {
            transform: translateY(0);
        }

        .theme-dark .icon-button {
            border: 1px solid var(--color-border);
        }

        .theme-dark .icon-button:hover {
            box-shadow: 0 0 12px var(--color-primary);
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.4);
            transform: scale(0);
            animation: ripple 0.6s linear;
        }

        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        .search-container {
            margin: var(--spacing-lg) auto;
            max-width: 550px; /* Slightly wider */
            width: 100%;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: var(--spacing-md) var(--spacing-xl);
            padding-left: 48px;
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--color-border);
            background-color: var(--color-surface);
            color: var(--color-text);
            font-size: 1rem;
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-fast);
        }

        .search-input:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
            border-color: var(--color-primary);
        }

        .search-icon {
            position: absolute;
            left: var(--spacing-md);
            top: 50%;
            transform: translateY(-50%);
            color: var(--color-text-secondary);
        }

        /* ===== Enhanced Game Selection Area - Sidebar Style ===== */
        .game-area {
            display: flex;
            flex: 1;
            gap: var(--spacing-lg);
        }

        .game-sidebar {
            width: 300px; /* Fixed width for sidebar */
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--color-border);
            padding: var(--spacing-md);
            overflow-y: auto;
            max-height: calc(100vh - 200px); /* Adjust based on header/footer */
            transition: transform var(--transition-normal);
            z-index: var(--z-sidebar);
        }

        .game-sidebar.hidden {
             transform: translateX(-110%); /* Hide off-screen */
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid var(--color-border);
        }

        .sidebar-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--color-text);
        }

        .toggle-sidebar {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--color-text-secondary);
            padding: var(--spacing-xs);
            border-radius: var(--border-radius-sm);
        }

        .toggle-sidebar:hover {
            background-color: rgba(0,0,0,0.05);
            color: var(--color-text);
        }
        .theme-dark .toggle-sidebar:hover {
            background-color: rgba(255,255,255,0.1);
        }


        .games-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .game-list-item {
            padding: var(--spacing-sm) var(--spacing-md);
            margin-bottom: var(--spacing-xs);
            border-radius: var(--border-radius-md);
            cursor: pointer;
            transition: background-color var(--transition-fast), transform var(--transition-fast);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            border: 1px solid transparent; /* Invisible border for consistent sizing */
        }

        .game-list-item:hover {
            background-color: rgba(0, 0, 0, 0.03);
            transform: translateX(5px);
        }

        .theme-dark .game-list-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .game-list-item.active {
            background-color: rgba(52, 152, 219, 0.15); /* Primary color with opacity */
            border-color: var(--color-primary);
            font-weight: 500;
        }

        .game-list-icon {
            font-size: 1.5rem;
        }

        .game-list-text {
            flex: 1;
        }


        .games-main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0; /* Allows scrolling inside */
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            flex: 1; /* Takes remaining space */
            overflow-y: auto; /* Scroll if needed */
            padding: var(--spacing-sm); /* Add padding for scroll area */
        }

        .game-tile {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-normal);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--color-border);
        }

        .game-tile:hover, .game-tile:focus {
            transform: translateY(-8px);
            box-shadow: var(--shadow-lg);
            border-color: var(--color-primary);
        }

        .game-tile:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .theme-dark .game-tile:hover {
            box-shadow: 0 0 15px var(--color-primary);
        }

        .game-tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg,
                var(--color-primary) 0%,
                var(--color-accent) 50%,
                var(--color-secondary) 100%);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform var(--transition-normal);
        }

        .game-tile:hover::before {
            transform: scaleX(1);
        }

        .game-icon {
            width: 70px;
            height: 70px;
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            border-radius: var(--border-radius-md);
            background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
            color: white;
            transition: transform var(--transition-normal);
            position: relative;
            box-shadow: var(--shadow-md);
            animation: float-subtle 3s ease-in-out infinite alternate; /* Subtle float */
        }

        @keyframes float-subtle {
            from { transform: translateY(0px); }
            to { transform: translateY(-5px); }
        }

        .theme-dark .game-icon {
            box-shadow: 0 0 15px var(--color-primary);
        }

        .game-tile:hover .game-icon {
            animation: wiggle 0.6s ease;
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }

        .game-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        .game-description {
            font-size: 0.875rem;
            color: var(--color-text-secondary);
            transform: translateY(0);
            transition: transform var(--transition-normal);
            margin-bottom: var(--spacing-md);
        }

        .game-tile:hover .game-description {
            transform: translateY(-4px);
        }

        .game-preview {
            width: 100%;
            height: 60px;
            margin-top: var(--spacing-md);
            border-radius: var(--border-radius-sm);
            background-color: rgba(0, 0, 0, 0.03);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            border: 1px solid var(--color-border);
        }

        .theme-dark .game-preview {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--color-border);
        }

        /* Game View */
        .game-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-background);
            z-index: var(--z-modal);
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform var(--transition-normal);
            overflow: hidden;
        }

        .game-view.active {
            transform: translateY(0);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            position: relative;
            z-index: 1;
            border-bottom: 1px solid var(--color-border);
        }

        .game-title-bar {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .game-content {
            flex: 1;
            padding: var(--spacing-md);
            overflow: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-modal);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normal);
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow: auto;
            transform: scale(0.9) translateY(20px);
            opacity: 0;
            transition: all var(--transition-normal);
            border: 1px solid var(--color-border);
        }

        .theme-dark .modal {
            border: 1px solid var(--color-primary);
            box-shadow: 0 0 20px rgba(0, 194, 255, 0.3);
        }

        .modal-overlay.active .modal {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        .modal-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border-radius: var(--border-radius-circle);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            transition: background-color var(--transition-fast);
            color: var(--color-text);
        }

        .modal-close:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .theme-dark .modal-close:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .modal-body {
            padding: var(--spacing-md);
        }

        .modal-footer {
            padding: var(--spacing-md);
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
        }

        /* Buttons */
        .btn {
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-md);
            font-weight: 500;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            position: relative;
            overflow: hidden;
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
        }

        .btn:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
            box-shadow: var(--shadow-sm);
        }

        .btn-primary:hover {
            background-color: var(--color-secondary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background-color: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            box-shadow: var(--shadow-sm);
        }

        .btn-secondary:hover {
            background-color: rgba(0, 0, 0, 0.03);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .theme-dark .btn-primary {
            box-shadow: 0 0 8px var(--color-primary);
        }

        .theme-dark .btn-primary:hover {
            box-shadow: 0 0 12px var(--color-primary);
        }

        .theme-dark .btn-secondary {
             border: 1px solid var(--color-border);
        }

        .theme-dark .btn-secondary:hover {
             background-color: rgba(255, 255, 255, 0.05);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: var(--spacing-md);
        }

        .form-label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: 500;
            color: var(--color-text);
        }

        .form-control {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--color-border);
            background-color: var(--color-surface);
            color: var(--color-text);
            font-family: inherit;
            font-size: 1rem;
            box-shadow: var(--shadow-sm);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .theme-dark .form-control:focus {
             box-shadow: 0 0 0 2px rgba(0, 194, 255, 0.3);
        }

        /* Toasts */
        .toast-container {
            position: fixed;
            bottom: var(--spacing-md);
            right: var(--spacing-md);
            z-index: var(--z-toast);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .toast {
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            max-width: 300px;
            transform: translateX(100%);
            opacity: 0;
            transition: all var(--transition-normal);
            border-left: 4px solid var(--color-primary);
            border: 1px solid var(--color-border);
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast-success {
            border-left-color: var(--color-accent);
        }

        .toast-error {
            border-left-color: var(--color-warning);
        }

        .toast-info {
            border-left-color: var(--color-primary);
        }

        .theme-dark .toast {
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        /* Game-specific styles - Updated */
        .snake-game, .tictactoe-game, .memory-game, .reaction-game, .whack-game, .dice-game, .runner-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
            width: 100%;
            max-width: 800px; /* Limit width for better layout */
        }

        .snake-canvas, .tictactoe-board, .memory-board, .reaction-display, .whack-board, .dice-display, .runner-canvas {
            border: 2px solid var(--color-border);
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
            max-width: 100%;
            touch-action: none;
        }

        .game-controls {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
            flex-wrap: wrap; /* Allow wrapping on small screens */
            justify-content: center;
        }

        /* Enhanced Snake Game Styles */
        .snake-game-ui {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            margin-bottom: var(--spacing-md);
        }

        .snake-stats {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            min-width: 150px;
        }

        .snake-stat-item {
            font-size: 1rem;
            font-weight: 500;
        }

        .snake-level-display {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--color-primary);
        }

        .snake-mode-selector {
             margin-top: var(--spacing-md);
             display: flex;
             gap: var(--spacing-sm);
             flex-wrap: wrap;
             justify-content: center;
        }

        /* Tic Tac Toe Specific - Updated */
        .tictactoe-game-ui {
             display: flex;
             flex-direction: column;
             align-items: center;
             gap: var(--spacing-md);
        }

        .tictactoe-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 5px;
            width: 300px;
            height: 300px;
            background-color: var(--color-border);
            padding: 5px;
            border-radius: 5px;
            box-shadow: var(--shadow-md); /* Add shadow */
        }

        .tictactoe-cell {
            background-color: var(--color-surface);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem; /* Larger font */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border-radius: var(--border-radius-sm);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1); /* Inner shadow */
        }

        .tictactoe-cell:hover {
            background-color: rgba(0, 0, 0, 0.05);
            transform: scale(1.05); /* Slight scale on hover */
        }

        .theme-dark .tictactoe-cell:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .tictactoe-cell.win {
             background-color: rgba(46, 204, 113, 0.3); /* Accent light with opacity */
             animation: winPulse 0.5s ease-in-out 3; /* Pulse animation */
        }

        @keyframes winPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .theme-dark .tictactoe-cell.win {
             background-color: rgba(0, 255, 102, 0.2); /* Neon green with opacity */
        }

        .tictactoe-status {
             font-size: 1.2rem;
             font-weight: 500;
             margin-top: var(--spacing-sm);
        }

        .tictactoe-score {
             font-size: 1rem;
             color: var(--color-text-secondary);
        }

        .tictactoe-mode-selector {
             margin-top: var(--spacing-md);
             display: flex;
             gap: var(--spacing-sm);
             flex-wrap: wrap;
             justify-content: center;
        }


        /* Memory Game Specific */
        .memory-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-gap: 10px;
            width: 100%;
            max-width: 400px;
        }

        .memory-card {
            aspect-ratio: 1 / 1;
            background: linear-gradient(135deg, var(--color-primary), var(--color-secondary)); /* Gradient back */
            border-radius: var(--border-radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            transition: transform 0.3s, background-color 0.3s;
            box-shadow: var(--shadow-sm);
            color: white;
            position: relative;
            overflow: hidden;
        }

         .memory-card::before { /* Card back pattern */
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.1) 0px, rgba(255,255,255,0.1) 10px, transparent 10px, transparent 20px);
            opacity: 0.5;
        }

        .memory-card.flipped {
            background: var(--color-surface); /* Solid background when flipped */
            color: var(--color-text);
            transform: rotateY(180deg);
        }

         .memory-card.matched {
            background: var(--color-accent); /* Solid accent for matched */
            color: white;
            cursor: default;
            opacity: 0.8;
        }

        /* Reaction Tester Specific */
        .reaction-display {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .reaction-ready {
            background: linear-gradient(135deg, var(--color-secondary), var(--color-warning)); /* Gradient */
            color: white;
            box-shadow: var(--shadow-md);
        }

        .reaction-wait {
            background: linear-gradient(135deg, var(--color-warning), #e67e22); /* Gradient */
            color: white;
            box-shadow: var(--shadow-md);
        }

        .reaction-go {
            background: linear-gradient(135deg, var(--color-accent), #27ae60); /* Gradient */
            color: white;
            animation: pulse 1s infinite;
            box-shadow: var(--shadow-md);
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: var(--shadow-md); }
            50% { transform: scale(1.05); box-shadow: var(--shadow-md), 0 0 15px var(--color-accent); }
            100% { transform: scale(1); box-shadow: var(--shadow-md); }
        }

        .reaction-result {
            margin-top: var(--spacing-md);
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Whack-a-Doodle Specific */
        .whack-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            width: 300px;
            height: 300px;
            padding: 10px;
            background: linear-gradient(135deg, var(--color-border), #aab7c4); /* Gradient background */
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-md); /* Add shadow */
        }

        .whack-hole {
            background: radial-gradient(circle, #34495e, #2c3e50); /* Hole gradient */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            box-shadow: inset 0 5px 10px rgba(0,0,0,0.5); /* Inner shadow for depth */
        }

        .whack-doodle {
            position: absolute;
            width: 80%;
            height: 80%;
            background: radial-gradient(circle, var(--color-secondary), #c0392b); /* Doodle gradient */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: transform 0.1s;
            transform: translateY(100%);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Shadow */
        }

        .whack-doodle.up {
            transform: translateY(0);
            animation: popUp 0.3s ease-out; /* Pop up animation */
        }

        @keyframes popUp {
            0% { transform: translateY(100%) scale(0.8); opacity: 0; }
            70% { transform: translateY(-20%) scale(1.1); }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        .whack-score {
            margin-top: var(--spacing-md);
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Dice Game Specific */
        .dice-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-lg);
            width: 100%;
            max-width: 300px;
            background-color: var(--color-surface);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-md);
            border: 1px solid var(--color-border);
        }

        .dice-rolls {
            display: flex;
            gap: var(--spacing-sm);
            font-size: 3rem; /* Larger dice */
        }

        .dice { /* Individual die */
            width: 60px;
            height: 60px;
            background-color: white;
            border-radius: var(--border-radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--color-border);
        }

        .dice-guess-input {
            width: 100px;
            text-align: center;
            font-size: 1.2rem; /* Larger input */
            padding: var(--spacing-sm);
        }

        .dice-result {
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
        }

        .dice-stats {
             font-size: 1rem;
             color: var(--color-text-secondary);
             text-align: center;
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            .doodle-bg {
                display: none;
            }
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .game-area {
                flex-direction: column;
            }
            .game-sidebar {
                width: 100%;
                max-height: 200px; /* Limit height on smaller screens */
            }
            .games-main-content {
                 /* Adjust if needed */
            }
        }

        @media (max-width: 768px) {
            .games-grid {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            }
            .app-header {
                flex-direction: column;
                gap: var(--spacing-md);
            }
            .game-sidebar {
                 position: fixed;
                 top: 0;
                 left: 0;
                 height: 100%;
                 max-height: none;
                 transform: translateX(-100%);
                 transition: transform var(--transition-normal);
            }
            .game-sidebar:not(.hidden) {
                transform: translateX(0);
            }
            .toggle-sidebar {
                display: block; /* Show toggle on mobile */
            }
        }

        @media (max-width: 480px) {
            .games-grid {
                grid-template-columns: 1fr;
            }
            .app-header {
                 padding: var(--spacing-sm);
            }
            .logo {
                 font-size: 1.5rem;
            }
            .logo-icon {
                 width: 40px;
                 height: 40px;
                 font-size: 1.5rem;
            }
            .icon-button {
                 width: 40px;
                 height: 40px;
                 font-size: 1rem;
            }
        }

    </style>
</head>
<body>
    <!-- ====== TEMPLATE ====== -->
    <div class="doodle-bg">
        <!-- Existing doodles -->
        <div class="doodle circle" style="top: 10%; left: 5%;"></div>
        <div class="doodle square" style="top: 20%; right: 7%;"></div>
        <div class="doodle triangle" style="top: 60%; left: 8%;"></div>
        <div class="doodle zigzag" style="top: 40%; left: 15%;"></div>
        <div class="doodle circle" style="top: 70%; right: 10%; width: 60px; height: 60px;"></div>
        <div class="doodle square" style="top: 30%; left: 20%; width: 40px; height: 40px;"></div>
        <div class="doodle triangle" style="bottom: 15%; right: 20%;"></div>
        <div class="doodle zigzag" style="bottom: 30%; left: 5%;"></div>
        <!-- New doodles for more detail -->
        <div class="doodle star" style="top: 15%; right: 25%;"></div>
        <div class="doodle blob" style="bottom: 20%; left: 25%;"></div>
        <div class="doodle star" style="top: 50%; left: 50%;"></div>
        <div class="doodle blob" style="top: 80%; right: 30%;"></div>
    </div>
    <div class="app">
        <header class="app-header">
            <div class="logo">
                <div class="logo-icon">🎮</div>
                <h1>Shaikh's Enhanced Arcade</h1>
            </div>
            <div class="controls">
                <button class="icon-button" id="soundToggle" aria-label="Toggle sound">
                    <span class="sound-icon">🔊</span>
                </button>
                <button class="icon-button" id="themeToggle" aria-label="Toggle theme">
                    <span class="theme-icon">🌙</span>
                </button>
                <button class="icon-button" id="settingsButton" aria-label="Open settings">
                    <span class="settings-icon">⚙️</span>
                </button>
                <button class="icon-button" id="profileButton" aria-label="Open profile">
                    <span class="profile-icon">👤</span>
                </button>
            </div>
        </header>
        <div class="search-container">
            <div class="search-icon">🔍</div>
            <input type="text" class="search-input" id="gameSearch" placeholder="Search games..." aria-label="Search games">
        </div>

        <!-- ===== Enhanced Game Selection Area ===== -->
        <div class="game-area">
            <aside class="game-sidebar" id="gameSidebar">
                <div class="sidebar-header">
                    <h2 class="sidebar-title">Games</h2>
                    <button class="toggle-sidebar" id="toggleSidebar" aria-label="Toggle game list">☰</button>
                </div>
                <ul class="games-list" id="gamesList">
                    <!-- Game list items will be populated by JavaScript -->
                </ul>
            </aside>
            <main class="games-main-content">
                 <div class="games-grid" id="gamesGrid">
                    <!-- Game tiles will be populated by JavaScript -->
                 </div>
            </main>
        </div>
        <!-- ===== End Game Selection Area ===== -->

        <div class="game-view" id="gameView">
            <div class="game-header">
                <div class="game-title-bar">
                    <button class="btn btn-secondary" id="backButton">
                        ← Back
                    </button>
                    <h2 class="game-title" id="currentGameTitle">Game Title</h2>
                </div>
                <div class="game-controls">
                    <button class="icon-button" id="gameInfo" aria-label="Game information">
                        ℹ️
                    </button>
                    <button class="icon-button" id="gameRestart" aria-label="Restart game">
                        🔄
                    </button>
                    <button class="icon-button" id="gamePause" aria-label="Pause game">
                        ⏸️
                    </button>
                </div>
            </div>
            <div class="game-content" id="gameContent">
                <!-- Game content will be populated by JavaScript -->
            </div>
        </div>
    </div>
    <!-- Modals -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Settings</h3>
                <button class="modal-close" id="closeSettings">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="soundToggleSetting">Sound</label>
                    <div class="form-control">
                        <label>
                            <input type="checkbox" id="soundToggleSetting">
                            Enable sound
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label" for="volumeSlider">Volume</label>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.1" class="form-control">
                </div>
                <div class="form-group">
                    <label class="form-label" for="themeSelect">Theme</label>
                    <select id="themeSelect" class="form-control">
                        <option value="light">Light</option>
                        <option value="dark">Dark (Neon)</option>
                        <option value="auto">Auto (system)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="onboardingToggle">Show onboarding</label>
                    <div class="form-control">
                        <label>
                            <input type="checkbox" id="onboardingToggle">
                            Show onboarding on startup
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="resetProgress">
                    Reset Progress
                </button>
                <button class="btn btn-primary" id="saveSettings">
                    Save
                </button>
            </div>
        </div>
    </div>
    <div class="modal-overlay" id="profileModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Your Profile</h3>
                <button class="modal-close" id="closeProfile">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <h4>Achievements</h4>
                    <div id="achievementsList">
                        <!-- Achievements will be populated by JavaScript -->
                    </div>
                </div>
                <div class="form-group">
                    <h4>High Scores</h4>
                    <div id="highScoresList">
                        <!-- High scores will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-overlay" id="onboardingModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Welcome to Shaikh's Enhanced Arcade!</h3>
                <button class="modal-close" id="closeOnboarding">✕</button>
            </div>
            <div class="modal-body">
                <p>🎮 Play a collection of fun, upgraded mini-games</p>
                <p>🏆 Earn achievements and track high scores</p>
                <p>⚙️ Customize your experience in settings</p>
                <p>🌙 Try the cool neon dark mode!</p>
                <p>✨ Experience the new light theme and creative details!</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="startPlaying">
                    Start Playing
                </button>
            </div>
        </div>
    </div>
    <div class="toast-container" id="toastContainer">
        <!-- Toasts will be added here by JavaScript -->
    </div>
    <script>
        /* ====== SCRIPTS ====== */
        (function() {
            'use strict';
            // Utility functions
            const qs = (selector, root = document) => root.querySelector(selector);
            const qsa = (selector, root = document) => Array.from(root.querySelectorAll(selector));
            const create = (tag, props = {}, children = []) => {
                const el = document.createElement(tag);
                Object.keys(props).forEach(key => {
                    el[key] = props[key];
                });
                children.forEach(child => {
                    if (typeof child === 'string') {
                        el.appendChild(document.createTextNode(child));
                    } else {
                        el.appendChild(child);
                    }
                });
                return el;
            };

            // App state
            let activeGame = null;
            let activeGameId = null; // Keep track of the active game ID
            let gamesRegistry = {};
            let settings = {
                soundOn: true,
                volume: 0.5,
                theme: 'light',
                showOnboarding: true
            };
            let scores = {};
            let achievements = {};

            // DOM elements
            const gamesGrid = qs('#gamesGrid');
            const gamesList = qs('#gamesList'); // Sidebar list
            const gameSidebar = qs('#gameSidebar');
            const toggleSidebar = qs('#toggleSidebar');
            const gameView = qs('#gameView');
            const gameContent = qs('#gameContent');
            const currentGameTitle = qs('#currentGameTitle');
            const gameSearch = qs('#gameSearch');
            const backButton = qs('#backButton');
            const soundToggle = qs('#soundToggle');
            const themeToggle = qs('#themeToggle');
            const settingsButton = qs('#settingsButton');
            const profileButton = qs('#profileButton');
            const gamePause = qs('#gamePause');
            const gameRestart = qs('#gameRestart');
            const gameInfo = qs('#gameInfo');

            // Modals
            const settingsModal = qs('#settingsModal');
            const profileModal = qs('#profileModal');
            const onboardingModal = qs('#onboardingModal');
            const closeSettings = qs('#closeSettings');
            const closeProfile = qs('#closeProfile');
            const closeOnboarding = qs('#closeOnboarding');
            const soundToggleSetting = qs('#soundToggleSetting');
            const volumeSlider = qs('#volumeSlider');
            const themeSelect = qs('#themeSelect');
            const onboardingToggle = qs('#onboardingToggle');
            const resetProgress = qs('#resetProgress');
            const saveSettings = qs('#saveSettings');
            const startPlaying = qs('#startPlaying');

            // Sound Manager (Simplified version)
            const SoundManager = {
                audioContext: null,
                enabled: true,
                volume: 0.5,
                init() {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        this.enabled = true;
                    } catch (e) {
                        console.warn('Web Audio API is not supported in this browser');
                        this.enabled = false;
                    }
                },
                play(kind) {
                    if (!this.enabled || !this.audioContext || !settings.soundOn) return;
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    let frequency = 440;
                    let duration = 0.1;
                    switch (kind) {
                        case 'click': frequency = 523.25; break;
                        case 'success': frequency = 783.99; break;
                        case 'error': frequency = 349.23; break;
                        case 'eat': frequency = 659.25; duration = 0.05; break;
                        case 'hit': frequency = 392; duration = 0.08; break;
                    }
                    gainNode.gain.value = this.volume;
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    oscillator.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    oscillator.stop(this.audioContext.currentTime + duration);
                },
                setVolume(volume) { this.volume = volume; },
                toggle() { this.enabled = !this.enabled; return this.enabled; }
            };

            // Toast system
            const Toast = {
                container: qs('#toastContainer'),
                show(message, type = 'info', duration = 3000) {
                    const toast = create('div', {
                        className: `toast toast-${type}`,
                        innerHTML: `<span>${message}</span>`
                    });
                    this.container.appendChild(toast);
                    toast.offsetHeight; // Trigger reflow
                    toast.classList.add('show');
                    setTimeout(() => {
                        toast.classList.remove('show');
                        setTimeout(() => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, 300);
                    }, duration);
                }
            };

            // Ripple effect
            const addRippleEffect = (element) => {
                element.addEventListener('click', function(e) {
                    const rect = this.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const ripple = create('span', { className: 'ripple', style: `top: ${y}px; left: ${x}px;` });
                    this.appendChild(ripple);
                    setTimeout(() => { ripple.remove(); }, 600);
                });
            };

            // LocalStorage management
            const Storage = {
                get(key) {
                    try {
                        const item = localStorage.getItem(`shaikhArcadeEnhanced.${key}`);
                        return item ? JSON.parse(item) : null;
                    } catch (e) { console.error('Error reading from localStorage', e); return null; }
                },
                set(key, value) {
                    try { localStorage.setItem(`shaikhArcadeEnhanced.${key}`, JSON.stringify(value)); } catch (e) { console.error('Error writing to localStorage', e); }
                },
                remove(key) {
                    try { localStorage.removeItem(`shaikhArcadeEnhanced.${key}`); } catch (e) { console.error('Error removing from localStorage', e); }
                }
            };

            // Load/Save data
            function loadData() {
                const savedSettings = Storage.get('settings');
                if (savedSettings) settings = { ...settings, ...savedSettings };
                const savedScores = Storage.get('scores');
                if (savedScores) scores = savedScores;
                const savedAchievements = Storage.get('achievements');
                if (savedAchievements) achievements = savedAchievements;
            }
            function saveData() {
                Storage.set('settings', settings);
                Storage.set('scores', scores);
                Storage.set('achievements', achievements);
            }

            // Apply settings
            function applySettings() {
                let actualTheme = settings.theme;
                if (settings.theme === 'auto') {
                    actualTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
                }
                document.body.classList.toggle('theme-dark', actualTheme === 'dark');
                themeToggle.querySelector('.theme-icon').textContent = actualTheme === 'dark' ? '☀️' : '🌙';
                soundToggle.querySelector('.sound-icon').textContent = settings.soundOn ? '🔊' : '🔇';
                SoundManager.setVolume(settings.volume);
                soundToggleSetting.checked = settings.soundOn;
                volumeSlider.value = settings.volume;
                themeSelect.value = settings.theme;
                onboardingToggle.checked = settings.showOnboarding;
            }

            // Show onboarding
            function checkOnboarding() {
                if (settings.showOnboarding) {
                    onboardingModal.classList.add('active');
                }
            }

            // Check and unlock achievements
            function checkAchievement(achievementId, condition, payload = null) {
                if (condition && !achievements[achievementId]) {
                    achievements[achievementId] = { unlocked: true, timestamp: Date.now(), payload: payload };
                    Storage.set('achievements', achievements);
                    let message = '';
                    switch (achievementId) {
                        case 'first_win': message = 'Achievement Unlocked: First Win!'; break;
                        case 'snake_master': message = 'Achievement Unlocked: Snake Master!'; break;
                        case 'tic_master': message = 'Achievement Unlocked: Tic-Tac-Toe Master!'; break;
                        case 'memory_champ': message = 'Achievement Unlocked: Memory Champion!'; break;
                        case 'speed_demon': message = 'Achievement Unlocked: Speed Demon!'; break;
                        case 'whack_streak': message = 'Achievement Unlocked: Whack-a-Doodle Streak!'; break;
                        case 'lucky_roller': message = 'Achievement Unlocked: Lucky Roller!'; break;
                        case 'runner_pro': message = 'Achievement Unlocked: Runner Pro!'; break;
                    }
                    if (message) Toast.show(message, 'success');
                }
            }

            // Update scores
            function updateScores(gameId, scoreData) {
                if (!scores[gameId]) scores[gameId] = {};
                if (typeof scoreData === 'number') {
                    if (!scores[gameId].highScore || scoreData > scores[gameId].highScore) {
                        scores[gameId].highScore = scoreData;
                        Storage.set('scores', scores);
                    }
                } else if (typeof scoreData === 'object') {
                    Object.keys(scoreData).forEach(key => {
                        if (!scores[gameId][key] || scoreData[key] > scores[gameId][key]) {
                            scores[gameId][key] = scoreData[key];
                        }
                    });
                    Storage.set('scores', scores);
                }
            }

            // Game modules
            const GameModules = {

                // ===== Enhanced Smooth Snake game with Levels and AI =====
                snake: {
                    id: 'snake',
                    title: 'Smooth Snake',
                    description: 'Guide the snake to eat food and grow longer. Levels increase speed!',
                    icon: '🐍',
                    init(container) {
                        const canvas = create('canvas', {
                            className: 'snake-canvas',
                            width: 500, // Slightly larger canvas
                            height: 500,
                            role: 'application',
                            'aria-label': 'Snake game canvas'
                        });
                        const ctx = canvas.getContext('2d');

                        // Game state with level
                        const gameState = {
                            snake: [{x: 10, y: 10}],
                            food: {x: 5, y: 5},
                            direction: 'right',
                            nextDirection: 'right',
                            score: 0,
                            highScore: scores.snake?.highScore || 0,
                            gameOver: false,
                            paused: false,
                            gridSize: 20,
                            baseSpeed: 150, // Base speed
                            speed: 150, // Current speed (decreases with level)
                            level: 1,
                            foodEatenThisLevel: 0,
                            foodsPerLevel: 5, // Food needed to level up
                            lastUpdate: 0,
                            interpolation: 0,
                            touchStart: null
                        };

                        const scoreAnnouncer = create('div', { className: 'sr-only', 'aria-live': 'polite' });

                        // Create UI elements
                        const gameUI = create('div', { className: 'snake-game-ui' });
                        const statsDiv = create('div', { className: 'snake-stats' });
                        const scoreSpan = create('span', { className: 'snake-stat-item', textContent: `Score: ${gameState.score}` });
                        const highScoreSpan = create('span', { className: 'snake-stat-item', textContent: `High Score: ${gameState.highScore}` });
                        const levelSpan = create('span', { className: 'snake-level-display', textContent: `Level: ${gameState.level}` });
                        statsDiv.append(scoreSpan, highScoreSpan, levelSpan);

                        const modeSelector = create('div', { className: 'snake-mode-selector' });
                        const modeLabel = create('span', { textContent: 'Mode:' });
                        const soloButton = create('button', { className: 'btn btn-secondary active', textContent: 'Solo' });
                        const aiButton = create('button', { className: 'btn btn-secondary', textContent: 'vs AI' });
                        // Placeholder for AI logic - simplified for now
                        let aiMode = false;
                        soloButton.addEventListener('click', () => {
                            aiMode = false;
                            soloButton.classList.add('active');
                            aiButton.classList.remove('active');
                            this.restart(); // Restart game on mode change
                        });
                        aiButton.addEventListener('click', () => {
                            aiMode = true;
                            aiButton.classList.add('active');
                            soloButton.classList.remove('active');
                            this.restart(); // Restart game on mode change
                        });
                        modeSelector.append(modeLabel, soloButton, aiButton);

                        gameUI.append(statsDiv, modeSelector);
                        container.append(gameUI, canvas, scoreAnnouncer);

                        // --- Game Logic ---
                        const placeFood = () => {
                            let newFood, overlapping;
                            do {
                                newFood = {
                                    x: Math.floor(Math.random() * (canvas.width / gameState.gridSize)),
                                    y: Math.floor(Math.random() * (canvas.height / gameState.gridSize))
                                };
                                overlapping = false;
                                for (const segment of gameState.snake) {
                                    if (segment.x === newFood.x && segment.y === newFood.y) {
                                        overlapping = true; break;
                                    }
                                }
                            } while (overlapping);
                            gameState.food = newFood;
                        };

                        const checkCollision = (head, array) => {
                            for (let i = 0; i < array.length; i++) {
                                if (array[i].x === head.x && array[i].y === head.y) return true;
                            }
                            return false;
                        };

                        const updateLevel = () => {
                            gameState.foodEatenThisLevel++;
                            if (gameState.foodEatenThisLevel >= gameState.foodsPerLevel) {
                                gameState.level++;
                                gameState.foodEatenThisLevel = 0;
                                // Increase difficulty (decrease speed, min 50ms)
                                gameState.speed = Math.max(50, gameState.baseSpeed - (gameState.level * 10));
                                levelSpan.textContent = `Level: ${gameState.level}`;
                                Toast.show(`Level Up! Speed Increased!`, 'info');
                                SoundManager.play('success');
                            }
                        };

                        const update = (currentTime) => {
                            if (gameState.paused || gameState.gameOver) return;
                            if (!gameState.lastUpdate) gameState.lastUpdate = currentTime;
                            const deltaTime = currentTime - gameState.lastUpdate;
                            gameState.interpolation = Math.min(1, deltaTime / gameState.speed);

                            if (deltaTime > gameState.speed) {
                                gameState.lastUpdate = currentTime;
                                gameState.interpolation = 0;
                                gameState.direction = gameState.nextDirection;

                                // --- AI Logic (Simple) ---
                                if (aiMode) {
                                   // Very basic AI: move towards food if possible, avoid walls/self
                                   const head = gameState.snake[0];
                                   const possibleMoves = [];
                                   const directions = [
                                       { dir: 'up', vec: {x: 0, y: -1} },
                                       { dir: 'down', vec: {x: 0, y: 1} },
                                       { dir: 'left', vec: {x: -1, y: 0} },
                                       { dir: 'right', vec: {x: 1, y: 0} }
                                   ];

                                   directions.forEach(d => {
                                       if (
                                           (gameState.direction !== 'down' || d.dir !== 'up') &&
                                           (gameState.direction !== 'up' || d.dir !== 'down') &&
                                           (gameState.direction !== 'right' || d.dir !== 'left') &&
                                           (gameState.direction !== 'left' || d.dir !== 'right')
                                       ) {
                                           const newHead = { x: head.x + d.vec.x, y: head.y + d.vec.y };
                                           if (
                                               newHead.x >= 0 && newHead.x < canvas.width / gameState.gridSize &&
                                               newHead.y >= 0 && newHead.y < canvas.height / gameState.gridSize &&
                                               !checkCollision(newHead, gameState.snake)
                                           ) {
                                               possibleMoves.push(d);
                                           }
                                       }
                                   });

                                   if (possibleMoves.length > 0) {
                                       // Prefer moves that get closer to food
                                       possibleMoves.sort((a, b) => {
                                           const distA = Math.abs((head.x + a.vec.x) - gameState.food.x) + Math.abs((head.y + a.vec.y) - gameState.food.y);
                                           const distB = Math.abs((head.x + b.vec.x) - gameState.food.x) + Math.abs((head.y + b.vec.y) - gameState.food.y);
                                           return distA - distB;
                                       });
                                       gameState.nextDirection = possibleMoves[0].dir; // Choose best move
                                   } else {
                                       // No safe moves, let it crash or pick a random valid one
                                       // This simple AI might crash if cornered.
                                   }
                                   gameState.direction = gameState.nextDirection; // Apply AI decision
                                }
                                // --- End AI Logic ---

                                const head = { ...gameState.snake[0] };
                                switch (gameState.direction) {
                                    case 'up': head.y--; break;
                                    case 'down': head.y++; break;
                                    case 'left': head.x--; break;
                                    case 'right': head.x++; break;
                                }

                                if (head.x < 0 || head.x >= canvas.width / gameState.gridSize ||
                                    head.y < 0 || head.y >= canvas.height / gameState.gridSize ||
                                    checkCollision(head, gameState.snake)) {
                                    gameState.gameOver = true;
                                    SoundManager.play('error');
                                    checkAchievement('snake_master', gameState.score >= 500, { score: gameState.score });
                                    updateScores('snake', gameState.score);
                                    return;
                                }

                                gameState.snake.unshift(head);

                                if (head.x === gameState.food.x && head.y === gameState.food.y) {
                                    gameState.score += 10 * gameState.level; // Score based on level
                                    SoundManager.play('eat');
                                    scoreAnnouncer.textContent = `Score: ${gameState.score}`;
                                    scoreSpan.textContent = `Score: ${gameState.score}`;
                                    placeFood();
                                    updateLevel(); // Check for level up
                                } else {
                                    gameState.snake.pop();
                                }
                            }
                            requestAnimationFrame(update);
                        };

                        const draw = () => {
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-background');
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // Draw grid background
                            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--color-border');
                            ctx.lineWidth = 0.5;
                            for (let x = 0; x <= canvas.width; x += gameState.gridSize) {
                                ctx.beginPath();
                                ctx.moveTo(x, 0);
                                ctx.lineTo(x, canvas.height);
                                ctx.stroke();
                            }
                            for (let y = 0; y <= canvas.height; y += gameState.gridSize) {
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(canvas.width, y);
                                ctx.stroke();
                            }

                            // Draw food
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-accent');
                            ctx.beginPath();
                            const foodCenterX = gameState.food.x * gameState.gridSize + gameState.gridSize / 2;
                            const foodCenterY = gameState.food.y * gameState.gridSize + gameState.gridSize / 2;
                            const foodRadius = gameState.gridSize / 2 - 2;
                            ctx.arc(foodCenterX, foodCenterY, foodRadius, 0, Math.PI * 2);
                            ctx.fill();

                            // Draw snake with interpolation
                            const snakeColor = aiMode ? getComputedStyle(document.body).getPropertyValue('--color-warning') : getComputedStyle(document.body).getPropertyValue('--color-secondary');
                            ctx.fillStyle = snakeColor;
                            for (let i = 0; i < gameState.snake.length; i++) {
                                const segment = gameState.snake[i];
                                let x = segment.x * gameState.gridSize;
                                let y = segment.y * gameState.gridSize;
                                if (i === 0 && gameState.interpolation > 0) {
                                    const nextX = segment.x;
                                    const nextY = segment.y;
                                    switch (gameState.direction) {
                                        case 'left': x = (nextX + gameState.interpolation) * gameState.gridSize; break;
                                        case 'right': x = (nextX - gameState.interpolation) * gameState.gridSize; break;
                                        case 'up': y = (nextY + gameState.interpolation) * gameState.gridSize; break;
                                        case 'down': y = (nextY - gameState.interpolation) * gameState.gridSize; break;
                                    }
                                }
                                ctx.fillRect(x + 1, y + 1, gameState.gridSize - 2, gameState.gridSize - 2); // Add small margin
                                // Draw eyes on head
                                if (i === 0) {
                                    ctx.fillStyle = 'black';
                                    const eyeSize = gameState.gridSize / 5;
                                    let eye1X, eye1Y, eye2X, eye2Y;
                                    switch(gameState.direction) {
                                        case 'right':
                                            eye1X = x + gameState.gridSize - eyeSize * 2; eye1Y = y + eyeSize * 2;
                                            eye2X = x + gameState.gridSize - eyeSize * 2; eye2Y = y + gameState.gridSize - eyeSize * 3;
                                            break;
                                        case 'left':
                                            eye1X = x + eyeSize; eye1Y = y + eyeSize * 2;
                                            eye2X = x + eyeSize; eye2Y = y + gameState.gridSize - eyeSize * 3;
                                            break;
                                        case 'up':
                                            eye1X = x + eyeSize * 2; eye1Y = y + eyeSize;
                                            eye2X = x + gameState.gridSize - eyeSize * 3; eye2Y = y + eyeSize;
                                            break;
                                        case 'down':
                                            eye1X = x + eyeSize * 2; eye1Y = y + gameState.gridSize - eyeSize * 2;
                                            eye2X = x + gameState.gridSize - eyeSize * 3; eye2Y = y + gameState.gridSize - eyeSize * 2;
                                            break;
                                    }
                                    ctx.fillRect(eye1X, eye1Y, eyeSize, eyeSize);
                                    ctx.fillRect(eye2X, eye2Y, eyeSize, eyeSize);
                                    ctx.fillStyle = snakeColor; // Reset fill style
                                }
                            }

                            if (gameState.gameOver) {
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = 'white';
                                ctx.font = 'bold 24px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 20);
                                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 20);
                                ctx.textAlign = 'left';
                            } else if (gameState.paused) {
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = 'white';
                                ctx.font = 'bold 24px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
                                ctx.textAlign = 'left';
                            }
                        };

                        const gameLoop = () => {
                            draw();
                            requestAnimationFrame(gameLoop);
                        };

                        const handleKeyDown = (e) => {
                            switch (e.key) {
                                case 'ArrowUp': case 'w': case 'W':
                                    if (gameState.direction !== 'down') gameState.nextDirection = 'up'; break;
                                case 'ArrowDown': case 's': case 'S':
                                    if (gameState.direction !== 'up') gameState.nextDirection = 'down'; break;
                                case 'ArrowLeft': case 'a': case 'A':
                                    if (gameState.direction !== 'right') gameState.nextDirection = 'left'; break;
                                case 'ArrowRight': case 'd': case 'D':
                                    if (gameState.direction !== 'left') gameState.nextDirection = 'right'; break;
                                case ' ': gameState.paused = !gameState.paused; break;
                            }
                        };

                        // Initialize game
                        placeFood();
                        requestAnimationFrame(update);
                        requestAnimationFrame(gameLoop);
                        document.addEventListener('keydown', handleKeyDown);

                        // Return game API
                        return {
                            destroy() {
                                document.removeEventListener('keydown', handleKeyDown);
                                container.innerHTML = '';
                            },
                            pause() { gameState.paused = true; },
                            resume() { gameState.paused = false; gameState.lastUpdate = 0; },
                            restart() {
                                gameState.snake = [{x: 10, y: 10}];
                                gameState.direction = 'right';
                                gameState.nextDirection = 'right';
                                gameState.score = 0;
                                gameState.gameOver = false;
                                gameState.paused = false;
                                gameState.level = 1;
                                gameState.speed = gameState.baseSpeed;
                                gameState.foodEatenThisLevel = 0;
                                gameState.lastUpdate = 0;
                                gameState.interpolation = 0;
                                scoreSpan.textContent = `Score: ${gameState.score}`;
                                levelSpan.textContent = `Level: ${gameState.level}`;
                                placeFood();
                                scoreAnnouncer.textContent = 'Game restarted';
                                SoundManager.play('click');
                            }
                        };
                    }
                },

                // ===== Enhanced Tic-Tac-Toe with 1P/2P =====
                 tictactoe: {
                    id: 'tictactoe',
                    title: 'Tic-Tac-Toe',
                    description: 'Classic X and O game. Play against AI or a friend!',
                    icon: '⭕',
                    init(container) {
                        let currentPlayer = 'X';
                        let gameBoard = ['', '', '', '', '', '', '', '', ''];
                        let gameActive = true;
                        let playerScore = scores.tictactoe?.playerWins || 0;
                        let aiScore = scores.tictactoe?.aiWins || 0;
                        let draws = scores.tictactoe?.draws || 0;
                        let isTwoPlayer = false; // Default to 1P vs AI

                        const gameElement = create('div', { className: 'tictactoe-game-ui' }); // Use new class
                        const boardElement = create('div', { className: 'tictactoe-board' });
                        const statusElement = create('div', { className: 'tictactoe-status', textContent: `Player ${currentPlayer}'s turn` });
                        const scoreElement = create('div', { className: 'tictactoe-score', textContent: `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}` });

                        // Mode Selector
                        const modeSelector = create('div', { className: 'tictactoe-mode-selector' });
                        const modeLabel = create('span', { textContent: 'Mode:' });
                        const onePButton = create('button', { className: 'btn btn-secondary active', textContent: '1 Player (vs AI)' });
                        const twoPButton = create('button', { className: 'btn btn-secondary', textContent: '2 Players' });

                        onePButton.addEventListener('click', () => {
                            isTwoPlayer = false;
                            onePButton.classList.add('active');
                            twoPButton.classList.remove('active');
                            this.restart(); // Restart on mode change
                        });
                        twoPButton.addEventListener('click', () => {
                            isTwoPlayer = true;
                            twoPButton.classList.add('active');
                            onePButton.classList.remove('active');
                            this.restart(); // Restart on mode change
                        });
                        modeSelector.append(modeLabel, onePButton, twoPButton);

                        // Create cells
                        const cells = [];
                        for (let i = 0; i < 9; i++) {
                            const cell = create('div', {
                                className: 'tictactoe-cell',
                                dataset: { index: i },
                                onclick: () => handleCellClick(i)
                            });
                            cells.push(cell);
                            boardElement.appendChild(cell);
                        }

                        gameElement.append(modeSelector, boardElement, statusElement, scoreElement); // Add mode selector first
                        container.appendChild(gameElement);

                        function handleCellClick(index) {
                            if (!gameActive || gameBoard[index] !== '') return;

                            makeMove(index, currentPlayer);

                            // Handle AI move if it's 1P and AI's turn (O)
                            if (gameActive && !isTwoPlayer && currentPlayer === 'O') {
                                // Simple AI: pick a random empty spot (can be improved)
                                setTimeout(() => {
                                    // --- Improved AI Logic (Minimax would be better, this is a step up) ---
                                    let bestMove = -1;
                                    let bestScore = -Infinity;

                                    // Check for winning move
                                    for (let i = 0; i < 9; i++) {
                                        if (gameBoard[i] === '') {
                                            gameBoard[i] = 'O';
                                            if (checkWin()) {
                                                bestMove = i;
                                                gameBoard[i] = ''; // Reset
                                                break;
                                            }
                                            gameBoard[i] = ''; // Reset
                                        }
                                    }

                                    // If no winning move, block player win
                                    if (bestMove === -1) {
                                         for (let i = 0; i < 9; i++) {
                                            if (gameBoard[i] === '') {
                                                gameBoard[i] = 'X';
                                                if (checkWin()) {
                                                    bestMove = i;
                                                    gameBoard[i] = ''; // Reset
                                                    break;
                                                }
                                                gameBoard[i] = ''; // Reset
                                            }
                                        }
                                    }

                                    // If still no move, pick center/corner/random
                                    if (bestMove === -1) {
                                        const preferredMoves = [4, 0, 2, 6, 8]; // Center, then corners
                                        const availablePreferred = preferredMoves.filter(i => gameBoard[i] === '');
                                        if (availablePreferred.length > 0) {
                                            bestMove = availablePreferred[0];
                                        } else {
                                            const emptyIndices = gameBoard.map((val, idx) => val === '' ? idx : null).filter(val => val !== null);
                                            if (emptyIndices.length > 0) {
                                                bestMove = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
                                            }
                                        }
                                    }
                                    // --- End Improved AI Logic ---

                                    if (bestMove !== -1) {
                                        makeMove(bestMove, 'O');
                                    }
                                }, 500); // Slight delay for AI move
                            }
                        }

                        function makeMove(index, player) {
                            gameBoard[index] = player;
                            cells[index].textContent = player;
                            if (checkWin()) {
                                gameActive = false;
                                statusElement.textContent = `${player} wins!`;
                                if (player === 'X') {
                                    playerScore++;
                                    checkAchievement('tic_master', playerScore >= 5, { wins: playerScore });
                                } else {
                                    if (isTwoPlayer) {
                                        playerScore++; // Player O wins in 2P mode
                                    } else {
                                        aiScore++; // AI wins in 1P mode
                                    }
                                }
                                updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                                scoreElement.textContent = `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}`;
                                highlightWinningCells();
                                SoundManager.play(player === 'X' ? 'success' : 'error');
                            } else if (checkDraw()) {
                                gameActive = false;
                                statusElement.textContent = "It's a draw!";
                                draws++;
                                updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                                scoreElement.textContent = `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}`;
                                SoundManager.play('click');
                            } else {
                                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                                statusElement.textContent = `Player ${currentPlayer}'s turn`;
                                SoundManager.play('click');
                            }
                        }

                        function checkWin() {
                            const winPatterns = [
                                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                                [0, 4, 8], [2, 4, 6]
                            ];
                            for (const pattern of winPatterns) {
                                const [a, b, c] = pattern;
                                if (gameBoard[a] && gameBoard[a] === gameBoard[b] && gameBoard[a] === gameBoard[c]) {
                                    return { pattern };
                                }
                            }
                            return null;
                        }

                        function checkDraw() {
                            return !gameBoard.includes('');
                        }

                        function highlightWinningCells() {
                            const winResult = checkWin();
                            if (winResult) {
                                winResult.pattern.forEach(index => {
                                    cells[index].classList.add('win');
                                });
                            }
                        }

                        return {
                            destroy() { container.innerHTML = ''; },
                            pause() { /* Pause logic if needed */ },
                            resume() { /* Resume logic if needed */ },
                            restart() {
                                gameBoard = ['', '', '', '', '', '', '', '', ''];
                                currentPlayer = 'X';
                                gameActive = true;
                                statusElement.textContent = `Player ${currentPlayer}'s turn`;
                                cells.forEach(cell => {
                                    cell.textContent = '';
                                    cell.classList.remove('win');
                                });
                                // Update score display in case mode changed
                                scoreElement.textContent = `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}`;
                                SoundManager.play('click');
                            }
                        };
                    }
                },


                // Memory Match Game (Placeholder for now, can be enhanced)
                memory: {
                    id: 'memory',
                    title: 'Memory Match',
                    description: 'Find matching pairs of cards',
                    icon: '🎴',
                    init(container) {
                        const emojis = ['😀', '😎', '🥳', '🤖', '👾', '🐱', '🐶', '🦊'];
                        let gameCards = [...emojis, ...emojis];
                        gameCards = gameCards.sort(() => 0.5 - Math.random());
                        let flippedCards = [];
                        let matchedPairs = 0;
                        let moves = 0;
                        let gameStarted = false;
                        let timerInterval = null;
                        let seconds = 0;
                        const bestTime = scores.memory?.bestTime || null;
                        const gameElement = create('div', { className: 'memory-game' });
                        const boardElement = create('div', { className: 'memory-board' });
                        const movesElement = create('div', { className: 'game-moves', textContent: `Moves: ${moves}` });
                        const timerElement = create('div', { className: 'game-timer', textContent: `Time: ${seconds}s` });
                        const bestTimeElement = create('div', { className: 'game-best-time', textContent: bestTime ? `Best: ${bestTime}s` : 'Best: --' });
                        const restartButton = create('button', { className: 'btn btn-secondary', textContent: 'Restart' });
                        restartButton.addEventListener('click', restartGame);
                        const cards = gameCards.map((emoji, index) => {
                            const card = create('div', {
                                className: 'memory-card',
                                textContent: '', // Start empty
                                onclick: () => flipCard(card, index)
                            });
                            card.dataset.emoji = emoji;
                            card.dataset.index = index;
                            return card;
                        });
                        boardElement.append(...cards);
                        gameElement.append(boardElement, movesElement, timerElement, bestTimeElement, restartButton);
                        container.appendChild(gameElement);
                        function startTimer() {
                            if (!gameStarted) {
                                gameStarted = true;
                                timerInterval = setInterval(() => {
                                    seconds++;
                                    timerElement.textContent = `Time: ${seconds}s`;
                                }, 1000);
                            }
                        }
                        function flipCard(card, index) {
                            if (flippedCards.length === 2 || card.classList.contains('flipped') || card.classList.contains('matched')) {
                                return;
                            }
                            startTimer();
                            card.classList.add('flipped');
                            card.textContent = card.dataset.emoji;
                            flippedCards.push({ card, index });
                            if (flippedCards.length === 2) {
                                moves++;
                                movesElement.textContent = `Moves: ${moves}`;
                                const card1 = flippedCards[0];
                                const card2 = flippedCards[1];
                                if (gameCards[card1.index] === gameCards[card2.index]) {
                                    card1.card.classList.add('matched');
                                    card2.card.classList.add('matched');
                                    flippedCards = [];
                                    matchedPairs++;
                                    SoundManager.play('success');
                                    if (matchedPairs === emojis.length) {
                                        clearInterval(timerInterval);
                                        checkAchievement('memory_champ', moves <= 20, { moves, time: seconds });
                                        if (!bestTime || seconds < bestTime) {
                                            updateScores('memory', { bestTime: seconds });
                                            bestTimeElement.textContent = `Best: ${seconds}s`;
                                            Toast.show(`New Best Time: ${seconds}s!`, 'success');
                                        }
                                        setTimeout(() => {
                                            alert(`Congratulations! You finished in ${moves} moves and ${seconds} seconds.`);
                                        }, 500);
                                    }
                                } else {
                                    setTimeout(() => {
                                        card1.card.classList.remove('flipped');
                                        card2.card.classList.remove('flipped');
                                        card1.card.textContent = '';
                                        card2.card.textContent = '';
                                        flippedCards = [];
                                    }, 1000);
                                    SoundManager.play('error');
                                }
                            }
                        }
                        function restartGame() {
                            clearInterval(timerInterval);
                            gameCards = [...emojis, ...emojis].sort(() => 0.5 - Math.random());
                            flippedCards = [];
                            matchedPairs = 0;
                            moves = 0;
                            gameStarted = false;
                            seconds = 0;
                            movesElement.textContent = `Moves: ${moves}`;
                            timerElement.textContent = `Time: ${seconds}s`;
                            cards.forEach((card, index) => {
                                card.classList.remove('flipped', 'matched');
                                card.textContent = '';
                                card.dataset.emoji = gameCards[index];
                            });
                            SoundManager.play('click');
                        }
                        return {
                            destroy() {
                                clearInterval(timerInterval);
                                container.innerHTML = '';
                            },
                            pause() {
                                if (timerInterval) clearInterval(timerInterval);
                            },
                            resume() {
                                if (gameStarted && matchedPairs < emojis.length) {
                                     timerInterval = setInterval(() => {
                                        seconds++;
                                        timerElement.textContent = `Time: ${seconds}s`;
                                    }, 1000);
                                }
                            },
                            restart: restartGame
                        };
                    }
                },

                // Reaction Tester Game (Placeholder)
                reaction: {
                    id: 'reaction',
                    title: 'Reaction Tester',
                    description: 'Test your reaction speed',
                    icon: '⏱️',
                    init(container) {
                        let state = 'ready';
                        let startTime, endTime;
                        let bestTime = scores.reaction?.bestTime !== undefined ? scores.reaction.bestTime : null;
                        let attempts = scores.reaction?.attempts || 0;
                        const gameElement = create('div', { className: 'reaction-game' });
                        const displayElement = create('div', {
                            className: 'reaction-display reaction-ready',
                            textContent: 'Click to Start'
                        });
                        const resultElement = create('div', { className: 'reaction-result', textContent: bestTime ? `Best: ${bestTime.toFixed(3)}s` : 'Best: --' });
                        const attemptsElement = create('div', { className: 'reaction-attempts', textContent: `Attempts: ${attempts}` });
                        displayElement.addEventListener('click', handleClick);
                        gameElement.append(displayElement, resultElement, attemptsElement);
                        container.appendChild(gameElement);
                        function handleClick() {
                            if (state === 'ready') {
                                state = 'wait';
                                displayElement.className = 'reaction-display reaction-wait';
                                displayElement.textContent = 'Wait...';
                                const delay = Math.random() * 3000 + 1000;
                                setTimeout(() => {
                                    if (state === 'wait') {
                                        state = 'go';
                                        startTime = Date.now();
                                        displayElement.className = 'reaction-display reaction-go';
                                        displayElement.textContent = 'CLICK NOW!';
                                    }
                                }, delay);
                                SoundManager.play('click');
                            } else if (state === 'wait') {
                                state = 'ready';
                                displayElement.className = 'reaction-display reaction-ready';
                                displayElement.textContent = 'Too Early! Click to Restart';
                                SoundManager.play('error');
                            } else if (state === 'go') {
                                endTime = Date.now();
                                const reactionTime = (endTime - startTime) / 1000;
                                state = 'result';
                                displayElement.className = 'reaction-display reaction-ready';
                                displayElement.textContent = 'Click to Restart';
                                resultElement.textContent = `Reaction Time: ${reactionTime.toFixed(3)}s`;
                                attempts++;
                                attemptsElement.textContent = `Attempts: ${attempts}`;
                                if (bestTime === null || reactionTime < bestTime) {
                                    bestTime = reactionTime;
                                    updateScores('reaction', { bestTime: bestTime, attempts: attempts });
                                    resultElement.textContent += ' (New Best!)';
                                    checkAchievement('speed_demon', bestTime < 0.2, { time: bestTime });
                                } else {
                                    updateScores('reaction', { attempts: attempts });
                                }
                                SoundManager.play('success');
                            } else if (state === 'result') {
                                state = 'ready';
                                displayElement.className = 'reaction-display reaction-ready';
                                displayElement.textContent = 'Click to Start';
                                resultElement.textContent = bestTime ? `Best: ${bestTime.toFixed(3)}s` : 'Best: --';
                                SoundManager.play('click');
                            }
                        }
                        return {
                            destroy() { container.innerHTML = ''; },
                            pause() { /* Pause logic */ },
                            resume() { /* Resume logic */ },
                            restart() {
                                state = 'ready';
                                displayElement.className = 'reaction-display reaction-ready';
                                displayElement.textContent = 'Click to Start';
                                resultElement.textContent = bestTime ? `Best: ${bestTime.toFixed(3)}s` : 'Best: --';
                                SoundManager.play('click');
                            }
                        };
                    }
                },

                // Whack-a-Doodle Game (Placeholder)
                 whack: {
                    id: 'whack',
                    title: 'Whack-a-Doodle',
                    description: 'Whack the doodles as they appear',
                    icon: '🔨',
                    init(container) {
                        let score = 0;
                        let timeLeft = 30;
                        let gameActive = false;
                        let timerInterval = null;
                        let popInterval = null;
                        const highScore = scores.whack?.highScore || 0;
                        const gameElement = create('div', { className: 'whack-game' });
                        const boardElement = create('div', { className: 'whack-board' });
                        const scoreElement = create('div', { className: 'whack-score', textContent: `Score: ${score}` });
                        const timeElement = create('div', { className: 'whack-time', textContent: `Time: ${timeLeft}s` });
                        const highScoreElement = create('div', { className: 'whack-high-score', textContent: `High Score: ${highScore}` });
                        const startButton = create('button', { className: 'btn btn-primary', textContent: 'Start Game' });
                        const holes = [];
                        for (let i = 0; i < 9; i++) {
                            const hole = create('div', { className: 'whack-hole' });
                            const doodle = create('div', { className: 'whack-doodle', textContent: '🤪' });
                            doodle.addEventListener('click', () => whackDoodle(doodle));
                            hole.appendChild(doodle);
                            holes.push(hole);
                            boardElement.appendChild(hole);
                        }
                        startButton.addEventListener('click', startGame);
                        gameElement.append(boardElement, scoreElement, timeElement, highScoreElement, startButton);
                        container.appendChild(gameElement);
                        function startGame() {
                            if (gameActive) return;
                            gameActive = true;
                            score = 0;
                            timeLeft = 30;
                            scoreElement.textContent = `Score: ${score}`;
                            timeElement.textContent = `Time: ${timeLeft}s`;
                            startButton.disabled = true;
                            startButton.textContent = 'Game On!';
                            timerInterval = setInterval(() => {
                                timeLeft--;
                                timeElement.textContent = `Time: ${timeLeft}s`;
                                if (timeLeft <= 0) {
                                    endGame();
                                }
                            }, 1000);
                            popInterval = setInterval(popDoodle, 800);
                            SoundManager.play('click');
                        }
                        function popDoodle() {
                            if (!gameActive) return;
                            holes.forEach(hole => {
                                const doodle = hole.querySelector('.whack-doodle');
                                doodle.classList.remove('up');
                            });
                            const randomHole = holes[Math.floor(Math.random() * holes.length)];
                            const doodle = randomHole.querySelector('.whack-doodle');
                            doodle.classList.add('up');
                            setTimeout(() => {
                                if (gameActive) {
                                    doodle.classList.remove('up');
                                }
                            }, 600);
                        }
                        function whackDoodle(doodle) {
                            if (!gameActive || !doodle.classList.contains('up')) return;
                            score++;
                            scoreElement.textContent = `Score: ${score}`;
                            doodle.classList.remove('up');
                            SoundManager.play('success');
                            checkAchievement('whack_streak', score >= 30, { score });
                        }
                        function endGame() {
                            gameActive = false;
                            clearInterval(timerInterval);
                            clearInterval(popInterval);
                            startButton.disabled = false;
                            startButton.textContent = 'Start Game';
                            holes.forEach(hole => {
                                const doodle = hole.querySelector('.whack-doodle');
                                doodle.classList.remove('up');
                            });
                            if (score > highScore) {
                                updateScores('whack', score);
                                highScoreElement.textContent = `High Score: ${score}`;
                                Toast.show(`New High Score: ${score}!`, 'success');
                            }
                            SoundManager.play('click');
                        }
                        return {
                            destroy() {
                                clearInterval(timerInterval);
                                clearInterval(popInterval);
                                container.innerHTML = '';
                            },
                            pause() {
                                if (gameActive) {
                                    clearInterval(timerInterval);
                                    clearInterval(popInterval);
                                }
                            },
                            resume() {
                                if (gameActive) {
                                    timerInterval = setInterval(() => {
                                        timeLeft--;
                                        timeElement.textContent = `Time: ${timeLeft}s`;
                                        if (timeLeft <= 0) {
                                            endGame();
                                        }
                                    }, 1000);
                                    popInterval = setInterval(popDoodle, 800);
                                }
                            },
                            restart() {
                                if (gameActive) {
                                    endGame();
                                }
                                setTimeout(startGame, 100);
                            }
                        };
                    }
                },

                // Dice Game (Placeholder)
                 dice: {
                    id: 'dice',
                    title: 'Guess & Dice',
                    description: 'Guess numbers and roll dice',
                    icon: '🎲',
                    init(container) {
                        let totalScore = scores.dice?.totalScore || 0;
                        let rolls = scores.dice?.rolls || 0;
                        let correctGuesses = scores.dice?.correctGuesses || 0;
                        const gameElement = create('div', { className: 'dice-game' });
                        const displayElement = create('div', { className: 'dice-display' });
                        const guessLabel = create('label', { className: 'form-label', textContent: 'Guess (1-6):' });
                        const guessInput = create('input', { className: 'form-control dice-guess-input', type: 'number', min: '1', max: '6', value: '1' });
                        const rollButton = create('button', { className: 'btn btn-primary', textContent: 'Roll Dice' });
                        const resultElement = create('div', { className: 'dice-result', textContent: 'Roll the dice!' });
                        const statsElement = create('div', { className: 'dice-stats', textContent: `Total Score: ${totalScore} | Rolls: ${rolls} | Correct: ${correctGuesses}` });
                        const diceContainer = create('div', { className: 'dice-rolls' });
                        const dice1 = create('div', { className: 'dice', textContent: '?' });
                        const dice2 = create('div', { className: 'dice', textContent: '?' });
                        diceContainer.append(dice1, dice2);
                        rollButton.addEventListener('click', rollDice);
                        displayElement.append(guessLabel, guessInput, diceContainer, rollButton, resultElement, statsElement);
                        gameElement.appendChild(displayElement);
                        container.appendChild(gameElement);
                        function rollDice() {
                            const userGuess = parseInt(guessInput.value);
                            if (isNaN(userGuess) || userGuess < 1 || userGuess > 6) {
                                resultElement.textContent = 'Please enter a valid guess (1-6).';
                                return;
                            }
                            const roll1 = Math.floor(Math.random() * 6) + 1;
                            const roll2 = Math.floor(Math.random() * 6) + 1;
                            const sum = roll1 + roll2;
                            dice1.textContent = roll1;
                            dice2.textContent = roll2;
                            rolls++;
                            let roundScore = 0;
                            let message = `You rolled ${sum}. `;
                            if (userGuess === roll1 || userGuess === roll2) {
                                roundScore += 10;
                                correctGuesses++;
                                message += 'Correct guess! +10 points. ';
                                checkAchievement('lucky_roller', correctGuesses >= 10, { correct: correctGuesses });
                                SoundManager.play('success');
                            } else {
                                message += 'No match. ';
                                SoundManager.play('click');
                            }
                            if (sum === 7) {
                                roundScore += 5;
                                message += 'Lucky 7! +5 points.';
                                SoundManager.play('success');
                            }
                            totalScore += roundScore;
                            resultElement.textContent = message;
                            statsElement.textContent = `Total Score: ${totalScore} | Rolls: ${rolls} | Correct: ${correctGuesses}`;
                            updateScores('dice', { totalScore, rolls, correctGuesses });
                        }
                        return {
                            destroy() { container.innerHTML = ''; },
                            pause() { /* Pause logic */ },
                            resume() { /* Resume logic */ },
                            restart() {
                                guessInput.value = '1';
                                dice1.textContent = '?';
                                dice2.textContent = '?';
                                resultElement.textContent = 'Roll the dice!';
                                SoundManager.play('click');
                            }
                        };
                    }
                },

                // Placeholder for Runner (can be expanded)
                runner: {
                    id: 'runner',
                    title: 'Shaikh\'s Runner',
                    description: 'Endless runner game (Placeholder)',
                    icon: '🏃',
                    init(container) {
                        const gameElement = create('div', { className: 'runner-game' });
                        const canvas = create('canvas', {
                            className: 'runner-canvas',
                            width: 600,
                            height: 200
                        });
                        const ctx = canvas.getContext('2d');
                        const startButton = create('button', { className: 'btn btn-primary', textContent: 'Start Runner' });
                        startButton.addEventListener('click', () => {
                             // Simple animation demo
                            let x = 0;
                            function animate() {
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-text');
                                ctx.font = '20px sans-serif';
                                ctx.fillText('🏃 Runner Game Placeholder', 10, 50);
                                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-secondary');
                                ctx.fillRect(x, 150, 50, 50); // Simple moving block
                                x = (x + 2) % canvas.width;
                                requestAnimationFrame(animate);
                            }
                            animate();
                            startButton.disabled = true;
                            startButton.textContent = 'Running...';
                        });
                        gameElement.append(canvas, startButton);
                        container.appendChild(gameElement);
                        return {
                            destroy() { container.innerHTML = ''; },
                            pause() { /* Pause logic */ },
                            resume() { /* Resume logic */ },
                            restart() { /* Restart logic */ }
                        };
                    }
                }
            };


            // Register games
            function registerGames() {
                for (const gameId in GameModules) {
                    gamesRegistry[gameId] = GameModules[gameId];
                }
            }

            // Create game preview
            function createGamePreview(gameId) {
                const preview = create('div', { className: 'game-preview' });
                switch (gameId) {
                    case 'snake':
                        preview.innerHTML = '<p>🐍 Moving snake preview</p>';
                        break;
                    case 'tictactoe':
                        preview.innerHTML = '<p>⭕ XO animation</p>';
                        break;
                    case 'memory':
                        preview.innerHTML = '<p>🎴 Flipping cards</p>';
                        break;
                    case 'reaction':
                        preview.innerHTML = '<p>⏱️ Pulsing circle</p>';
                        break;
                    case 'whack':
                        preview.innerHTML = '<p>🔨 Popping shapes</p>';
                        break;
                    case 'dice':
                        preview.innerHTML = '<p>🎲 Rolling dice</p>';
                        break;
                    case 'runner':
                        preview.innerHTML = '<p>🏃 Running character</p>';
                        break;
                }
                return preview;
            }

            // Render game tiles (Main Grid)
            function renderGameTiles() {
                gamesGrid.innerHTML = '';
                for (const gameId in gamesRegistry) {
                    const game = gamesRegistry[gameId];
                    const tile = create('div', {
                        className: 'game-tile',
                        tabIndex: 0,
                        onclick: () => openGame(gameId),
                        onkeydown: (e) => { if (e.key === 'Enter' || e.key === ' ') openGame(gameId); }
                    }, [
                        create('div', { className: 'game-icon', innerHTML: game.icon }),
                        create('h3', { className: 'game-title', textContent: game.title }),
                        create('p', { className: 'game-description', textContent: game.description }),
                        createGamePreview(gameId)
                    ]);
                    gamesGrid.appendChild(tile);
                    addRippleEffect(tile);
                }
            }

            // Render game list (Sidebar)
            function renderGameList() {
                gamesList.innerHTML = '';
                for (const gameId in gamesRegistry) {
                    const game = gamesRegistry[gameId];
                    const listItem = create('li', {
                        className: 'game-list-item',
                        onclick: () => openGame(gameId)
                    }, [
                        create('span', { className: 'game-list-icon', innerHTML: game.icon }),
                        create('span', { className: 'game-list-text', textContent: game.title })
                    ]);
                    gamesList.appendChild(listItem);
                    // Highlight active game in list
                    if (gameId === activeGameId) {
                         listItem.classList.add('active');
                    }
                }
            }

             // Update active game highlight in sidebar
            function updateActiveGameHighlight(gameId) {
                activeGameId = gameId;
                qsa('.game-list-item', gamesList).forEach(item => {
                    item.classList.remove('active');
                    // Find the item corresponding to the active game
                    if (item.querySelector('.game-list-text').textContent === gamesRegistry[gameId]?.title) {
                        item.classList.add('active');
                    }
                });
            }

            // Open a game
            function openGame(gameId) {
                const game = gamesRegistry[gameId];
                if (!game) return;
                if (activeGame) {
                    activeGame.destroy();
                    activeGame = null;
                }
                currentGameTitle.textContent = game.title;
                gameContent.innerHTML = '';
                gameView.classList.add('active');
                activeGame = game.init(gameContent);
                gameContent.setAttribute('tabindex', '-1');
                gameContent.focus();
                SoundManager.play('click');
                updateActiveGameHighlight(gameId); // Highlight in sidebar
                // Hide sidebar on mobile after selection
                if (window.innerWidth <= 768) {
                    gameSidebar.classList.add('hidden');
                }
            }

            // Close the current game
            function closeGame() {
                if (activeGame) {
                    activeGame.destroy();
                    activeGame = null;
                }
                gameView.classList.remove('active');
                gamesGrid.setAttribute('tabindex', '-1');
                gamesGrid.focus();
                gamesGrid.removeAttribute('tabindex');
                SoundManager.play('click');
                updateActiveGameHighlight(null); // Remove highlight
            }

            // Toggle sidebar visibility (mobile)
            function toggleSidebarVisibility() {
                 gameSidebar.classList.toggle('hidden');
            }

            // Initialize the application
            function init() {
                SoundManager.init();
                loadData();
                applySettings();
                registerGames();
                renderGameTiles();
                renderGameList(); // Render sidebar list
                qsa('button').forEach(button => {
                    if (!button.classList.contains('tictactoe-cell') &&
                        !button.classList.contains('memory-card') &&
                        !button.classList.contains('whack-doodle')) {
                         addRippleEffect(button);
                    }
                });

                // Event Listeners
                backButton.addEventListener('click', closeGame);
                soundToggle.addEventListener('click', () => {
                    settings.soundOn = !settings.soundOn;
                    applySettings();
                    saveData();
                    SoundManager.play('click');
                });
                themeToggle.addEventListener('click', () => {
                    settings.theme = settings.theme === 'light' ? 'dark' : 'light';
                    applySettings();
                    saveData();
                    SoundManager.play('click');
                });
                settingsButton.addEventListener('click', () => {
                    settingsModal.classList.add('active');
                    SoundManager.play('click');
                });
                profileButton.addEventListener('click', () => {
                    profileModal.classList.add('active');
                    SoundManager.play('click');
                    const achievementsList = qs('#achievementsList');
                    const highScoresList = qs('#highScoresList');
                    achievementsList.innerHTML = '';
                    highScoresList.innerHTML = '';
                    let hasAchievements = false;
                    for (const [id, achievement] of Object.entries(achievements)) {
                        if (achievement.unlocked) {
                            hasAchievements = true;
                            const achievementEl = create('div', {
                                className: 'achievement-item',
                                innerHTML: `
                                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                        <span style="font-size: 24px; margin-right: 10px;">🏆</span>
                                        <div>
                                            <strong>${id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</strong>
                                            <p>Unlocked on ${new Date(achievement.timestamp).toLocaleDateString()}</p>
                                        </div>
                                    </div>
                                `
                            });
                            achievementsList.appendChild(achievementEl);
                        }
                    }
                    if (!hasAchievements) {
                        achievementsList.innerHTML = '<p>No achievements yet. Start playing!</p>';
                    }
                    let hasScores = false;
                    for (const [gameId, gameScores] of Object.entries(scores)) {
                        hasScores = true;
                        const scoreEl = create('div', {
                            className: 'score-item',
                            innerHTML: `
                                <h5>${gameId.replace(/\b\w/g, l => l.toUpperCase())}</h5>
                                <pre style="white-space: pre-wrap;">${JSON.stringify(gameScores, null, 2)}</pre>
                            `
                        });
                        highScoresList.appendChild(scoreEl);
                    }
                     if (!hasScores) {
                        highScoresList.innerHTML = '<p>No scores recorded yet.</p>';
                    }
                });
                gamePause.addEventListener('click', () => {
                    if (activeGame && activeGame.pause) {
                        activeGame.pause();
                        SoundManager.play('click');
                    }
                });
                gameRestart.addEventListener('click', () => {
                    if (activeGame && activeGame.restart) {
                        activeGame.restart();
                        SoundManager.play('click');
                    }
                });
                gameInfo.addEventListener('click', () => {
                    Toast.show('Game information would appear here', 'info');
                    SoundManager.play('click');
                });
                closeSettings.addEventListener('click', () => {
                    settingsModal.classList.remove('active');
                    SoundManager.play('click');
                });
                closeProfile.addEventListener('click', () => {
                    profileModal.classList.remove('active');
                    SoundManager.play('click');
                });
                closeOnboarding.addEventListener('click', () => {
                    onboardingModal.classList.remove('active');
                    SoundManager.play('click');
                });
                startPlaying.addEventListener('click', () => {
                    onboardingModal.classList.remove('active');
                    SoundManager.play('click');
                });
                saveSettings.addEventListener('click', () => {
                    settings.soundOn = soundToggleSetting.checked;
                    settings.volume = parseFloat(volumeSlider.value);
                    settings.theme = themeSelect.value;
                    settings.showOnboarding = onboardingToggle.checked;
                    applySettings();
                    saveData();
                    settingsModal.classList.remove('active');
                    Toast.show('Settings saved', 'success');
                    SoundManager.play('success');
                });
                resetProgress.addEventListener('click', () => {
                    if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                        Storage.remove('scores');
                        Storage.remove('achievements');
                        scores = {};
                        achievements = {};
                        Toast.show('Progress reset', 'info');
                        SoundManager.play('success');
                    }
                });
                gameSearch.addEventListener('input', () => {
                    const searchTerm = gameSearch.value.toLowerCase();
                    const tiles = qsa('.game-tile');
                    tiles.forEach(tile => {
                        const title = tile.querySelector('.game-title').textContent.toLowerCase();
                        const description = tile.querySelector('.game-description').textContent.toLowerCase();
                        tile.style.display = title.includes(searchTerm) || description.includes(searchTerm) ? 'flex' : 'none';
                    });
                    // Also filter sidebar list
                     const listItems = qsa('.game-list-item');
                     listItems.forEach(item => {
                         const title = item.querySelector('.game-list-text').textContent.toLowerCase();
                         item.style.display = title.includes(searchTerm) ? 'flex' : 'none';
                     });
                });

                // Sidebar toggle (mobile)
                toggleSidebar.addEventListener('click', toggleSidebarVisibility);

                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && activeGame && activeGame.pause) {
                        activeGame.pause();
                    } else if (!document.hidden && activeGame && activeGame.resume) {
                         activeGame.resume();
                    }
                });

                const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                if (reducedMotion) {
                    document.documentElement.style.setProperty('--transition-fast', '0.01s');
                    document.documentElement.style.setProperty('--transition-normal', '0.01s');
                    document.documentElement.style.setProperty('--transition-slow', '0.01s');
                }

                checkOnboarding();
                selfTest();
            }

            // Self-test function
            function selfTest() {
                const tests = {
                    localStorage: () => {
                        try {
                            localStorage.setItem('test', 'test');
                            localStorage.removeItem('test');
                            return true;
                        } catch (e) {
                            return false;
                        }
                    },
                    canvas: () => {
                        return !!document.createElement('canvas').getContext;
                    },
                    webAudio: () => {
                        return !!(window.AudioContext || window.webkitAudioContext);
                    }
                };
                let allPassed = true;
                const results = [];
                for (const [name, test] of Object.entries(tests)) {
                    const passed = test();
                    allPassed = allPassed && passed;
                    results.push(`${name}: ${passed ? 'PASS' : 'FAIL'}`);
                    if (!passed) {
                        console.warn(`Self-test failed: ${name}`);
                    }
                }
                if (!allPassed) {
                    Toast.show('Some features may not work correctly in your browser', 'error', 5000);
                }
            }

            // Development check for game modules
            function devCheck() {
                console.log('Checking game modules...');
                for (const [id, module] of Object.entries(GameModules)) {
                    console.group(`Game: ${id}`);
                    const requiredMethods = ['init', 'destroy', 'pause', 'resume', 'restart'];
                    const missingMethods = [];
                    for (const method of requiredMethods) {
                        if (typeof module[method] !== 'function') {
                            missingMethods.push(method);
                        }
                    }
                    if (missingMethods.length > 0) {
                        console.warn(`Missing methods: ${missingMethods.join(', ')}`);
                    } else {
                        console.log('✓ All required methods present');
                    }
                    console.groupEnd();
                }
            }

            init();
            devCheck();
        })();
    </script>
</body>
</html>
