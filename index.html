<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaikh's Arcade</title>
    <style>
        /* ====== STYLE ====== */
        :root {
            /* Doodle-inspired color palette */
            --color-primary: #4285F4;
            --color-secondary: #34A853;
            --color-accent: #EA4335;
            --color-warning: #FBBC05;
            --color-background: #ffffff;
            --color-surface: #f8f9fa;
            --color-text: #202124;
            --color-text-secondary: #5f6368;
            --color-border: #dadce0;
            
            /* Doodle-specific colors */
            --doodle-blue: #4285F4;
            --doodle-green: #34A853;
            --doodle-red: #EA4335;
            --doodle-yellow: #FBBC05;
            --doodle-purple: #9C27B0;
            --doodle-orange: #FF9800;
            
            /* Spacing */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --spacing-xxl: 3rem;
            
            /* Border radius */
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --border-radius-lg: 16px;
            --border-radius-xl: 24px;
            --border-radius-circle: 50%;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.1);
            --shadow-md: 0 2px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 12px rgba(0,0,0,0.1);
            --shadow-focus: 0 0 0 2px var(--color-primary);
            
            /* Animation */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
            
            /* Z-index */
            --z-dropdown: 100;
            --z-sticky: 200;
            --z-modal: 300;
            --z-toast: 400;
        }

        .theme-dark {
            --color-background: #202124;
            --color-surface: #303134;
            --color-text: #e8eaed;
            --color-text-secondary: #9aa0a6;
            --color-border: #5f6368;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--color-background);
            color: var(--color-text);
            line-height: 1.5;
            overflow-x: hidden;
            transition: background-color var(--transition-normal);
        }

        button {
            background: none;
            border: none;
            cursor: pointer;
            font-family: inherit;
            color: inherit;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Doodle animations */
        @keyframes wiggle {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }

        @keyframes bob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        @keyframes scaleIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes confetti {
            0% { transform: translateY(0) rotate(0); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        @keyframes parallax {
            from { background-position: 0 0; }
            to { background-position: 100px 100px; }
        }

        .doodle-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0.05;
            background-image: 
                radial-gradient(circle at 10% 20%, var(--doodle-blue) 0%, transparent 20%),
                radial-gradient(circle at 30% 60%, var(--doodle-red) 0%, transparent 20%),
                radial-gradient(circle at 70% 40%, var(--doodle-yellow) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, var(--doodle-green) 0%, transparent 20%);
            background-size: 200px 200px;
            animation: parallax 20s infinite linear;
        }

        /* App Layout */
        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: var(--spacing-md);
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            position: relative;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--color-primary);
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--color-primary);
            color: white;
            border-radius: var(--border-radius-md);
            animation: bob 2s infinite;
        }

        .controls {
            display: flex;
            gap: var(--spacing-sm);
        }

        .icon-button {
            width: 40px;
            height: 40px;
            border-radius: var(--border-radius-circle);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }

        .icon-button:hover, .icon-button:focus {
            background-color: var(--color-primary);
            color: white;
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .icon-button:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .icon-button:active {
            transform: translateY(0);
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.4);
            transform: scale(0);
            animation: ripple 0.6s linear;
        }

        .search-container {
            margin: var(--spacing-lg) auto;
            max-width: 500px;
            width: 100%;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: var(--spacing-md) var(--spacing-xl);
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--color-border);
            background-color: var(--color-surface);
            color: var(--color-text);
            font-size: 1rem;
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-fast);
        }

        .search-input:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .search-icon {
            position: absolute;
            left: var(--spacing-md);
            top: 50%;
            transform: translateY(-50%);
            color: var(--color-text-secondary);
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
        }

        .game-tile {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-normal);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .game-tile:hover, .game-tile:focus {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
        }

        .game-tile:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .game-tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, 
                var(--doodle-blue) 0%, 
                var(--doodle-green) 25%, 
                var(--doodle-yellow) 50%, 
                var(--doodle-red) 75%, 
                var(--doodle-purple) 100%);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform var(--transition-normal);
        }

        .game-tile:hover::before {
            transform: scaleX(1);
        }

        .game-icon {
            width: 64px;
            height: 64px;
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            border-radius: var(--border-radius-md);
            background-color: var(--color-primary);
            color: white;
            transition: transform var(--transition-normal);
            position: relative;
        }

        .game-tile:hover .game-icon {
            animation: wiggle 0.6s ease;
        }

        .game-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }

        .game-description {
            font-size: 0.875rem;
            color: var(--color-text-secondary);
            transform: translateY(0);
            transition: transform var(--transition-normal);
        }

        .game-tile:hover .game-description {
            transform: translateY(-2px);
        }

        .game-preview {
            width: 100%;
            height: 60px;
            margin-top: var(--spacing-md);
            border-radius: var(--border-radius-sm);
            background-color: rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* Snake preview */
        .snake-preview {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .snake-preview-segment {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: var(--doodle-green);
            border-radius: 2px;
            transition: all 0.3s ease;
        }

        .snake-preview-food {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: var(--doodle-red);
            border-radius: 50%;
        }

        /* Tic-Tac-Toe preview */
        .tictactoe-preview {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 50px;
            height: 50px;
            background-color: var(--color-border);
        }

        .tictactoe-preview-cell {
            background-color: var(--color-surface);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
        }

        /* Memory preview */
        .memory-preview {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 2px;
            width: 60px;
            height: 40px;
        }

        .memory-preview-card {
            width: 16px;
            height: 16px;
            background-color: var(--doodle-blue);
            border-radius: var(--border-radius-sm);
            animation: blink 2s infinite;
            animation-delay: calc(var(--delay, 0) * 0.3s);
        }

        /* Reaction preview */
        .reaction-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--doodle-yellow);
            animation: scaleIn 1.5s infinite alternate;
        }

        /* Whack preview */
        .whack-preview {
            position: relative;
            width: 50px;
            height: 40px;
        }

        .whack-preview-hole {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #8B4513;
        }

        .whack-preview-mole {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #795548;
            bottom: 0;
            animation: bob 1.5s infinite;
            animation-delay: calc(var(--delay, 0) * 0.5s);
        }

        /* Dice preview */
        .dice-preview {
            width: 30px;
            height: 30px;
            border-radius: var(--border-radius-sm);
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            animation: wiggle 2s infinite;
        }

        .dice-preview-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: var(--color-text);
        }

        /* Runner preview */
        .runner-preview {
            position: relative;
            width: 60px;
            height: 30px;
            overflow: hidden;
        }

        .runner-preview-character {
            position: absolute;
            width: 8px;
            height: 12px;
            background-color: var(--doodle-blue);
            bottom: 0;
            left: 10px;
            animation: bob 0.5s infinite;
        }

        .runner-preview-obstacle {
            position: absolute;
            width: 6px;
            height: 8px;
            background-color: var(--doodle-red);
            bottom: 0;
            right: -10px;
            animation: slideIn 2s infinite linear;
        }

        @keyframes slideIn {
            from { right: -10px; }
            to { right: 60px; }
        }

        /* Game View */
        .game-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-background);
            z-index: var(--z-modal);
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform var(--transition-normal);
            overflow: hidden;
        }

        .game-view.active {
            transform: translateY(0);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            position: relative;
            z-index: 1;
        }

        .game-title-bar {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .game-content {
            flex: 1;
            padding: var(--spacing-md);
            overflow: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-modal);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normal);
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow: auto;
            transform: scale(0.9) translateY(20px);
            opacity: 0;
            transition: all var(--transition-normal);
        }

        .modal-overlay.active .modal {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        .modal-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border-radius: var(--border-radius-circle);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            transition: background-color var(--transition-fast);
        }

        .modal-close:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .modal-body {
            padding: var(--spacing-md);
        }

        .modal-footer {
            padding: var(--spacing-md);
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
        }

        /* Buttons */
        .btn {
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-md);
            font-weight: 500;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            position: relative;
            overflow: hidden;
        }

        .btn:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: #3367d6;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }

        .btn-secondary:hover {
            background-color: rgba(0, 0, 0, 0.05);
            transform: translateY(-2px);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: var(--spacing-md);
        }

        .form-label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: 500;
        }

        .form-control {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--color-border);
            background-color: var(--color-surface);
            color: var(--color-text);
            font-family: inherit;
            font-size: 1rem;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
        }

        /* Toasts */
        .toast-container {
            position: fixed;
            bottom: var(--spacing-md);
            right: var(--spacing-md);
            z-index: var(--z-toast);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .toast {
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            max-width: 300px;
            transform: translateX(100%);
            opacity: 0;
            transition: all var(--transition-normal);
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast-success {
            border-left: 4px solid var(--color-secondary);
        }

        .toast-error {
            border-left: 4px solid var(--color-accent);
        }

        .toast-info {
            border-left: 4px solid var(--color-primary);
        }

        /* Achievement badges */
        .achievement-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            border-radius: var(--border-radius-circle);
            background: linear-gradient(135deg, var(--doodle-yellow), var(--doodle-orange));
            margin-right: var(--spacing-sm);
            box-shadow: var(--shadow-md);
        }

        /* Game-specific styles */
        .snake-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
            width: 100%;
        }

        .snake-canvas {
            border: 2px solid var(--color-border);
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
            max-width: 100%;
            touch-action: none;
        }

        .game-controls {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        .snake-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: var(--spacing-xs);
            margin-top: var(--spacing-md);
        }

        .snake-control-button {
            width: 60px;
            height: 60px;
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .snake-control-button:active {
            background-color: var(--color-primary);
            color: white;
        }

        .snake-control-button.up {
            grid-column: 2;
            grid-row: 1;
        }

        .snake-control-button.down {
            grid-column: 2;
            grid-row: 3;
        }

        .snake-control-button.left {
            grid-column: 1;
            grid-row: 2;
        }

        .snake-control-button.right {
            grid-column: 3;
            grid-row: 2;
        }

        .tictactoe-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            width: 300px;
            height: 300px;
            background-color: var(--color-border);
        }

        .tictactoe-cell {
            background-color: var(--color-surface);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color var(--transition-fast);
        }

        .tictactoe-cell:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            max-width: 500px;
            margin: 0 auto;
        }

        .memory-card {
            width: 100px;
            height: 100px;
            perspective: 1000px;
            cursor: pointer;
        }

        .memory-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .memory-card.flipped .memory-card-inner {
            transform: rotateY(180deg);
        }

        .memory-card-front, .memory-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: var(--border-radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        .memory-card-front {
            background-color: var(--color-primary);
            color: white;
        }

        .memory-card-back {
            background-color: var(--color-surface);
            color: var(--color-text);
            transform: rotateY(180deg);
            box-shadow: var(--shadow-sm);
        }

        .reaction-tester {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
        }

        .reaction-box {
            width: 300px;
            height: 300px;
            border-radius: var(--border-radius-lg);
            background-color: var(--color-accent);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color var(--transition-fast);
        }

        .reaction-box.waiting {
            background-color: var(--color-warning);
        }

        .reaction-box.ready {
            background-color: var(--color-secondary);
        }

        .reaction-history {
            display: flex;
            gap: var(--spacing-xs);
            height: 40px;
            align-items: flex-end;
        }

        .reaction-bar {
            width: 8px;
            background-color: var(--color-primary);
            border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0;
        }

        .whack-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 16px;
            max-width: 400px;
            margin: 0 auto;
        }

        .whack-hole {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #8B4513;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .whack-mole {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: #795548;
            bottom: -70px;
            left: 5px;
            transition: bottom 0.2s ease;
        }

        .whack-mole.up {
            bottom: 5px;
        }

        .dice-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
        }

        .dice-container {
            display: flex;
            gap: var(--spacing-md);
        }

        .dice {
            width: 60px;
            height: 60px;
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .runner-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
        }

        .runner-canvas {
            border: 2px solid var(--color-border);
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
            max-width: 100%;
            touch-action: none;
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .doodle-bg {
                animation: none;
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .games-grid {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
            
            .tictactoe-board {
                width: 250px;
                height: 250px;
            }
            
            .memory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .memory-card {
                width: 80px;
                height: 80px;
            }
        }

        @media (max-width: 480px) {
            .app-header {
                flex-direction: column;
                gap: var(--spacing-md);
            }
            
            .games-grid {
                grid-template-columns: 1fr;
            }
            
            .tictactoe-board {
                width: 200px;
                height: 200px;
            }
            
            .memory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .memory-card {
                width: 70px;
                height: 70px;
            }
            
            .reaction-box {
                width: 200px;
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- ====== TEMPLATE ====== -->
    <div class="doodle-bg"></div>
    <div class="app">
        <header class="app-header">
            <div class="logo">
                <div class="logo-icon" id="logoIcon">🎮</div>
                <h1>Shaikh's Arcade</h1>
            </div>
            <div class="controls">
                <button class="icon-button" id="soundToggle" aria-label="Toggle sound">
                    <span class="sound-icon">🔊</span>
                </button>
                <button class="icon-button" id="themeToggle" aria-label="Toggle theme">
                    <span class="theme-icon">🌙</span>
                </button>
                <button class="icon-button" id="settingsButton" aria-label="Open settings">
                    <span class="settings-icon">⚙️</span>
                </button>
                <button class="icon-button" id="profileButton" aria-label="Open profile">
                    <span class="profile-icon">👤</span>
                </button>
            </div>
        </header>

        <div class="search-container">
            <div class="search-icon">🔍</div>
            <input type="text" class="search-input" id="gameSearch" placeholder="Search games..." aria-label="Search games">
        </div>

        <div class="games-grid" id="gamesGrid">
            <!-- Game tiles will be populated by JavaScript -->
        </div>

        <div class="game-view" id="gameView">
            <div class="game-header">
                <div class="game-title-bar">
                    <button class="btn btn-secondary" id="backButton">
                        ← Back
                    </button>
                    <h2 class="game-title" id="currentGameTitle">Game Title</h2>
                </div>
                <div class="game-controls">
                    <button class="icon-button" id="gameInfo" aria-label="Game information">
                        ℹ️
                    </button>
                    <button class="icon-button" id="gameRestart" aria-label="Restart game">
                        🔄
                    </button>
                    <button class="icon-button" id="gamePause" aria-label="Pause game">
                        ⏸️
                    </button>
                </div>
            </div>
            <div class="game-content" id="gameContent">
                <!-- Game content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Settings</h3>
                <button class="modal-close" id="closeSettings">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="soundToggleSetting">Sound</label>
                    <div class="form-control">
                        <label>
                            <input type="checkbox" id="soundToggleSetting">
                            Enable sound
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label" for="volumeSlider">Volume</label>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.1" class="form-control">
                </div>
                <div class="form-group">
                    <label class="form-label" for="themeSelect">Theme</label>
                    <select id="themeSelect" class="form-control">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="auto">Auto (system)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="onboardingToggle">Show onboarding</label>
                    <div class="form-control">
                        <label>
                            <input type="checkbox" id="onboardingToggle">
                            Show onboarding on startup
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="resetProgress">
                    Reset Progress
                </button>
                <button class="btn btn-primary" id="saveSettings">
                    Save
                </button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="profileModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Your Profile</h3>
                <button class="modal-close" id="closeProfile">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <h4>Achievements</h4>
                    <div id="achievementsList">
                        <!-- Achievements will be populated by JavaScript -->
                    </div>
                </div>
                <div class="form-group">
                    <h4>High Scores</h4>
                    <div id="highScoresList">
                        <!-- High scores will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="onboardingModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Welcome to Shaikh's Arcade!</h3>
                <button class="modal-close" id="closeOnboarding">✕</button>
            </div>
            <div class="modal-body">
                <p>🎮 Play a collection of fun mini-games</p>
                <p>🏆 Earn achievements and track high scores</p>
                <p>⚙️ Customize your experience in settings</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="startPlaying">
                    Start Playing
                </button>
            </div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer">
        <!-- Toasts will be added here by JavaScript -->
    </div>

    <script>
        /* ====== SCRIPTS ====== */
        (function() {
            'use strict';
            
            // Utility functions
            const qs = (selector, root = document) => root.querySelector(selector);
            const qsa = (selector, root = document) => Array.from(root.querySelectorAll(selector));
            const create = (tag, props = {}, children = []) => {
                const el = document.createElement(tag);
                Object.keys(props).forEach(key => {
                    el[key] = props[key];
                });
                children.forEach(child => {
                    if (typeof child === 'string') {
                        el.appendChild(document.createTextNode(child));
                    } else {
                        el.appendChild(child);
                    }
                });
                return el;
            };
            
            // Doodle icon generator
            const DoodleIcon = (type, size = 24) => {
                const icons = {
                    snake: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M6 12C6 8.69 8.69 6 12 6C15.31 6 18 8.69 18 12C18 15.31 15.31 18 12 18C8.69 18 6 15.31 6 12Z" fill="#34A853"/>
                        <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM12 20C7.59 20 4 16.41 4 12C4 7.59 7.59 4 12 4C16.41 4 20 7.59 20 12C20 16.41 16.41 20 12 20Z" fill="#34A853"/>
                        <circle cx="9" cy="12" r="1" fill="white"/>
                        <circle cx="15" cy="12" r="1" fill="white"/>
                    </svg>`,
                    tictactoe: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3" y="3" width="18" height="18" rx="2" stroke="#4285F4" stroke-width="2"/>
                        <line x1="9" y1="3" x2="9" y2="21" stroke="#4285F4" stroke-width="2"/>
                        <line x1="15" y1="3" x2="15" y2="21" stroke="#4285F4" stroke-width="2"/>
                        <line x1="3" y1="9" x2="21" y2="9" stroke="#4285F4" stroke-width="2"/>
                        <line x1="3" y1="15" x2="21" y2="15" stroke="#4285F4" stroke-width="2"/>
                    </svg>`,
                    memory: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="2" y="2" width="20" height="20" rx="3" fill="#EA4335"/>
                        <circle cx="8" cy="8" r="2" fill="white"/>
                        <circle cx="16" cy="8" r="2" fill="white"/>
                        <circle cx="8" cy="16" r="2" fill="white"/>
                        <circle cx="16" cy="16" r="2" fill="white"/>
                    </svg>`,
                    reaction: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="10" fill="#FBBC05"/>
                        <circle cx="8" cy="9" r="1" fill="white"/>
                        <circle cx="16" cy="9" r="1" fill="white"/>
                        <path d="M8 15C8 15 10 17 12 17C14 17 16 15 16 15" stroke="white" stroke-width="2"/>
                    </svg>`,
                    whack: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L2 22H22L12 2Z" fill="#9C27B0"/>
                        <circle cx="12" cy="10" r="4" fill="white"/>
                        <circle cx="12" cy="10" r="2" fill="#9C27B0"/>
                    </svg>`,
                    dice: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3" y="3" width="18" height="18" rx="3" fill="#FF9800"/>
                        <circle cx="7" cy="7" r="1" fill="white"/>
                        <circle cx="17" cy="7" r="1" fill="white"/>
                        <circle cx="12" cy="12" r="1" fill="white"/>
                        <circle cx="7" cy="17" r="1" fill="white"/>
                        <circle cx="17" cy="17" r="1" fill="white"/>
                    </svg>`,
                    runner: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="10" fill="#4285F4"/>
                        <circle cx="12" cy="9" r="2" fill="white"/>
                        <path d="M12 11L12 17" stroke="white" stroke-width="2"/>
                        <path d="M9 14L15 14" stroke="white" stroke-width="2"/>
                    </svg>`,
                    trophy: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 15C15.7275 15 18.75 11.9775 18.75 8.25V3.75H5.25V8.25C5.25 11.9775 8.2725 15 12 15Z" fill="#FBBC05" stroke="#FBBC05" stroke-width="2"/>
                        <path d="M15.75 15V18.75H8.25V15" stroke="#FBBC05" stroke-width="2"/>
                        <path d="M12 18.75V22.5" stroke="#FBBC05" stroke-width="2"/>
                        <path d="M8.25 21H15.75" stroke="#FBBC05" stroke-width="2"/>
                    </svg>`,
                    spark: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M7 2L5 8L2 9C2 9 4.5 10.5 5 12C5.5 13.5 3 16 3 16L7 14.5L10 17L9 13.5L12 12L9 11L10 7L7 2Z" fill="#FF9800"/>
                        <path d="M16 3L14 9L11 10C11 10 13.5 11.5 14 13C14.5 14.5 12 17 12 17L16 15.5L19 18L18 14.5L21 13L18 12L19 8L16 3Z" fill="#EA4335"/>
                    </svg>`
                };
                
                const svgContainer = create('div', {
                    innerHTML: icons[type] || icons.spark
                });
                
                return svgContainer.firstChild;
            };
            
            // App state
            let activeGame = null;
            let gamesRegistry = {};
            let settings = {
                soundOn: true,
                volume: 0.5,
                theme: 'light',
                showOnboarding: true
            };
            let scores = {};
            let achievements = {};
            
            // DOM elements
            const gamesGrid = qs('#gamesGrid');
            const gameView = qs('#gameView');
            const gameContent = qs('#gameContent');
            const currentGameTitle = qs('#currentGameTitle');
            const gameSearch = qs('#gameSearch');
            const backButton = qs('#backButton');
            const soundToggle = qs('#soundToggle');
            const themeToggle = qs('#themeToggle');
            const settingsButton = qs('#settingsButton');
            const profileButton = qs('#profileButton');
            const gamePause = qs('#gamePause');
            const gameRestart = qs('#gameRestart');
            const gameInfo = qs('#gameInfo');
            const logoIcon = qs('#logoIcon');
            
            // Modals
            const settingsModal = qs('#settingsModal');
            const profileModal = qs('#profileModal');
            const onboardingModal = qs('#onboardingModal');
            const closeSettings = qs('#closeSettings');
            const closeProfile = qs('#closeProfile');
            const closeOnboarding = qs('#closeOnboarding');
            const soundToggleSetting = qs('#soundToggleSetting');
            const volumeSlider = qs('#volumeSlider');
            const themeSelect = qs('#themeSelect');
            const onboardingToggle = qs('#onboardingToggle');
            const resetProgress = qs('#resetProgress');
            const saveSettings = qs('#saveSettings');
            const startPlaying = qs('#startPlaying');
            
            // Sound Manager
            const SoundManager = {
                audioContext: null,
                enabled: true,
                volume: 0.5,
                
                init() {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        this.enabled = true;
                    } catch (e) {
                        console.warn('Web Audio API is not supported in this browser');
                        this.enabled = false;
                    }
                },
                
                play(kind) {
                    if (!this.enabled || !this.audioContext || !settings.soundOn) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    let frequency = 440;
                    let duration = 0.1;
                    
                    switch (kind) {
                        case 'click':
                            frequency = 523.25;
                            break;
                        case 'success':
                            frequency = 783.99;
                            break;
                        case 'error':
                            frequency = 349.23;
                            break;
                        case 'eat':
                            frequency = 659.25;
                            duration = 0.05;
                            break;
                        case 'hit':
                            frequency = 392;
                            duration = 0.08;
                            break;
                    }
                    
                    gainNode.gain.value = this.volume;
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    oscillator.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    oscillator.stop(this.audioContext.currentTime + duration);
                },
                
                setVolume(volume) {
                    this.volume = volume;
                },
                
                toggle() {
                    this.enabled = !this.enabled;
                    return this.enabled;
                }
            };
            
            // Toast system
            const Toast = {
                container: qs('#toastContainer'),
                
                show(message, type = 'info', duration = 3000) {
                    const toast = create('div', {
                        className: `toast toast-${type}`,
                        innerHTML: `<span>${message}</span>`
                    });
                    
                    this.container.appendChild(toast);
                    
                    // Trigger reflow
                    toast.offsetHeight;
                    
                    toast.classList.add('show');
                    
                    setTimeout(() => {
                        toast.classList.remove('show');
                        setTimeout(() => {
                            if (toast.parentNode) {
                                toast.parentNode.removeChild(toast);
                            }
                        }, 300);
                    }, duration);
                }
            };
            
            // Confetti effect
            const Confetti = {
                create(x, y, color) {
                    const confetti = create('div', {
                        className: 'confetti',
                        style: `
                            position: fixed;
                            top: ${y}px;
                            left: ${x}px;
                            width: 8px;
                            height: 8px;
                            background-color: ${color};
                            border-radius: 1px;
                            z-index: ${var(--z-toast)};
                            pointer-events: none;
                        `
                    });
                    
                    document.body.appendChild(confetti);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const velocity = 2 + Math.random() * 2;
                    const spin = Math.random() * 10 - 5;
                    
                    let posX = x;
                    let posY = y;
                    let rotation = 0;
                    
                    const animate = () => {
                        posX += Math.cos(angle) * velocity;
                        posY += Math.sin(angle) * velocity + 0.1; // gravity
                        rotation += spin;
                        
                        confetti.style.left = `${posX}px`;
                        confetti.style.top = `${posY}px`;
                        confetti.style.transform = `rotate(${rotation}deg)`;
                        
                        if (posY < window.innerHeight) {
                            requestAnimationFrame(animate);
                        } else {
                            confetti.parentNode.removeChild(confetti);
                        }
                    };
                    
                    animate();
                },
                
                burst(x, y, count = 20) {
                    const colors = [
                        '#4285F4', '#34A853', '#EA4335', '#FBBC05', '#9C27B0', '#FF9800'
                    ];
                    
                    for (let i = 0; i < count; i++) {
                        setTimeout(() => {
                            this.create(x, y, colors[Math.floor(Math.random() * colors.length)]);
                        }, i * 30);
                    }
                }
            };
            
            // Ripple effect
            const addRippleEffect = (element) => {
                element.addEventListener('click', function(e) {
                    const rect = this.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const ripple = create('span', {
                        className: 'ripple',
                        style: `top: ${y}px; left: ${x}px;`
                    });
                    
                    this.appendChild(ripple);
                    
                    setTimeout(() => {
                        ripple.remove();
                    }, 600);
                });
            };
            
            // LocalStorage management
            const Storage = {
                get(key) {
                    try {
                        const item = localStorage.getItem(`shaikhArcade.${key}`);
                        return item ? JSON.parse(item) : null;
                    } catch (e) {
                        console.error('Error reading from localStorage', e);
                        return null;
                    }
                },
                
                set(key, value) {
                    try {
                        localStorage.setItem(`shaikhArcade.${key}`, JSON.stringify(value));
                    } catch (e) {
                        console.error('Error writing to localStorage', e);
                    }
                },
                
                remove(key) {
                    try {
                        localStorage.removeItem(`shaikhArcade.${key}`);
                    } catch (e) {
                        console.error('Error removing from localStorage', e);
                    }
                }
            };
            
            // Load saved data
            function loadData() {
                const savedSettings = Storage.get('settings');
                if (savedSettings) {
                    settings = { ...settings, ...savedSettings };
                }
                
                const savedScores = Storage.get('scores');
                if (savedScores) {
                    scores = savedScores;
                }
                
                const savedAchievements = Storage.get('achievements');
                if (savedAchievements) {
                    achievements = savedAchievements;
                }
            }
            
            // Save data
            function saveData() {
                Storage.set('settings', settings);
                Storage.set('scores', scores);
                Storage.set('achievements', achievements);
            }
            
            // Apply settings to UI
            function applySettings() {
                // Apply theme
                if (settings.theme === 'dark' || (settings.theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    document.body.classList.add('theme-dark');
                    themeToggle.querySelector('.theme-icon').textContent = '☀️';
                } else {
                    document.body.classList.remove('theme-dark');
                    themeToggle.querySelector('.theme-icon').textContent = '🌙';
                }
                
                // Apply sound settings
                soundToggle.querySelector('.sound-icon').textContent = settings.soundOn ? '🔊' : '🔇';
                SoundManager.setVolume(settings.volume);
                
                // Update settings modal
                soundToggleSetting.checked = settings.soundOn;
                volumeSlider.value = settings.volume;
                themeSelect.value = settings.theme;
                onboardingToggle.checked = settings.showOnboarding;
            }
            
            // Show onboarding if needed
            function checkOnboarding() {
                if (settings.showOnboarding) {
                    onboardingModal.classList.add('active');
                }
            }
            
            // Check and unlock achievements
            function checkAchievement(achievementId, condition, payload = null) {
                if (condition && !achievements[achievementId]) {
                    achievements[achievementId] = {
                        unlocked: true,
                        timestamp: Date.now(),
                        payload: payload
                    };
                    Storage.set('achievements', achievements);
                    
                    let message = '';
                    switch (achievementId) {
                        case 'first_win':
                            message = 'Achievement Unlocked: First Win!';
                            break;
                        case 'snake_master':
                            message = 'Achievement Unlocked: Snake Master!';
                            break;
                        case 'tic_master':
                            message = 'Achievement Unlocked: Tic-Tac-Toe Master!';
                            break;
                        case 'memory_champ':
                            message = 'Achievement Unlocked: Memory Champion!';
                            break;
                        case 'speed_demon':
                            message = 'Achievement Unlocked: Speed Demon!';
                            break;
                        case 'whack_streak':
                            message = 'Achievement Unlocked: Whack-a-Doodle Streak!';
                            break;
                        case 'lucky_roller':
                            message = 'Achievement Unlocked: Lucky Roller!';
                            break;
                        case 'runner_pro':
                            message = 'Achievement Unlocked: Runner Pro!';
                            break;
                    }
                    
                    if (message) {
                        Toast.show(message, 'success');
                        
                        // Show confetti for major achievements
                        if (['snake_master', 'tic_master', 'memory_champ'].includes(achievementId)) {
                            Confetti.burst(window.innerWidth / 2, window.innerHeight / 2);
                        }
                    }
                }
            }
            
            // Game modules
            const GameModules = {
                // Smooth Snake game
                snake: {
                    id: 'snake',
                    title: 'Smooth Snake',
                    description: 'Guide the snake to eat food and grow longer',
                    icon: DoodleIcon('snake', 32),
                    
                    init(container) {
                        const canvas = create('canvas', {
                            className: 'snake-canvas',
                            width: 400,
                            height: 400,
                            role: 'application',
                            'aria-label': 'Snake game canvas'
                        });
                        
                        const ctx = canvas.getContext('2d');
                        const gameState = {
                            snake: [{x: 10, y: 10}],
                            food: {x: 5, y: 5},
                            direction: 'right',
                            nextDirection: 'right',
                            score: 0,
                            highScore: scores.snake?.highScore || 0,
                            gameOver: false,
                            paused: false,
                            gridSize: 20,
                            speed: 150,
                            lastUpdate: 0,
                            interpolation: 0,
                            touchStart: null
                        };
                        
                        const scoreAnnouncer = create('div', {
                            className: 'sr-only',
                            'aria-live': 'polite'
                        });
                        
                        const controlsContainer = create('div', {
                            className: 'snake-controls'
                        });
                        
                        const upButton = create('button', {
                            className: 'snake-control-button up',
                            innerHTML: '↑',
                            onclick: () => { if (gameState.direction !== 'down') gameState.nextDirection = 'up'; }
                        });
                        
                        const downButton = create('button', {
                            className: 'snake-control-button down',
                            innerHTML: '↓',
                            onclick: () => { if (gameState.direction !== 'up') gameState.nextDirection = 'down'; }
                        });
                        
                        const leftButton = create('button', {
                            className: 'snake-control-button left',
                            innerHTML: '←',
                            onclick: () => { if (gameState.direction !== 'right') gameState.nextDirection = 'left'; }
                        });
                        
                        const rightButton = create('button', {
                            className: 'snake-control-button right',
                            innerHTML: '→',
                            onclick: () => { if (gameState.direction !== 'left') gameState.nextDirection = 'right'; }
                        });
                        
                        controlsContainer.appendChild(upButton);
                        controlsContainer.appendChild(downButton);
                        controlsContainer.appendChild(leftButton);
                        controlsContainer.appendChild(rightButton);
                        
                        container.appendChild(canvas);
                        container.appendChild(scoreAnnouncer);
                        container.appendChild(controlsContainer);
                        
                        // Game logic
                        function update(currentTime) {
                            if (gameState.paused || gameState.gameOver) return;
                            
                            if (!gameState.lastUpdate) gameState.lastUpdate = currentTime;
                            const deltaTime = currentTime - gameState.lastUpdate;
                            
                            gameState.interpolation = Math.min(1, deltaTime / gameState.speed);
                            
                            if (deltaTime > gameState.speed) {
                                gameState.lastUpdate = currentTime;
                                gameState.interpolation = 0;
                                
                                // Update direction
                                gameState.direction = gameState.nextDirection;
                                
                                // Move snake
                                const head = {...gameState.snake[0]};
                                
                                switch (gameState.direction) {
                                    case 'up': head.y--; break;
                                    case 'down': head.y++; break;
                                    case 'left': head.x--; break;
                                    case 'right': head.x++; break;
                                }
                                
                                // Check wall collision
                                if (head.x < 0 || head.x >= canvas.width / gameState.gridSize ||
                                    head.y < 0 || head.y >= canvas.height / gameState.gridSize) {
                                    gameState.gameOver = true;
                                    SoundManager.play('error');
                                    checkAchievement('snake_master', gameState.score >= 500, { score: gameState.score });
                                    updateScores('snake', gameState.score);
                                    return;
                                }
                                
                                // Check self collision
                                for (let i = 0; i < gameState.snake.length; i++) {
                                    if (gameState.snake[i].x === head.x && gameState.snake[i].y === head.y) {
                                        gameState.gameOver = true;
                                        SoundManager.play('error');
                                        checkAchievement('snake_master', gameState.score >= 500, { score: gameState.score });
                                        updateScores('snake', gameState.score);
                                        return;
                                    }
                                }
                                
                                // Add new head
                                gameState.snake.unshift(head);
                                
                                // Check food collision
                                if (head.x === gameState.food.x && head.y === gameState.food.y) {
                                    gameState.score += 10;
                                    SoundManager.play('eat');
                                    scoreAnnouncer.textContent = `Score: ${gameState.score}`;
                                    
                                    // Add particle effect every 5 foods
                                    if (gameState.score % 50 === 0) {
                                        const headPos = {
                                            x: gameState.snake[0].x * gameState.gridSize + gameState.gridSize / 2,
                                            y: gameState.snake[0].y * gameState.gridSize + gameState.gridSize / 2
                                        };
                                        Confetti.burst(headPos.x, headPos.y, 10);
                                    }
                                    
                                    placeFood();
                                    
                                    // Increase speed every 5 foods
                                    if (gameState.score % 50 === 0 && gameState.speed > 50) {
                                        gameState.speed -= 10;
                                    }
                                } else {
                                    // Remove tail if no food eaten
                                    gameState.snake.pop();
                                }
                            }
                            
                            requestAnimationFrame(update);
                        }
                        
                        function placeFood() {
                            let newFood;
                            let overlapping;
                            
                            do {
                                newFood = {
                                    x: Math.floor(Math.random() * (canvas.width / gameState.gridSize)),
                                    y: Math.floor(Math.random() * (canvas.height / gameState.gridSize))
                                };
                                
                                overlapping = false;
                                for (const segment of gameState.snake) {
                                    if (segment.x === newFood.x && segment.y === newFood.y) {
                                        overlapping = true;
                                        break;
                                    }
                                }
                            } while (overlapping);
                            
                            gameState.food = newFood;
                        }
                        
                        function draw() {
                            // Clear canvas
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-background');
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Draw food
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-accent');
                            ctx.fillRect(
                                gameState.food.x * gameState.gridSize,
                                gameState.food.y * gameState.gridSize,
                                gameState.gridSize,
                                gameState.gridSize
                            );
                            
                            // Draw snake with interpolation for smooth movement
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-secondary');
                            
                            for (let i = 0; i < gameState.snake.length; i++) {
                                const segment = gameState.snake[i];
                                let x = segment.x * gameState.gridSize;
                                let y = segment.y * gameState.gridSize;
                                
                                // Interpolate head position
                                if (i === 0 && gameState.interpolation > 0) {
                                    const nextX = segment.x;
                                    const nextY = segment.y;
                                    
                                    switch (gameState.direction) {
                                        case 'left': x = (nextX + gameState.interpolation) * gameState.gridSize; break;
                                        case 'right': x = (nextX - gameState.interpolation) * gameState.gridSize; break;
                                        case 'up': y = (nextY + gameState.interpolation) * gameState.gridSize; break;
                                        case 'down': y = (nextY - gameState.interpolation) * gameState.gridSize; break;
                                    }
                                }
                                
                                ctx.fillRect(x, y, gameState.gridSize, gameState.gridSize);
                            }
                            
                            // Draw score
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-text');
                            ctx.font = '16px sans-serif';
                            ctx.fillText(`Score: ${gameState.score}`, 10, 20);
                            ctx.fillText(`High Score: ${gameState.highScore}`, 10, 40);
                            
                            if (gameState.gameOver) {
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                ctx.fillStyle = 'white';
                                ctx.font = '24px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 20);
                                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 20);
                                ctx.textAlign = 'left';
                            } else if (gameState.paused) {
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                ctx.fillStyle = 'white';
                                ctx.font = '24px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
                                ctx.textAlign = 'left';
                            }
                        }
                        
                        function gameLoop() {
                            draw();
                            requestAnimationFrame(gameLoop);
                        }
                        
                        // Input handling
                        function handleKeyDown(e) {
                            switch (e.key) {
                                case 'ArrowUp':
                                case 'w':
                                case 'W':
                                    if (gameState.direction !== 'down') gameState.nextDirection = 'up';
                                    break;
                                case 'ArrowDown':
                                case 's':
                                case 'S':
                                    if (gameState.direction !== 'up') gameState.nextDirection = 'down';
                                    break;
                                case 'ArrowLeft':
                                case 'a':
                                case 'A':
                                    if (gameState.direction !== 'right') gameState.nextDirection = 'left';
                                    break;
                                case 'ArrowRight':
                                case 'd':
                                case 'D':
                                    if (gameState.direction !== 'left') gameState.nextDirection = 'right';
                                    break;
                                case ' ':
                                    gameState.paused = !gameState.paused;
                                    break;
                            }
                        }
                        
                        // Touch handling
                        function handleTouchStart(e) {
                            gameState.touchStart = {
                                x: e.touches[0].clientX,
                                y: e.touches[0].clientY
                            };
                        }
                        
                        function handleTouchEnd(e) {
                            if (!gameState.touchStart) return;
                            
                            const touchEnd = {
                                x: e.changedTouches[0].clientX,
                                y: e.changedTouches[0].clientY
                            };
                            
                            const dx = touchEnd.x - gameState.touchStart.x;
                            const dy = touchEnd.y - gameState.touchStart.y;
                            const minSwipeDistance = 30;
                            
                            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > minSwipeDistance) {
                                // Horizontal swipe
                                if (dx > 0 && gameState.direction !== 'left') {
                                    gameState.nextDirection = 'right';
                                } else if (dx < 0 && gameState.direction !== 'right') {
                                    gameState.nextDirection = 'left';
                                }
                            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > minSwipeDistance) {
                                // Vertical swipe
                                if (dy > 0 && gameState.direction !== 'up') {
                                    gameState.nextDirection = 'down';
                                } else if (dy < 0 && gameState.direction !== 'down') {
                                    gameState.nextDirection = 'up';
                                }
                            }
                            
                            gameState.touchStart = null;
                        }
                        
                        // Initialize game
                        placeFood();
                        requestAnimationFrame(update);
                        requestAnimationFrame(gameLoop);
                        document.addEventListener('keydown', handleKeyDown);
                        canvas.addEventListener('touchstart', handleTouchStart);
                        canvas.addEventListener('touchend', handleTouchEnd);
                        
                        // Return game API
                        return {
                            destroy() {
                                document.removeEventListener('keydown', handleKeyDown);
                                canvas.removeEventListener('touchstart', handleTouchStart);
                                canvas.removeEventListener('touchend', handleTouchEnd);
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                gameState.paused = true;
                            },
                            
                            resume() {
                                gameState.paused = false;
                                gameState.lastUpdate = 0;
                            },
                            
                            restart() {
                                gameState.snake = [{x: 10, y: 10}];
                                gameState.direction = 'right';
                                gameState.nextDirection = 'right';
                                gameState.score = 0;
                                gameState.gameOver = false;
                                gameState.paused = false;
                                gameState.speed = 150;
                                gameState.lastUpdate = 0;
                                gameState.interpolation = 0;
                                placeFood();
                                scoreAnnouncer.textContent = 'Game restarted';
                            }
                        };
                    }
                },
                
                // Tic-Tac-Toe game
                tictactoe: {
                    id: 'tictactoe',
                    title: 'Tic-Tac-Toe',
                    description: 'Classic X and O game with AI opponents',
                    icon: DoodleIcon('tictactoe', 32),
                    
                    init(container) {
                        const gameState = {
                            board: Array(9).fill(''),
                            currentPlayer: 'X',
                            gameOver: false,
                            mode: 'pvp', // pvp, easy, medium, hard
                            scores: { X: 0, O: 0, draws: 0 },
                            focusIndex: 0
                        };
                        
                        const boardElement = create('div', { 
                            className: 'tictactoe-board',
                            tabIndex: 0,
                            role: 'application',
                            'aria-label': 'Tic-Tac-Toe board'
                        });
                        
                        // Create cells
                        for (let i = 0; i < 9; i++) {
                            const cell = create('button', {
                                className: 'tictactoe-cell',
                                'data-index': i,
                                'aria-label': `Cell ${i+1}, empty`,
                                onclick: () => makeMove(i)
                            });
                            boardElement.appendChild(cell);
                        }
                        
                        const scoreDisplay = create('div', {
                            className: 'score-display',
                            innerHTML: `
                                <p>X: ${gameState.scores.X} | O: ${gameState.scores.O} | Draws: ${gameState.scores.draws}</p>
                            `
                        });
                        
                        container.appendChild(boardElement);
                        container.appendChild(scoreDisplay);
                        
                        // Mode selection
                        const modeSelect = create('div', {
                            className: 'game-controls',
                            innerHTML: `
                                <button class="btn btn-primary" data-mode="pvp">PvP</button>
                                <button class="btn btn-secondary" data-mode="easy">Easy AI</button>
                                <button class="btn btn-secondary" data-mode="medium">Medium AI</button>
                                <button class="btn btn-secondary" data-mode="hard">Hard AI</button>
                            `
                        });
                        
                        modeSelect.addEventListener('click', (e) => {
                            if (e.target.tagName === 'BUTTON') {
                                const mode = e.target.dataset.mode;
                                gameState.mode = mode;
                                
                                // Update button styles
                                qsa('button', modeSelect).forEach(btn => {
                                    btn.className = btn.dataset.mode === mode ? 'btn btn-primary' : 'btn btn-secondary';
                                });
                                
                                restartGame();
                            }
                        });
                        
                        container.appendChild(modeSelect);
                        
                        // Keyboard navigation
                        boardElement.addEventListener('keydown', (e) => {
                            const cells = qsa('.tictactoe-cell', boardElement);
                            
                            switch (e.key) {
                                case 'ArrowUp':
                                    e.preventDefault();
                                    gameState.focusIndex = (gameState.focusIndex - 3 + 9) % 9;
                                    cells[gameState.focusIndex].focus();
                                    break;
                                case 'ArrowDown':
                                    e.preventDefault();
                                    gameState.focusIndex = (gameState.focusIndex + 3) % 9;
                                    cells[gameState.focusIndex].focus();
                                    break;
                                case 'ArrowLeft':
                                    e.preventDefault();
                                    gameState.focusIndex = (gameState.focusIndex - 1 + 9) % 9;
                                    cells[gameState.focusIndex].focus();
                                    break;
                                case 'ArrowRight':
                                    e.preventDefault();
                                    gameState.focusIndex = (gameState.focusIndex + 1) % 9;
                                    cells[gameState.focusIndex].focus();
                                    break;
                                case 'Enter':
                                case ' ':
                                    e.preventDefault();
                                    makeMove(gameState.focusIndex);
                                    break;
                            }
                        });
                        
                        // Game functions
                        function makeMove(index) {
                            if (gameState.board[index] !== '' || gameState.gameOver) return;
                            
                            gameState.board[index] = gameState.currentPlayer;
                            updateBoard();
                            
                            if (checkWinner()) {
                                gameState.gameOver = true;
                                gameState.scores[gameState.currentPlayer]++;
                                updateScores('tictactoe', gameState.scores);
                                Toast.show(`Player ${gameState.currentPlayer} wins!`, 'success');
                                checkAchievement('first_win', true);
                                if (gameState.mode === 'hard' && gameState.currentPlayer === 'X') {
                                    checkAchievement('tic_master', true);
                                }
                                return;
                            }
                            
                            if (checkDraw()) {
                                gameState.gameOver = true;
                                gameState.scores.draws++;
                                updateScores('tictactoe', gameState.scores);
                                Toast.show('It\'s a draw!', 'info');
                                return;
                            }
                            
                            // Switch player
                            gameState.currentPlayer = gameState.currentPlayer === 'X' ? 'O' : 'X';
                            
                            // AI move if needed
                            if (!gameState.gameOver && gameState.mode !== 'pvp' && gameState.currentPlayer === 'O') {
                                setTimeout(makeAIMove, 500);
                            }
                        }
                        
                        function makeAIMove() {
                            let move;
                            
                            switch (gameState.mode) {
                                case 'easy':
                                    move = makeEasyAIMove();
                                    break;
                                case 'medium':
                                    move = makeMediumAIMove();
                                    break;
                                case 'hard':
                                    move = makeHardAIMove();
                                    break;
                            }
                            
                            if (move !== undefined) {
                                makeMove(move);
                            }
                        }
                        
                        function makeEasyAIMove() {
                            // Just pick a random available move
                            const availableMoves = [];
                            for (let i = 0; i < 9; i++) {
                                if (gameState.board[i] === '') {
                                    availableMoves.push(i);
                                }
                            }
                            
                            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
                        }
                        
                        function makeMediumAIMove() {
                            // Try to win if possible, block if necessary, otherwise use heuristic
                            const availableMoves = [];
                            for (let i = 0; i < 9; i++) {
                                if (gameState.board[i] === '') {
                                    availableMoves.push(i);
                                }
                            }
                            
                            // Check for winning move
                            for (const move of availableMoves) {
                                const testBoard = [...gameState.board];
                                testBoard[move] = 'O';
                                if (checkWinForPlayer(testBoard, 'O')) {
                                    return move;
                                }
                            }
                            
                            // Check for blocking move
                            for (const move of availableMoves) {
                                const testBoard = [...gameState.board];
                                testBoard[move] = 'X';
                                if (checkWinForPlayer(testBoard, 'X')) {
                                    return move;
                                }
                            }
                            
                            // Heuristic: prefer center, then corners, then sides
                            if (gameState.board[4] === '') return 4; // Center
                            
                            const corners = [0, 2, 6, 8];
                            for (const corner of corners) {
                                if (gameState.board[corner] === '') return corner;
                            }
                            
                            const sides = [1, 3, 5, 7];
                            for (const side of sides) {
                                if (gameState.board[side] === '') return side;
                            }
                            
                            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
                        }
                        
                        function makeHardAIMove() {
                            // Minimax algorithm with alpha-beta pruning for optimal play
                            let bestScore = -Infinity;
                            let bestMove;
                            let alpha = -Infinity;
                            let beta = Infinity;
                            
                            for (let i = 0; i < 9; i++) {
                                if (gameState.board[i] === '') {
                                    gameState.board[i] = 'O';
                                    const score = minimax(gameState.board, 0, false, alpha, beta);
                                    gameState.board[i] = '';
                                    
                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestMove = i;
                                    }
                                    
                                    alpha = Math.max(alpha, bestScore);
                                    if (beta <= alpha) break; // Alpha-beta pruning
                                }
                            }
                            
                            return bestMove;
                        }
                        
                        function minimax(board, depth, isMaximizing, alpha, beta) {
                            // Base cases
                            if (checkWinForPlayer(board, 'O')) return 10 - depth;
                            if (checkWinForPlayer(board, 'X')) return depth - 10;
                            if (checkDrawForBoard(board)) return 0;
                            
                            // Recursive case
                            if (isMaximizing) {
                                let bestScore = -Infinity;
                                
                                for (let i = 0; i < 9; i++) {
                                    if (board[i] === '') {
                                        board[i] = 'O';
                                        const score = minimax(board, depth + 1, false, alpha, beta);
                                        board[i] = '';
                                        bestScore = Math.max(score, bestScore);
                                        
                                        alpha = Math.max(alpha, bestScore);
                                        if (beta <= alpha) break; // Alpha-beta pruning
                                    }
                                }
                                
                                return bestScore;
                            } else {
                                let bestScore = Infinity;
                                
                                for (let i = 0; i < 9; i++) {
                                    if (board[i] === '') {
                                        board[i] = 'X';
                                        const score = minimax(board, depth + 1, true, alpha, beta);
                                        board[i] = '';
                                        bestScore = Math.min(score, bestScore);
                                        
                                        beta = Math.min(beta, bestScore);
                                        if (beta <= alpha) break; // Alpha-beta pruning
                                    }
                                }
                                
                                return bestScore;
                            }
                        }
                        
                        function checkWinForPlayer(board, player) {
                            const winPatterns = [
                                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                                [0, 4, 8], [2, 4, 6]             // diagonals
                            ];
                            
                            return winPatterns.some(pattern => {
                                return pattern.every(index => board[index] === player);
                            });
                        }
                        
                        function checkDrawForBoard(board) {
                            return board.every(cell => cell !== '');
                        }
                        
                        function checkWinner() {
                            return checkWinForPlayer(gameState.board, gameState.currentPlayer);
                        }
                        
                        function checkDraw() {
                            return checkDrawForBoard(gameState.board);
                        }
                        
                        function updateBoard() {
                            const cells = qsa('.tictactoe-cell', boardElement);
                            cells.forEach((cell, index) => {
                                cell.textContent = gameState.board[index];
                                cell.setAttribute('aria-label', `Cell ${index+1}, ${gameState.board[index] || 'empty'}`);
                            });
                            
                            scoreDisplay.innerHTML = `
                                <p>X: ${gameState.scores.X} | O: ${gameState.scores.O} | Draws: ${gameState.scores.draws}</p>
                            `;
                        }
                        
                        function restartGame() {
                            gameState.board = Array(9).fill('');
                            gameState.currentPlayer = 'X';
                            gameState.gameOver = false;
                            updateBoard();
                            
                            // AI makes first move if it's AI's turn and not PvP
                            if (gameState.mode !== 'pvp' && gameState.currentPlayer === 'O') {
                                setTimeout(makeAIMove, 500);
                            }
                        }
                        
                        // Initialize game
                        updateBoard();
                        
                        // Return game API
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Not pausable
                            },
                            
                            resume() {
                                // Not pausable
                            },
                            
                            restart() {
                                restartGame();
                            }
                        };
                    }
                },
                
                // Memory Match game
                memory: {
                    id: 'memory',
                    title: 'Memory Match',
                    description: 'Find matching pairs of cards',
                    icon: DoodleIcon('memory', 32),
                    
                    init(container) {
                        const gameState = {
                            cards: [],
                            flippedCards: [],
                            matchedPairs: 0,
                            moves: 0,
                            difficulty: 'medium', // easy: 6 pairs, medium: 9 pairs, hard: 12 pairs
                            gameOver: false
                        };
                        
                        const difficultySelect = create('div', {
                            className: 'game-controls',
                            innerHTML: `
                                <button class="btn btn-primary" data-difficulty="easy">Easy (6 pairs)</button>
                                <button class="btn btn-secondary" data-difficulty="medium">Medium (9 pairs)</button>
                                <button class="btn btn-secondary" data-difficulty="hard">Hard (12 pairs)</button>
                            `
                        });
                        
                        const statsDisplay = create('div', {
                            className: 'stats-display',
                            innerHTML: `
                                <p>Moves: 0 | Pairs: 0/9</p>
                            `
                        });
                        
                        const gridContainer = create('div', {
                            className: 'memory-grid'
                        });
                        
                        container.appendChild(difficultySelect);
                        container.appendChild(statsDisplay);
                        container.appendChild(gridContainer);
                        
                        // Difficulty selection
                        difficultySelect.addEventListener('click', (e) => {
                            if (e.target.tagName === 'BUTTON') {
                                const difficulty = e.target.dataset.difficulty;
                                gameState.difficulty = difficulty;
                                
                                // Update button styles
                                qsa('button', difficultySelect).forEach(btn => {
                                    btn.className = btn.dataset.difficulty === difficulty ? 'btn btn-primary' : 'btn btn-secondary';
                                });
                                
                                initGame();
                            }
                        });
                        
                        function initGame() {
                            gridContainer.innerHTML = '';
                            gameState.flippedCards = [];
                            gameState.matchedPairs = 0;
                            gameState.moves = 0;
                            gameState.gameOver = false;
                            
                            let pairCount;
                            switch (gameState.difficulty) {
                                case 'easy': pairCount = 6; break;
                                case 'medium': pairCount = 9; break;
                                case 'hard': pairCount = 12; break;
                            }
                            
                            // Create card values (emoji or numbers)
                            const symbols = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮'];
                            const cardValues = [];
                            
                            for (let i = 0; i < pairCount; i++) {
                                cardValues.push(symbols[i]);
                                cardValues.push(symbols[i]);
                            }
                            
                            // Shuffle cards
                            for (let i = cardValues.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [cardValues[i], cardValues[j]] = [cardValues[j], cardValues[i]];
                            }
                            
                            gameState.cards = cardValues;
                            
                            // Create card elements
                            for (let i = 0; i < cardValues.length; i++) {
                                const card = create('div', {
                                    className: 'memory-card',
                                    'data-index': i,
                                    onclick: () => flipCard(i)
                                });
                                
                                const cardInner = create('div', {
                                    className: 'memory-card-inner'
                                });
                                
                                const cardFront = create('div', {
                                    className: 'memory-card-front',
                                    innerHTML: '?'
                                });
                                
                                const cardBack = create('div', {
                                    className: 'memory-card-back',
                                    innerHTML: cardValues[i]
                                });
                                
                                cardInner.appendChild(cardFront);
                                cardInner.appendChild(cardBack);
                                card.appendChild(cardInner);
                                gridContainer.appendChild(card);
                            }
                            
                            updateStats();
                            
                            // Peek functionality - show all cards briefly at start
                            setTimeout(() => {
                                qsa('.memory-card').forEach(card => {
                                    card.classList.add('flipped');
                                });
                                
                                setTimeout(() => {
                                    qsa('.memory-card').forEach(card => {
                                        card.classList.remove('flipped');
                                    });
                                }, 2000);
                            }, 500);
                        }
                        
                        function flipCard(index) {
                            if (gameState.flippedCards.length >= 2 || 
                                gameState.flippedCards.includes(index) || 
                                gameState.gameOver) return;
                            
                            const card = qs(`.memory-card[data-index="${index}"]`);
                            card.classList.add('flipped');
                            gameState.flippedCards.push(index);
                            
                            if (gameState.flippedCards.length === 2) {
                                gameState.moves++;
                                updateStats();
                                
                                setTimeout(() => {
                                    const [firstIndex, secondIndex] = gameState.flippedCards;
                                    
                                    if (gameState.cards[firstIndex] === gameState.cards[secondIndex]) {
                                        // Match found
                                        gameState.matchedPairs++;
                                        
                                        if (gameState.matchedPairs === gameState.cards.length / 2) {
                                            gameState.gameOver = true;
                                            Toast.show('You won!', 'success');
                                            checkAchievement('memory_champ', true, { 
                                                difficulty: gameState.difficulty, 
                                                moves: gameState.moves 
                                            });
                                            updateScores('memory', { 
                                                [gameState.difficulty]: gameState.moves 
                                            });
                                        }
                                    } else {
                                        // No match, flip back
                                        qs(`.memory-card[data-index="${firstIndex}"]`).classList.remove('flipped');
                                        qs(`.memory-card[data-index="${secondIndex}"]`).classList.remove('flipped');
                                    }
                                    
                                    gameState.flippedCards = [];
                                }, 1000);
                            }
                        }
                        
                        function updateStats() {
                            statsDisplay.innerHTML = `
                                <p>Moves: ${gameState.moves} | Pairs: ${gameState.matchedPairs}/${gameState.cards.length / 2}</p>
                            `;
                        }
                        
                        // Initialize game
                        initGame();
                        
                        // Return game API
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Not pausable
                            },
                            
                            resume() {
                                // Not pausable
                            },
                            
                            restart() {
                                initGame();
                            }
                        };
                    }
                },
                
                // Additional game implementations would follow the same pattern
                // For brevity, I'll include stubs for the remaining games
                
                reaction: {
                    id: 'reaction',
                    title: 'Reaction Tester',
                    description: 'Test your reaction speed',
                    icon: DoodleIcon('reaction', 32),
                    
                    init(container) {
                        const gameElement = create('div', {
                            className: 'reaction-game',
                            innerHTML: '<p>Reaction Tester game would be implemented here</p>'
                        });
                        
                        container.appendChild(gameElement);
                        
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Pause logic
                            },
                            
                            resume() {
                                // Resume logic
                            },
                            
                            restart() {
                                // Restart logic
                            }
                        };
                    }
                },
                
                whack: {
                    id: 'whack',
                    title: 'Whack-a-Doodle',
                    description: 'Whack the doodles as they appear',
                    icon: DoodleIcon('whack', 32),
                    
                    init(container) {
                        const gameElement = create('div', {
                            className: 'whack-game',
                            innerHTML: '<p>Whack-a-Doodle game would be implemented here</p>'
                        });
                        
                        container.appendChild(gameElement);
                        
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Pause logic
                            },
                            
                            resume() {
                                // Resume logic
                            },
                            
                            restart() {
                                // Restart logic
                            }
                        };
                    }
                },
                
                dice: {
                    id: 'dice',
                    title: 'Guess & Dice',
                    description: 'Guess numbers and roll dice',
                    icon: DoodleIcon('dice', 32),
                    
                    init(container) {
                        const gameElement = create('div', {
                            className: 'dice-game',
                            innerHTML: '<p>Guess & Dice game would be implemented here</p>'
                        });
                        
                        container.appendChild(gameElement);
                        
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Pause logic
                            },
                            
                            resume() {
                                // Resume logic
                            },
                            
                            restart() {
                                // Restart logic
                            }
                        };
                    }
                },
                
                runner: {
                    id: 'runner',
                    title: 'Shaikh\'s Runner',
                    description: 'Endless runner game',
                    icon: DoodleIcon('runner', 32),
                    
                    init(container) {
                        const gameElement = create('div', {
                            className: 'runner-game',
                            innerHTML: '<p>Shaikh\'s Runner game would be implemented here</p>'
                        });
                        
                        container.appendChild(gameElement);
                        
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Pause logic
                            },
                            
                            resume() {
                                // Resume logic
                            },
                            
                            restart() {
                                // Restart logic
                            }
                        };
                    }
                }
            };
            
            // Update scores in storage
            function updateScores(gameId, scoreData) {
                if (!scores[gameId]) {
                    scores[gameId] = {};
                }
                
                // Handle different score formats
                if (typeof scoreData === 'number') {
                    // For games like Snake that just have a high score
                    if (!scores[gameId].highScore || scoreData > scores[gameId].highScore) {
                        scores[gameId].highScore = scoreData;
                        Storage.set('scores', scores);
                    }
                } else if (typeof scoreData === 'object') {
                    // For games with multiple score types
                    Object.keys(scoreData).forEach(key => {
                        if (!scores[gameId][key] || scoreData[key] > scores[gameId][key]) {
                            scores[gameId][key] = scoreData[key];
                        }
                    });
                    Storage.set('scores', scores);
                }
            }
            
            // Register games
            function registerGames() {
                for (const gameId in GameModules) {
                    gamesRegistry[gameId] = GameModules[gameId];
                }
            }
            
            // Create game preview
            function createGamePreview(gameId) {
                const preview = create('div', { className: 'game-preview' });
                
                switch (gameId) {
                    case 'snake':
                        const snakePreview = create('div', { className: 'snake-preview' });
                        
                        // Create snake segments
                        for (let i = 0; i < 4; i++) {
                            const segment = create('div', {
                                className: 'snake-preview-segment',
                                style: `left: ${20 + i * 8}px; top: 26px;`
                            });
                            snakePreview.appendChild(segment);
                        }
                        
                        // Create food
                        const food = create('div', {
                            className: 'snake-preview-food',
                            style: 'left: 50px; top: 26px;'
                        });
                        snakePreview.appendChild(food);
                        
                        preview.appendChild(snakePreview);
                        break;
                        
                    case 'tictactoe':
                        const tictactoePreview = create('div', { className: 'tictactoe-preview' });
                        
                        // Create a simple X and O pattern
                        for (let i = 0; i < 9; i++) {
                            const cell = create('div', { className: 'tictactoe-preview-cell' });
                            
                            if (i === 0 || i === 4 || i === 8) {
                                cell.textContent = 'X';
                            } else if (i === 2 || i === 6) {
                                cell.textContent = 'O';
                            }
                            
                            tictactoePreview.appendChild(cell);
                        }
                        
                        preview.appendChild(tictactoePreview);
                        break;
                        
                    case 'memory':
                        const memoryPreview = create('div', { className: 'memory-preview' });
                        
                        // Create flipping cards
                        for (let i = 0; i < 6; i++) {
                            const card = create('div', {
                                className: 'memory-preview-card',
                                style: `--delay: ${i};`
                            });
                            memoryPreview.appendChild(card);
                        }
                        
                        preview.appendChild(memoryPreview);
                        break;
                        
                    case 'reaction':
                        const reactionPreview = create('div', { className: 'reaction-preview' });
                        preview.appendChild(reactionPreview);
                        break;
                        
                    case 'whack':
                        const whackPreview = create('div', { className: 'whack-preview' });
                        
                        // Create holes with moles
                        for (let i = 0; i < 3; i++) {
                            const hole = create('div', {
                                className: 'whack-preview-hole',
                                style: `left: ${10 + i * 20}px; top: 20px;`
                            });
                            
                            const mole = create('div', {
                                className: 'whack-preview-mole',
                                style: `left: ${12 + i * 20}px; --delay: ${i};`
                            });
                            
                            whackPreview.appendChild(hole);
                            whackPreview.appendChild(mole);
                        }
                        
                        preview.appendChild(whackPreview);
                        break;
                        
                    case 'dice':
                        const dicePreview = create('div', { className: 'dice-preview' });
                        
                        const dot = create('div', { className: 'dice-preview-dot' });
                        dicePreview.appendChild(dot);
                        
                        preview.appendChild(dicePreview);
                        break;
                        
                    case 'runner':
                        const runnerPreview = create('div', { className: 'runner-preview' });
                        
                        const character = create('div', { className: 'runner-preview-character' });
                        const obstacle = create('div', { className: 'runner-preview-obstacle' });
                        
                        runnerPreview.appendChild(character);
                        runnerPreview.appendChild(obstacle);
                        
                        preview.appendChild(runnerPreview);
                        break;
                }
                
                return preview;
            }
            
            // Render game tiles
            function renderGameTiles() {
                gamesGrid.innerHTML = '';
                
                for (const gameId in gamesRegistry) {
                    const game = gamesRegistry[gameId];
                    
                    const tile = create('div', {
                        className: 'game-tile',
                        tabIndex: 0,
                        onclick: () => openGame(gameId),
                        onkeydown: (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                openGame(gameId);
                            }
                        }
                    }, [
                        create('div', {
                            className: 'game-icon'
                        }, [game.icon]),
                        create('h3', { className: 'game-title', textContent: game.title }),
                        create('p', { className: 'game-description', textContent: game.description }),
                        createGamePreview(gameId)
                    ]);
                    
                    gamesGrid.appendChild(tile);
                    addRippleEffect(tile);
                }
            }
            
            // Open a game
            function openGame(gameId) {
                const game = gamesRegistry[gameId];
                if (!game) return;
                
                // Close any active game
                if (activeGame) {
                    activeGame.destroy();
                    activeGame = null;
                }
                
                // Update UI
                currentGameTitle.textContent = game.title;
                gameContent.innerHTML = '';
                gameView.classList.add('active');
                
                // Initialize the game
                activeGame = game.init(gameContent);
                
                // Set focus to game content for accessibility
                gameContent.setAttribute('tabindex', '-1');
                gameContent.focus();
                
                SoundManager.play('click');
            }
            
            // Close the current game
            function closeGame() {
                if (activeGame) {
                    activeGame.destroy();
                    activeGame = null;
                }
                
                gameView.classList.remove('active');
                
                // Set focus back to the game grid
                gamesGrid.setAttribute('tabindex', '-1');
                gamesGrid.focus();
                gamesGrid.removeAttribute('tabindex');
                
                SoundManager.play('click');
            }
            
            // Initialize the application
            function init() {
                // Initialize systems
                SoundManager.init();
                loadData();
                applySettings();
                
                // Register games and render UI
                registerGames();
                renderGameTiles();
                
                // Add ripple effects to buttons
                qsa('button').forEach(button => {
                    if (!button.classList.contains('snake-control-button')) {
                        addRippleEffect(button);
                    }
                });
                
                // Set up event listeners
                backButton.addEventListener('click', closeGame);
                
                soundToggle.addEventListener('click', () => {
                    settings.soundOn = !settings.soundOn;
                    applySettings();
                    saveData();
                    SoundManager.play('click');
                });
                
                themeToggle.addEventListener('click', () => {
                    settings.theme = settings.theme === 'light' ? 'dark' : 'light';
                    applySettings();
                    saveData();
                    SoundManager.play('click');
                });
                
                settingsButton.addEventListener('click', () => {
                    settingsModal.classList.add('active');
                    SoundManager.play('click');
                });
                
                profileButton.addEventListener('click', () => {
                    profileModal.classList.add('active');
                    SoundManager.play('click');
                    
                    // Populate achievements and scores
                    const achievementsList = qs('#achievementsList');
                    const highScoresList = qs('#highScoresList');
                    
                    achievementsList.innerHTML = '';
                    highScoresList.innerHTML = '';
                    
                    // Display achievements
                    for (const [id, achievement] of Object.entries(achievements)) {
                        if (achievement.unlocked) {
                            const achievementEl = create('div', {
                                className: 'achievement-item',
                                innerHTML: `
                                    <div class="achievement-badge">${DoodleIcon('trophy', 24).outerHTML}</div>
                                    <div>
                                        <strong>${id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</strong>
                                        <p>Unlocked on ${new Date(achievement.timestamp).toLocaleDateString()}</p>
                                    </div>
                                `
                            });
                            achievementsList.appendChild(achievementEl);
                        }
                    }
                    
                    // Display high scores
                    for (const [gameId, gameScores] of Object.entries(scores)) {
                        const scoreEl = create('div', {
                            className: 'score-item',
                            innerHTML: `
                                <h5>${gameId.replace(/\b\w/g, l => l.toUpperCase())}</h5>
                                <pre>${JSON.stringify(gameScores, null, 2)}</pre>
                            `
                        });
                        highScoresList.appendChild(scoreEl);
                    }
                });
                
                gamePause.addEventListener('click', () => {
                    if (activeGame) {
                        activeGame.pause();
                        SoundManager.play('click');
                    }
                });
                
                gameRestart.addEventListener('click', () => {
                    if (activeGame) {
                        activeGame.restart();
                        SoundManager.play('click');
                    }
                });
                
                gameInfo.addEventListener('click', () => {
                    Toast.show('Game information would appear here', 'info');
                    SoundManager.play('click');
                });
                
                closeSettings.addEventListener('click', () => {
                    settingsModal.classList.remove('active');
                    SoundManager.play('click');
                });
                
                closeProfile.addEventListener('click', () => {
                    profileModal.classList.remove('active');
                    SoundManager.play('click');
                });
                
                closeOnboarding.addEventListener('click', () => {
                    onboardingModal.classList.remove('active');
                    SoundManager.play('click');
                });
                
                startPlaying.addEventListener('click', () => {
                    onboardingModal.classList.remove('active');
                    SoundManager.play('click');
                });
                
                saveSettings.addEventListener('click', () => {
                    settings.soundOn = soundToggleSetting.checked;
                    settings.volume = parseFloat(volumeSlider.value);
                    settings.theme = themeSelect.value;
                    settings.showOnboarding = onboardingToggle.checked;
                    
                    applySettings();
                    saveData();
                    settingsModal.classList.remove('active');
                    
                    Toast.show('Settings saved', 'success');
                    SoundManager.play('success');
                });
                
                resetProgress.addEventListener('click', () => {
                    if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                        Storage.remove('scores');
                        Storage.remove('achievements');
                        scores = {};
                        achievements = {};
                        
                        Toast.show('Progress reset', 'info');
                        SoundManager.play('success');
                    }
                });
                
                gameSearch.addEventListener('input', () => {
                    const searchTerm = gameSearch.value.toLowerCase();
                    const tiles = qsa('.game-tile');
                    
                    tiles.forEach(tile => {
                        const title = tile.querySelector('.game-title').textContent.toLowerCase();
                        const description = tile.querySelector('.game-description').textContent.toLowerCase();
                        
                        if (title.includes(searchTerm) || description.includes(searchTerm)) {
                            tile.style.display = 'flex';
                        } else {
                            tile.style.display = 'none';
                        }
                    });
                });
                
                // Handle visibility change to pause games
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && activeGame && activeGame.pause) {
                        activeGame.pause();
                    }
                });
                
                // Check for reduced motion preference
                const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                if (reducedMotion) {
                    document.documentElement.style.setProperty('--transition-fast', '0.01s');
                    document.documentElement.style.setProperty('--transition-normal', '0.01s');
                    document.documentElement.style.setProperty('--transition-slow', '0.01s');
                }
                
                // Check onboarding
                checkOnboarding();
                
                // Self-test
                selfTest();
                
                // Animate logo
                setInterval(() => {
                    logoIcon.style.animation = 'none';
                    setTimeout(() => {
                        logoIcon.style.animation = 'bob 2s infinite';
                    }, 10);
                }, 5000);
            }
            
            // Self-test function
            function selfTest() {
                const tests = {
                    localStorage: () => {
                        try {
                            localStorage.setItem('test', 'test');
                            localStorage.removeItem('test');
                            return true;
                        } catch (e) {
                            return false;
                        }
                    },
                    
                    canvas: () => {
                        return !!document.createElement('canvas').getContext;
                    },
                    
                    webAudio: () => {
                        return !!(window.AudioContext || window.webkitAudioContext);
                    }
                };
                
                let allPassed = true;
                const results = [];
                
                for (const [name, test] of Object.entries(tests)) {
                    const passed = test();
                    allPassed = allPassed && passed;
                    results.push(`${name}: ${passed ? 'PASS' : 'FAIL'}`);
                    
                    if (!passed) {
                        console.warn(`Self-test failed: ${name}`);
                    }
                }
                
                if (!allPassed) {
                    Toast.show('Some features may not work correctly in your browser', 'error', 5000);
                }
            }
            
            // Development check for game modules
            function devCheck() {
                console.log('Checking game modules...');
                
                for (const [id, module] of Object.entries(GameModules)) {
                    console.group(`Game: ${id}`);
                    
                    const requiredMethods = ['init', 'destroy', 'pause', 'resume', 'restart'];
                    const missingMethods = [];
                    
                    for (const method of requiredMethods) {
                        if (typeof module[method] !== 'function') {
                            missingMethods.push(method);
                        }
                    }
                    
                    if (missingMethods.length > 0) {
                        console.warn(`Missing methods: ${missingMethods.join(', ')}`);
                    } else {
                        console.log('✓ All required methods present');
                    }
                    
                    console.groupEnd();
                }
            }
            
            // Start the application
            init();
            
            // Run development check
            devCheck();
        })();
    </script>
</body>
</html>
