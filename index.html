<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaikh's Arcade</title>
    <style>
        /* ====== STYLE ====== */
        :root {
            /* Colors */
            --color-primary: #4285F4;
            --color-secondary: #34A853;
            --color-accent: #EA4335;
            --color-warning: #FBBC05;
            --color-background: #f8f9fa;
            --color-surface: #ffffff;
            --color-text: #202124;
            --color-text-secondary: #5f6368;
            --color-border: #dadce0;
            
            /* Spacing */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --spacing-xxl: 3rem;
            
            /* Border radius */
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --border-radius-lg: 16px;
            --border-radius-xl: 24px;
            --border-radius-circle: 50%;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.1);
            --shadow-md: 0 2px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 12px rgba(0,0,0,0.1);
            --shadow-focus: 0 0 0 2px var(--color-primary);
            
            /* Animation */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
            
            /* Z-index */
            --z-dropdown: 100;
            --z-sticky: 200;
            --z-modal: 300;
            --z-toast: 400;
        }

        .theme-dark {
            --color-background: #202124;
            --color-surface: #303134;
            --color-text: #e8eaed;
            --color-text-secondary: #9aa0a6;
            --color-border: #5f6368;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--color-background);
            color: var(--color-text);
            line-height: 1.5;
            overflow-x: hidden;
            transition: background-color var(--transition-normal);
        }

        button {
            background: none;
            border: none;
            cursor: pointer;
            font-family: inherit;
            color: inherit;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* App Layout */
        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: var(--spacing-md);
            max-width: 1200px;
            margin: 0 auto;
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            position: relative;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--color-primary);
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--color-primary);
            color: white;
            border-radius: var(--border-radius-md);
        }

        .controls {
            display: flex;
            gap: var(--spacing-sm);
        }

        .icon-button {
            width: 40px;
            height: 40px;
            border-radius: var(--border-radius-circle);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-fast);
        }

        .icon-button:hover, .icon-button:focus {
            background-color: var(--color-primary);
            color: white;
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .icon-button:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .search-container {
            margin: var(--spacing-lg) auto;
            max-width: 500px;
            width: 100%;
        }

        .search-input {
            width: 100%;
            padding: var(--spacing-md);
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--color-border);
            background-color: var(--color-surface);
            color: var(--color-text);
            font-size: 1rem;
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-fast);
        }

        .search-input:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
        }

        .game-tile {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-normal);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .game-tile:hover, .game-tile:focus {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
        }

        .game-tile:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .game-icon {
            width: 64px;
            height: 64px;
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            border-radius: var(--border-radius-md);
            background-color: var(--color-primary);
            color: white;
            transition: transform var(--transition-normal);
        }

        .game-tile:hover .game-icon {
            transform: scale(1.1) rotate(5deg);
        }

        .game-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }

        .game-description {
            font-size: 0.875rem;
            color: var(--color-text-secondary);
        }

        /* Game View */
        .game-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-background);
            z-index: var(--z-modal);
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform var(--transition-normal);
            overflow: hidden;
        }

        .game-view.active {
            transform: translateY(0);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            position: relative;
            z-index: 1;
        }

        .game-title-bar {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .game-content {
            flex: 1;
            padding: var(--spacing-md);
            overflow: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-modal);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normal);
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow: auto;
            transform: translateY(20px);
            transition: transform var(--transition-normal);
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border-radius: var(--border-radius-circle);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            transition: background-color var(--transition-fast);
        }

        .modal-close:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .modal-body {
            padding: var(--spacing-md);
        }

        .modal-footer {
            padding: var(--spacing-md);
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
        }

        /* Buttons */
        .btn {
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-md);
            font-weight: 500;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
        }

        .btn:focus {
            outline: none;
            box-shadow: var(--shadow-focus);
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: #3367d6;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }

        .btn-secondary:hover {
            background-color: rgba(0, 0, 0, 0.05);
            transform: translateY(-2px);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: var(--spacing-md);
        }

        .form-label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: 500;
        }

        .form-control {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--color-border);
            background-color: var(--color-surface);
            color: var(--color-text);
            font-family: inherit;
            font-size: 1rem;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
        }

        /* Toasts */
        .toast-container {
            position: fixed;
            bottom: var(--spacing-md);
            right: var(--spacing-md);
            z-index: var(--z-toast);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .toast {
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            max-width: 300px;
            transform: translateX(100%);
            opacity: 0;
            transition: all var(--transition-normal);
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast-success {
            border-left: 4px solid var(--color-secondary);
        }

        .toast-error {
            border-left: 4px solid var(--color-accent);
        }

        .toast-info {
            border-left: 4px solid var(--color-primary);
        }

        /* Game-specific styles */
        .snake-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
        }

        .snake-canvas {
            border: 2px solid var(--color-border);
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
        }

        .game-controls {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        .tictactoe-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            width: 300px;
            height: 300px;
            background-color: var(--color-border);
        }

        .tictactoe-cell {
            background-color: var(--color-surface);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color var(--transition-fast);
        }

        .tictactoe-cell:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            max-width: 500px;
            margin: 0 auto;
        }

        .memory-card {
            width: 100px;
            height: 100px;
            perspective: 1000px;
            cursor: pointer;
        }

        .memory-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .memory-card.flipped .memory-card-inner {
            transform: rotateY(180deg);
        }

        .memory-card-front, .memory-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: var(--border-radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        .memory-card-front {
            background-color: var(--color-primary);
            color: white;
        }

        .memory-card-back {
            background-color: var(--color-surface);
            color: var(--color-text);
            transform: rotateY(180deg);
            box-shadow: var(--shadow-sm);
        }

        .reaction-tester {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
        }

        .reaction-box {
            width: 300px;
            height: 300px;
            border-radius: var(--border-radius-lg);
            background-color: var(--color-accent);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color var(--transition-fast);
        }

        .reaction-box.waiting {
            background-color: var(--color-warning);
        }

        .reaction-box.ready {
            background-color: var(--color-secondary);
        }

        .whack-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 16px;
            max-width: 400px;
            margin: 0 auto;
        }

        .whack-hole {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #8B4513;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .whack-mole {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: #795548;
            bottom: -70px;
            left: 5px;
            transition: bottom 0.2s ease;
        }

        .whack-mole.up {
            bottom: 5px;
        }

        .dice-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
        }

        .dice-container {
            display: flex;
            gap: var(--spacing-md);
        }

        .dice {
            width: 60px;
            height: 60px;
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .runner-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
        }

        .runner-canvas {
            border: 2px solid var(--color-border);
            border-radius: var(--border-radius-md);
            background-color: var(--color-surface);
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .games-grid {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
            
            .tictactoe-board {
                width: 250px;
                height: 250px;
            }
            
            .memory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .memory-card {
                width: 80px;
                height: 80px;
            }
        }

        @media (max-width: 480px) {
            .app-header {
                flex-direction: column;
                gap: var(--spacing-md);
            }
            
            .games-grid {
                grid-template-columns: 1fr;
            }
            
            .tictactoe-board {
                width: 200px;
                height: 200px;
            }
            
            .memory-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .memory-card {
                width: 70px;
                height: 70px;
            }
            
            .reaction-box {
                width: 200px;
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- ====== TEMPLATE (HTML) ====== -->
    <div class="app">
        <header class="app-header">
            <div class="logo">
                <div class="logo-icon">🎮</div>
                <h1>Shaikh's Arcade</h1>
            </div>
            <div class="controls">
                <button class="icon-button" id="soundToggle" aria-label="Toggle sound">
                    <span class="sound-icon">🔊</span>
                </button>
                <button class="icon-button" id="themeToggle" aria-label="Toggle theme">
                    <span class="theme-icon">🌙</span>
                </button>
                <button class="icon-button" id="settingsButton" aria-label="Open settings">
                    <span class="settings-icon">⚙️</span>
                </button>
                <button class="icon-button" id="profileButton" aria-label="Open profile">
                    <span class="profile-icon">👤</span>
                </button>
            </div>
        </header>

        <div class="search-container">
            <input type="text" class="search-input" id="gameSearch" placeholder="Search games..." aria-label="Search games">
        </div>

        <div class="games-grid" id="gamesGrid">
            <!-- Game tiles will be populated by JavaScript -->
        </div>

        <div class="game-view" id="gameView">
            <div class="game-header">
                <div class="game-title-bar">
                    <button class="btn btn-secondary" id="backButton">
                        ← Back
                    </button>
                    <h2 class="game-title" id="currentGameTitle">Game Title</h2>
                </div>
                <div class="game-controls">
                    <button class="icon-button" id="gameInfo" aria-label="Game information">
                        ℹ️
                    </button>
                    <button class="icon-button" id="gameRestart" aria-label="Restart game">
                        🔄
                    </button>
                    <button class="icon-button" id="gamePause" aria-label="Pause game">
                        ⏸️
                    </button>
                </div>
            </div>
            <div class="game-content" id="gameContent">
                <!-- Game content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Settings</h3>
                <button class="modal-close" id="closeSettings">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="soundToggleSetting">Sound</label>
                    <div class="form-control">
                        <label>
                            <input type="checkbox" id="soundToggleSetting">
                            Enable sound
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label" for="volumeSlider">Volume</label>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.1" class="form-control">
                </div>
                <div class="form-group">
                    <label class="form-label" for="themeSelect">Theme</label>
                    <select id="themeSelect" class="form-control">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="auto">Auto (system)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="onboardingToggle">Show onboarding</label>
                    <div class="form-control">
                        <label>
                            <input type="checkbox" id="onboardingToggle">
                            Show onboarding on startup
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="resetProgress">
                    Reset Progress
                </button>
                <button class="btn btn-primary" id="saveSettings">
                    Save
                </button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="profileModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Your Profile</h3>
                <button class="modal-close" id="closeProfile">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <h4>Achievements</h4>
                    <div id="achievementsList">
                        <!-- Achievements will be populated by JavaScript -->
                    </div>
                </div>
                <div class="form-group">
                    <h4>High Scores</h4>
                    <div id="highScoresList">
                        <!-- High scores will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="onboardingModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Welcome to Shaikh's Arcade!</h3>
                <button class="modal-close" id="closeOnboarding">✕</button>
            </div>
            <div class="modal-body">
                <p>🎮 Play a collection of fun mini-games</p>
                <p>🏆 Earn achievements and track high scores</p>
                <p>⚙️ Customize your experience in settings</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="startPlaying">
                    Start Playing
                </button>
            </div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer">
        <!-- Toasts will be added here by JavaScript -->
    </div>

    <script>
        /* ====== SCRIPTS ====== */
        (function() {
            'use strict';
            
            // Utility functions
            const qs = (selector, root = document) => root.querySelector(selector);
            const qsa = (selector, root = document) => Array.from(root.querySelectorAll(selector));
            const create = (tag, props = {}, children = []) => {
                const el = document.createElement(tag);
                Object.keys(props).forEach(key => {
                    el[key] = props[key];
                });
                children.forEach(child => {
                    if (typeof child === 'string') {
                        el.appendChild(document.createTextNode(child));
                    } else {
                        el.appendChild(child);
                    }
                });
                return el;
            };
            
            // App state
            let activeGame = null;
            let gamesRegistry = {};
            let settings = {
                soundOn: true,
                volume: 0.5,
                theme: 'light',
                showOnboarding: true
            };
            let scores = {};
            let achievements = {};
            
            // DOM elements
            const gamesGrid = qs('#gamesGrid');
            const gameView = qs('#gameView');
            const gameContent = qs('#gameContent');
            const currentGameTitle = qs('#currentGameTitle');
            const gameSearch = qs('#gameSearch');
            const backButton = qs('#backButton');
            const soundToggle = qs('#soundToggle');
            const themeToggle = qs('#themeToggle');
            const settingsButton = qs('#settingsButton');
            const profileButton = qs('#profileButton');
            const gamePause = qs('#gamePause');
            const gameRestart = qs('#gameRestart');
            const gameInfo = qs('#gameInfo');
            
            // Modals
            const settingsModal = qs('#settingsModal');
            const profileModal = qs('#profileModal');
            const onboardingModal = qs('#onboardingModal');
            const closeSettings = qs('#closeSettings');
            const closeProfile = qs('#closeProfile');
            const closeOnboarding = qs('#closeOnboarding');
            const soundToggleSetting = qs('#soundToggleSetting');
            const volumeSlider = qs('#volumeSlider');
            const themeSelect = qs('#themeSelect');
            const onboardingToggle = qs('#onboardingToggle');
            const resetProgress = qs('#resetProgress');
            const saveSettings = qs('#saveSettings');
            const startPlaying = qs('#startPlaying');
            
            // Sound Manager
            const SoundManager = {
                audioContext: null,
                enabled: true,
                volume: 0.5,
                
                init() {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        this.enabled = true;
                    } catch (e) {
                        console.warn('Web Audio API is not supported in this browser');
                        this.enabled = false;
                    }
                },
                
                play(kind) {
                    if (!this.enabled || !this.audioContext || !settings.soundOn) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    let frequency = 440;
                    let duration = 0.1;
                    
                    switch (kind) {
                        case 'click':
                            frequency = 523.25;
                            break;
                        case 'success':
                            frequency = 783.99;
                            break;
                        case 'error':
                            frequency = 349.23;
                            break;
                        case 'eat':
                            frequency = 659.25;
                            duration = 0.05;
                            break;
                        case 'hit':
                            frequency = 392;
                            duration = 0.08;
                            break;
                    }
                    
                    gainNode.gain.value = this.volume;
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    oscillator.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    oscillator.stop(this.audioContext.currentTime + duration);
                },
                
                setVolume(volume) {
                    this.volume = volume;
                },
                
                toggle() {
                    this.enabled = !this.enabled;
                    return this.enabled;
                }
            };
            
            // Toast system
            const Toast = {
                container: qs('#toastContainer'),
                
                show(message, type = 'info', duration = 3000) {
                    const toast = create('div', {
                        className: `toast toast-${type}`,
                        innerHTML: `<span>${message}</span>`
                    });
                    
                    this.container.appendChild(toast);
                    
                    // Trigger reflow
                    toast.offsetHeight;
                    
                    toast.classList.add('show');
                    
                    setTimeout(() => {
                        toast.classList.remove('show');
                        setTimeout(() => {
                            if (toast.parentNode) {
                                toast.parentNode.removeChild(toast);
                            }
                        }, 300);
                    }, duration);
                }
            };
            
            // LocalStorage management
            const Storage = {
                get(key) {
                    try {
                        const item = localStorage.getItem(`shaikhArcade.${key}`);
                        return item ? JSON.parse(item) : null;
                    } catch (e) {
                        console.error('Error reading from localStorage', e);
                        return null;
                    }
                },
                
                set(key, value) {
                    try {
                        localStorage.setItem(`shaikhArcade.${key}`, JSON.stringify(value));
                    } catch (e) {
                        console.error('Error writing to localStorage', e);
                    }
                },
                
                remove(key) {
                    try {
                        localStorage.removeItem(`shaikhArcade.${key}`);
                    } catch (e) {
                        console.error('Error removing from localStorage', e);
                    }
                }
            };
            
            // Load saved data
            function loadData() {
                const savedSettings = Storage.get('settings');
                if (savedSettings) {
                    settings = { ...settings, ...savedSettings };
                }
                
                const savedScores = Storage.get('scores');
                if (savedScores) {
                    scores = savedScores;
                }
                
                const savedAchievements = Storage.get('achievements');
                if (savedAchievements) {
                    achievements = savedAchievements;
                }
            }
            
            // Save data
            function saveData() {
                Storage.set('settings', settings);
                Storage.set('scores', scores);
                Storage.set('achievements', achievements);
            }
            
            // Apply settings to UI
            function applySettings() {
                // Apply theme
                if (settings.theme === 'dark' || (settings.theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    document.body.classList.add('theme-dark');
                    themeToggle.querySelector('.theme-icon').textContent = '☀️';
                } else {
                    document.body.classList.remove('theme-dark');
                    themeToggle.querySelector('.theme-icon').textContent = '🌙';
                }
                
                // Apply sound settings
                soundToggle.querySelector('.sound-icon').textContent = settings.soundOn ? '🔊' : '🔇';
                SoundManager.setVolume(settings.volume);
                
                // Update settings modal
                soundToggleSetting.checked = settings.soundOn;
                volumeSlider.value = settings.volume;
                themeSelect.value = settings.theme;
                onboardingToggle.checked = settings.showOnboarding;
            }
            
            // Show onboarding if needed
            function checkOnboarding() {
                if (settings.showOnboarding) {
                    onboardingModal.classList.add('active');
                }
            }
            
            // Game modules
            const GameModules = {
                // Smooth Snake game
                snake: {
                    id: 'snake',
                    title: 'Smooth Snake',
                    description: 'Guide the snake to eat food and grow longer',
                    icon: '🐍',
                    
                    init(container) {
                        const canvas = create('canvas', {
                            className: 'snake-canvas',
                            width: 400,
                            height: 400
                        });
                        
                        const ctx = canvas.getContext('2d');
                        const gameState = {
                            snake: [{x: 10, y: 10}],
                            food: {x: 5, y: 5},
                            direction: 'right',
                            nextDirection: 'right',
                            score: 0,
                            gameOver: false,
                            paused: false,
                            gridSize: 20,
                            speed: 150,
                            lastUpdate: 0
                        };
                        
                        container.appendChild(canvas);
                        
                        // Game logic
                        function update(currentTime) {
                            if (gameState.paused || gameState.gameOver) return;
                            
                            if (!gameState.lastUpdate) gameState.lastUpdate = currentTime;
                            const deltaTime = currentTime - gameState.lastUpdate;
                            
                            if (deltaTime > gameState.speed) {
                                gameState.lastUpdate = currentTime;
                                
                                // Update direction
                                gameState.direction = gameState.nextDirection;
                                
                                // Move snake
                                const head = {...gameState.snake[0]};
                                
                                switch (gameState.direction) {
                                    case 'up': head.y--; break;
                                    case 'down': head.y++; break;
                                    case 'left': head.x--; break;
                                    case 'right': head.x++; break;
                                }
                                
                                // Check wall collision
                                if (head.x < 0 || head.x >= canvas.width / gameState.gridSize ||
                                    head.y < 0 || head.y >= canvas.height / gameState.gridSize) {
                                    gameState.gameOver = true;
                                    SoundManager.play('error');
                                    checkAchievement('snakeMaster', gameState.score >= 500);
                                    return;
                                }
                                
                                // Check self collision
                                for (let i = 0; i < gameState.snake.length; i++) {
                                    if (gameState.snake[i].x === head.x && gameState.snake[i].y === head.y) {
                                        gameState.gameOver = true;
                                        SoundManager.play('error');
                                        checkAchievement('snakeMaster', gameState.score >= 500);
                                        return;
                                    }
                                }
                                
                                // Add new head
                                gameState.snake.unshift(head);
                                
                                // Check food collision
                                if (head.x === gameState.food.x && head.y === gameState.food.y) {
                                    gameState.score += 10;
                                    SoundManager.play('eat');
                                    placeFood();
                                    
                                    // Increase speed every 5 foods
                                    if (gameState.score % 50 === 0 && gameState.speed > 50) {
                                        gameState.speed -= 10;
                                    }
                                } else {
                                    // Remove tail if no food eaten
                                    gameState.snake.pop();
                                }
                            }
                            
                            requestAnimationFrame(update);
                        }
                        
                        function placeFood() {
                            let newFood;
                            let overlapping;
                            
                            do {
                                newFood = {
                                    x: Math.floor(Math.random() * (canvas.width / gameState.gridSize)),
                                    y: Math.floor(Math.random() * (canvas.height / gameState.gridSize))
                                };
                                
                                overlapping = false;
                                for (const segment of gameState.snake) {
                                    if (segment.x === newFood.x && segment.y === newFood.y) {
                                        overlapping = true;
                                        break;
                                    }
                                }
                            } while (overlapping);
                            
                            gameState.food = newFood;
                        }
                        
                        function draw() {
                            // Clear canvas
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-background');
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Draw food
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-accent');
                            ctx.fillRect(
                                gameState.food.x * gameState.gridSize,
                                gameState.food.y * gameState.gridSize,
                                gameState.gridSize,
                                gameState.gridSize
                            );
                            
                            // Draw snake
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-secondary');
                            for (const segment of gameState.snake) {
                                ctx.fillRect(
                                    segment.x * gameState.gridSize,
                                    segment.y * gameState.gridSize,
                                    gameState.gridSize,
                                    gameState.gridSize
                                );
                            }
                            
                            // Draw score
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-text');
                            ctx.font = '16px sans-serif';
                            ctx.fillText(`Score: ${gameState.score}`, 10, 20);
                            
                            if (gameState.gameOver) {
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                ctx.fillStyle = 'white';
                                ctx.font = '24px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 20);
                                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 20);
                                ctx.textAlign = 'left';
                            } else if (gameState.paused) {
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                ctx.fillStyle = 'white';
                                ctx.font = '24px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
                                ctx.textAlign = 'left';
                            }
                        }
                        
                        function gameLoop() {
                            draw();
                            requestAnimationFrame(gameLoop);
                        }
                        
                        // Input handling
                        function handleKeyDown(e) {
                            switch (e.key) {
                                case 'ArrowUp':
                                case 'w':
                                case 'W':
                                    if (gameState.direction !== 'down') gameState.nextDirection = 'up';
                                    break;
                                case 'ArrowDown':
                                case 's':
                                case 'S':
                                    if (gameState.direction !== 'up') gameState.nextDirection = 'down';
                                    break;
                                case 'ArrowLeft':
                                case 'a':
                                case 'A':
                                    if (gameState.direction !== 'right') gameState.nextDirection = 'left';
                                    break;
                                case 'ArrowRight':
                                case 'd':
                                case 'D':
                                    if (gameState.direction !== 'left') gameState.nextDirection = 'right';
                                    break;
                                case ' ':
                                    gameState.paused = !gameState.paused;
                                    break;
                            }
                        }
                        
                        // Initialize game
                        placeFood();
                        requestAnimationFrame(update);
                        requestAnimationFrame(gameLoop);
                        document.addEventListener('keydown', handleKeyDown);
                        
                        // Return game API
                        return {
                            destroy() {
                                document.removeEventListener('keydown', handleKeyDown);
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                gameState.paused = true;
                            },
                            
                            resume() {
                                gameState.paused = false;
                                gameState.lastUpdate = 0;
                            },
                            
                            restart() {
                                gameState.snake = [{x: 10, y: 10}];
                                gameState.direction = 'right';
                                gameState.nextDirection = 'right';
                                gameState.score = 0;
                                gameState.gameOver = false;
                                gameState.paused = false;
                                gameState.speed = 150;
                                gameState.lastUpdate = 0;
                                placeFood();
                            }
                        };
                    }
                },
                
                // Tic-Tac-Toe game
                tictactoe: {
                    id: 'tictactoe',
                    title: 'Tic-Tac-Toe',
                    description: 'Classic X and O game with AI opponents',
                    icon: '⭕',
                    
                    init(container) {
                        const gameState = {
                            board: Array(9).fill(''),
                            currentPlayer: 'X',
                            gameOver: false,
                            mode: 'pvp', // pvp, easy, medium, hard
                            scores: { X: 0, O: 0, draws: 0 }
                        };
                        
                        const boardElement = create('div', { className: 'tictactoe-board' });
                        
                        // Create cells
                        for (let i = 0; i < 9; i++) {
                            const cell = create('div', {
                                className: 'tictactoe-cell',
                                'data-index': i,
                                onclick: () => makeMove(i)
                            });
                            boardElement.appendChild(cell);
                        }
                        
                        container.appendChild(boardElement);
                        
                        // Mode selection
                        const modeSelect = create('div', {
                            className: 'game-controls',
                            innerHTML: `
                                <button class="btn btn-primary" data-mode="pvp">PvP</button>
                                <button class="btn btn-secondary" data-mode="easy">Easy AI</button>
                                <button class="btn btn-secondary" data-mode="medium">Medium AI</button>
                                <button class="btn btn-secondary" data-mode="hard">Hard AI</button>
                            `
                        });
                        
                        modeSelect.addEventListener('click', (e) => {
                            if (e.target.tagName === 'BUTTON') {
                                const mode = e.target.dataset.mode;
                                gameState.mode = mode;
                                
                                // Update button styles
                                qsa('button', modeSelect).forEach(btn => {
                                    btn.className = btn.dataset.mode === mode ? 'btn btn-primary' : 'btn btn-secondary';
                                });
                                
                                restartGame();
                            }
                        });
                        
                        container.appendChild(modeSelect);
                        
                        // Game functions
                        function makeMove(index) {
                            if (gameState.board[index] !== '' || gameState.gameOver) return;
                            
                            gameState.board[index] = gameState.currentPlayer;
                            updateBoard();
                            
                            if (checkWinner()) {
                                gameState.gameOver = true;
                                gameState.scores[gameState.currentPlayer]++;
                                Toast.show(`Player ${gameState.currentPlayer} wins!`, 'success');
                                checkAchievement('firstWin', true);
                                return;
                            }
                            
                            if (checkDraw()) {
                                gameState.gameOver = true;
                                gameState.scores.draws++;
                                Toast.show('It\'s a draw!', 'info');
                                return;
                            }
                            
                            // Switch player
                            gameState.currentPlayer = gameState.currentPlayer === 'X' ? 'O' : 'X';
                            
                            // AI move if needed
                            if (!gameState.gameOver && gameState.mode !== 'pvp' && gameState.currentPlayer === 'O') {
                                setTimeout(makeAIMove, 500);
                            }
                        }
                        
                        function makeAIMove() {
                            let move;
                            
                            switch (gameState.mode) {
                                case 'easy':
                                    move = makeEasyAIMove();
                                    break;
                                case 'medium':
                                    move = makeMediumAIMove();
                                    break;
                                case 'hard':
                                    move = makeHardAIMove();
                                    break;
                            }
                            
                            if (move !== undefined) {
                                makeMove(move);
                            }
                        }
                        
                        function makeEasyAIMove() {
                            // Just pick a random available move
                            const availableMoves = [];
                            for (let i = 0; i < 9; i++) {
                                if (gameState.board[i] === '') {
                                    availableMoves.push(i);
                                }
                            }
                            
                            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
                        }
                        
                        function makeMediumAIMove() {
                            // Try to win if possible, block if necessary, otherwise random
                            const availableMoves = [];
                            for (let i = 0; i < 9; i++) {
                                if (gameState.board[i] === '') {
                                    availableMoves.push(i);
                                }
                            }
                            
                            // Check for winning move
                            for (const move of availableMoves) {
                                const testBoard = [...gameState.board];
                                testBoard[move] = 'O';
                                if (checkWinForPlayer(testBoard, 'O')) {
                                    return move;
                                }
                            }
                            
                            // Check for blocking move
                            for (const move of availableMoves) {
                                const testBoard = [...gameState.board];
                                testBoard[move] = 'X';
                                if (checkWinForPlayer(testBoard, 'X')) {
                                    return move;
                                }
                            }
                            
                            // Otherwise random
                            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
                        }
                        
                        function makeHardAIMove() {
                            // Minimax algorithm for optimal play
                            let bestScore = -Infinity;
                            let bestMove;
                            
                            for (let i = 0; i < 9; i++) {
                                if (gameState.board[i] === '') {
                                    gameState.board[i] = 'O';
                                    const score = minimax(gameState.board, 0, false);
                                    gameState.board[i] = '';
                                    
                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestMove = i;
                                    }
                                }
                            }
                            
                            return bestMove;
                        }
                        
                        function minimax(board, depth, isMaximizing) {
                            // Base cases
                            if (checkWinForPlayer(board, 'O')) return 10 - depth;
                            if (checkWinForPlayer(board, 'X')) return depth - 10;
                            if (checkDrawForBoard(board)) return 0;
                            
                            // Recursive case
                            if (isMaximizing) {
                                let bestScore = -Infinity;
                                
                                for (let i = 0; i < 9; i++) {
                                    if (board[i] === '') {
                                        board[i] = 'O';
                                        const score = minimax(board, depth + 1, false);
                                        board[i] = '';
                                        bestScore = Math.max(score, bestScore);
                                    }
                                }
                                
                                return bestScore;
                            } else {
                                let bestScore = Infinity;
                                
                                for (let i = 0; i < 9; i++) {
                                    if (board[i] === '') {
                                        board[i] = 'X';
                                        const score = minimax(board, depth + 1, true);
                                        board[i] = '';
                                        bestScore = Math.min(score, bestScore);
                                    }
                                }
                                
                                return bestScore;
                            }
                        }
                        
                        function checkWinForPlayer(board, player) {
                            const winPatterns = [
                                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                                [0, 4, 8], [2, 4, 6]             // diagonals
                            ];
                            
                            return winPatterns.some(pattern => {
                                return pattern.every(index => board[index] === player);
                            });
                        }
                        
                        function checkDrawForBoard(board) {
                            return board.every(cell => cell !== '');
                        }
                        
                        function checkWinner() {
                            return checkWinForPlayer(gameState.board, gameState.currentPlayer);
                        }
                        
                        function checkDraw() {
                            return checkDrawForBoard(gameState.board);
                        }
                        
                        function updateBoard() {
                            const cells = qsa('.tictactoe-cell', boardElement);
                            cells.forEach((cell, index) => {
                                cell.textContent = gameState.board[index];
                            });
                        }
                        
                        function restartGame() {
                            gameState.board = Array(9).fill('');
                            gameState.currentPlayer = 'X';
                            gameState.gameOver = false;
                            updateBoard();
                            
                            // AI makes first move if it's AI's turn and not PvP
                            if (gameState.mode !== 'pvp' && gameState.currentPlayer === 'O') {
                                setTimeout(makeAIMove, 500);
                            }
                        }
                        
                        // Initialize game
                        updateBoard();
                        
                        // Return game API
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Not pausable
                            },
                            
                            resume() {
                                // Not pausable
                            },
                            
                            restart() {
                                restartGame();
                            }
                        };
                    }
                },
                
                // Additional game implementations would follow the same pattern
                // For brevity, I'll include stubs for the remaining games
                
                memory: {
                    id: 'memory',
                    title: 'Memory Match',
                    description: 'Find matching pairs of cards',
                    icon: '🎴',
                    
                    init(container) {
                        const gameElement = create('div', {
                            className: 'memory-game',
                            innerHTML: '<p>Memory Match game would be implemented here</p>'
                        });
                        
                        container.appendChild(gameElement);
                        
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Pause logic
                            },
                            
                            resume() {
                                // Resume logic
                            },
                            
                            restart() {
                                // Restart logic
                            }
                        };
                    }
                },
                
                reaction: {
                    id: 'reaction',
                    title: 'Reaction Tester',
                    description: 'Test your reaction speed',
                    icon: '⏱️',
                    
                    init(container) {
                        const gameElement = create('div', {
                            className: 'reaction-game',
                            innerHTML: '<p>Reaction Tester game would be implemented here</p>'
                        });
                        
                        container.appendChild(gameElement);
                        
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Pause logic
                            },
                            
                            resume() {
                                // Resume logic
                            },
                            
                            restart() {
                                // Restart logic
                            }
                        };
                    }
                },
                
                whack: {
                    id: 'whack',
                    title: 'Whack-a-Doodle',
                    description: 'Whack the doodles as they appear',
                    icon: '🔨',
                    
                    init(container) {
                        const gameElement = create('div', {
                            className: 'whack-game',
                            innerHTML: '<p>Whack-a-Doodle game would be implemented here</p>'
                        });
                        
                        container.appendChild(gameElement);
                        
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Pause logic
                            },
                            
                            resume() {
                                // Resume logic
                            },
                            
                            restart() {
                                // Restart logic
                            }
                        };
                    }
                },
                
                dice: {
                    id: 'dice',
                    title: 'Guess & Dice',
                    description: 'Guess numbers and roll dice',
                    icon: '🎲',
                    
                    init(container) {
                        const gameElement = create('div', {
                            className: 'dice-game',
                            innerHTML: '<p>Guess & Dice game would be implemented here</p>'
                        });
                        
                        container.appendChild(gameElement);
                        
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Pause logic
                            },
                            
                            resume() {
                                // Resume logic
                            },
                            
                            restart() {
                                // Restart logic
                            }
                        };
                    }
                },
                
                runner: {
                    id: 'runner',
                    title: 'Shaikh\'s Runner',
                    description: 'Endless runner game',
                    icon: '🏃',
                    
                    init(container) {
                        const gameElement = create('div', {
                            className: 'runner-game',
                            innerHTML: '<p>Shaikh\'s Runner game would be implemented here</p>'
                        });
                        
                        container.appendChild(gameElement);
                        
                        return {
                            destroy() {
                                container.innerHTML = '';
                            },
                            
                            pause() {
                                // Pause logic
                            },
                            
                            resume() {
                                // Resume logic
                            },
                            
                            restart() {
                                // Restart logic
                            }
                        };
                    }
                }
            };
            
            // Register games
            function registerGames() {
                for (const gameId in GameModules) {
                    gamesRegistry[gameId] = GameModules[gameId];
                }
            }
            
            // Render game tiles
            function renderGameTiles() {
                gamesGrid.innerHTML = '';
                
                for (const gameId in gamesRegistry) {
                    const game = gamesRegistry[gameId];
                    
                    const tile = create('div', {
                        className: 'game-tile',
                        tabIndex: 0,
                        onclick: () => openGame(gameId),
                        onkeydown: (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                openGame(gameId);
                            }
                        }
                    }, [
                        create('div', {
                            className: 'game-icon',
                            innerHTML: game.icon
                        }),
                        create('h3', { className: 'game-title', textContent: game.title }),
                        create('p', { className: 'game-description', textContent: game.description })
                    ]);
                    
                    gamesGrid.appendChild(tile);
                }
            }
            
            // Open a game
            function openGame(gameId) {
                const game = gamesRegistry[gameId];
                if (!game) return;
                
                // Close any active game
                if (activeGame) {
                    activeGame.destroy();
                    activeGame = null;
                }
                
                // Update UI
                currentGameTitle.textContent = game.title;
                gameContent.innerHTML = '';
                gameView.classList.add('active');
                
                // Initialize the game
                activeGame = game.init(gameContent);
                
                // Set focus to game content for accessibility
                gameContent.setAttribute('tabindex', '-1');
                gameContent.focus();
                
                SoundManager.play('click');
            }
            
            // Close the current game
            function closeGame() {
                if (activeGame) {
                    activeGame.destroy();
                    activeGame = null;
                }
                
                gameView.classList.remove('active');
                
                // Set focus back to the game grid
                gamesGrid.setAttribute('tabindex', '-1');
                gamesGrid.focus();
                gamesGrid.removeAttribute('tabindex');
                
                SoundManager.play('click');
            }
            
            // Check and unlock achievements
            function checkAchievement(achievementId, condition) {
                if (condition && !achievements[achievementId]) {
                    achievements[achievementId] = true;
                    Storage.set('achievements', achievements);
                    
                    let message = '';
                    switch (achievementId) {
                        case 'firstWin':
                            message = 'Achievement Unlocked: First Win!';
                            break;
                        case 'snakeMaster':
                            message = 'Achievement Unlocked: Snake Master!';
                            break;
                        // More achievements would be handled here
                    }
                    
                    if (message) {
                        Toast.show(message, 'success');
                    }
                }
            }
            
            // Initialize the application
            function init() {
                // Initialize systems
                SoundManager.init();
                loadData();
                applySettings();
                
                // Register games and render UI
                registerGames();
                renderGameTiles();
                
                // Set up event listeners
                backButton.addEventListener('click', closeGame);
                
                soundToggle.addEventListener('click', () => {
                    settings.soundOn = !settings.soundOn;
                    applySettings();
                    saveData();
                    SoundManager.play('click');
                });
                
                themeToggle.addEventListener('click', () => {
                    settings.theme = settings.theme === 'light' ? 'dark' : 'light';
                    applySettings();
                    saveData();
                    SoundManager.play('click');
                });
                
                settingsButton.addEventListener('click', () => {
                    settingsModal.classList.add('active');
                    SoundManager.play('click');
                });
                
                profileButton.addEventListener('click', () => {
                    profileModal.classList.add('active');
                    SoundManager.play('click');
                });
                
                gamePause.addEventListener('click', () => {
                    if (activeGame) {
                        activeGame.pause();
                        SoundManager.play('click');
                    }
                });
                
                gameRestart.addEventListener('click', () => {
                    if (activeGame) {
                        activeGame.restart();
                        SoundManager.play('click');
                    }
                });
                
                gameInfo.addEventListener('click', () => {
                    Toast.show('Game information would appear here', 'info');
                    SoundManager.play('click');
                });
                
                closeSettings.addEventListener('click', () => {
                    settingsModal.classList.remove('active');
                    SoundManager.play('click');
                });
                
                closeProfile.addEventListener('click', () => {
                    profileModal.classList.remove('active');
                    SoundManager.play('click');
                });
                
                closeOnboarding.addEventListener('click', () => {
                    onboardingModal.classList.remove('active');
                    SoundManager.play('click');
                });
                
                startPlaying.addEventListener('click', () => {
                    onboardingModal.classList.remove('active');
                    SoundManager.play('click');
                });
                
                saveSettings.addEventListener('click', () => {
                    settings.soundOn = soundToggleSetting.checked;
                    settings.volume = parseFloat(volumeSlider.value);
                    settings.theme = themeSelect.value;
                    settings.showOnboarding = onboardingToggle.checked;
                    
                    applySettings();
                    saveData();
                    settingsModal.classList.remove('active');
                    
                    Toast.show('Settings saved', 'success');
                    SoundManager.play('success');
                });
                
                resetProgress.addEventListener('click', () => {
                    if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                        Storage.remove('scores');
                        Storage.remove('achievements');
                        scores = {};
                        achievements = {};
                        
                        Toast.show('Progress reset', 'info');
                        SoundManager.play('success');
                    }
                });
                
                gameSearch.addEventListener('input', () => {
                    const searchTerm = gameSearch.value.toLowerCase();
                    const tiles = qsa('.game-tile');
                    
                    tiles.forEach(tile => {
                        const title = tile.querySelector('.game-title').textContent.toLowerCase();
                        const description = tile.querySelector('.game-description').textContent.toLowerCase();
                        
                        if (title.includes(searchTerm) || description.includes(searchTerm)) {
                            tile.style.display = 'flex';
                        } else {
                            tile.style.display = 'none';
                        }
                    });
                });
                
                // Check for reduced motion preference
                const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                if (reducedMotion) {
                    document.documentElement.style.setProperty('--transition-fast', '0.01s');
                    document.documentElement.style.setProperty('--transition-normal', '0.01s');
                    document.documentElement.style.setProperty('--transition-slow', '0.01s');
                }
                
                // Check onboarding
                checkOnboarding();
                
                // Self-test
                selfTest();
            }
            
            // Self-test function
            function selfTest() {
                const tests = {
                    localStorage: () => {
                        try {
                            localStorage.setItem('test', 'test');
                            localStorage.removeItem('test');
                            return true;
                        } catch (e) {
                            return false;
                        }
                    },
                    
                    canvas: () => {
                        return !!document.createElement('canvas').getContext;
                    },
                    
                    webAudio: () => {
                        return !!(window.AudioContext || window.webkitAudioContext);
                    }
                };
                
                let allPassed = true;
                const results = [];
                
                for (const [name, test] of Object.entries(tests)) {
                    const passed = test();
                    allPassed = allPassed && passed;
                    results.push(`${name}: ${passed ? 'PASS' : 'FAIL'}`);
                    
                    if (!passed) {
                        console.warn(`Self-test failed: ${name}`);
                    }
                }
                
                if (!allPassed) {
                    Toast.show('Some features may not work correctly in your browser', 'error', 5000);
                }
            }
            
            // Start the application
            init();
        })();
    </script>
</body>
</html>
