<!DOCTYPE html>
                        <html lang="en">
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <style>
                body {
                  background-color: white; /* Ensure the iframe has a white background */
                }
    
                
              </style>
                        </head>
                        <body>
                            <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaikh's Enhanced Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700&family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        /* ===== CSS Variables - Enhanced Theme with Google Doodle Colors ===== */
        :root {
            /* Light Theme (Default) - Google Doodle Palette */
            --color-blue: #4285f4;
            --color-green: #34a853;
            --color-yellow: #fbbc04;
            --color-red: #ea4335;
            --color-blue-light: #8ab4f8;
            --color-green-light: #7bcfa9;
            --color-yellow-light: #fcd669;
            --color-red-light: #f28b82;
            --color-blue-dark: #1a56db;
            --color-green-dark: #2e8b57;
            --color-yellow-dark: #e6ac00;
            --color-red-dark: #c5221f;
            --color-background: #ffffff;
            --color-on-background: #202124;
            --color-surface: #f8f9fa;
            --color-on-surface: #5f6368;
            --color-primary: var(--color-blue);
            --color-on-primary: #ffffff;
            --color-secondary: var(--color-green);
            --color-on-secondary: #ffffff;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15), 0 5px 10px rgba(0, 0, 0, 0.08);
            --shadow-focus: 0 0 0 3px rgba(66, 133, 244, 0.3);
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --border-radius-lg: 12px;
            --border-radius-xl: 16px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-xxl: 48px;
            --font-family-base: 'Nunito', sans-serif;
            --font-family-heading: 'Fredoka One', cursive;
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
            --z-sidebar: 10;
            --z-modal: 100;
            --z-toast: 110;
        }

        .theme-dark {
            --color-background: #202124;
            --color-on-background: #e8eaed;
            --color-surface: #303134;
            --color-on-surface: #9aa0a6;
            --color-blue: #8ab4f8;
            --color-green: #7bcfa9;
            --color-yellow: #fcd669;
            --color-red: #f28b82;
            --color-blue-light: #a8c7fa;
            --color-green-light: #9ddbc9;
            --color-yellow-light: #fde39c;
            --color-red-light: #f6a5a0;
            --color-blue-dark: #5e97f6;
            --color-green-dark: #5bb974;
            --color-yellow-dark: #fcc93a;
            --color-red-dark: #ee6761;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.15);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.3), 0 5px 10px rgba(0, 0, 0, 0.22);
            --shadow-focus: 0 0 0 3px rgba(138, 180, 248, 0.3);
        }

        /* ===== Base Styles ===== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family-base);
            background-color: var(--color-background);
            color: var(--color-on-background);
            line-height: 1.6;
            overflow-x: hidden;
            transition: background-color var(--transition-normal), color var(--transition-normal);
            position: relative;
            min-height: 100vh;
        }

        /* ===== Enhanced Doodle Background with More Detail ===== */
        .doodle-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .doodle {
            position: absolute;
            opacity: 0.05; /* Subtle in light mode */
        }

        .doodle.circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px dashed var(--color-blue);
            animation: float 25s infinite ease-in-out;
        }

        .doodle.square {
            width: 60px;
            height: 60px;
            border: 2px dotted var(--color-green);
            animation: rotate 35s infinite linear;
        }

        .doodle.triangle {
            width: 0;
            height: 0;
            border-left: 40px solid transparent;
            border-right: 40px solid transparent;
            border-bottom: 70px solid var(--color-yellow);
            opacity: 0.04;
            animation: float 30s infinite ease-in-out reverse;
        }

        .doodle.zigzag {
            width: 100px;
            height: 20px;
            background: repeating-linear-gradient(-45deg,
                transparent,
                transparent 10px,
                var(--color-red) 10px,
                var(--color-red) 20px);
            animation: moveRight 45s infinite linear;
        }

        /* New doodle types for more detail */
        .doodle.star {
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 35px solid var(--color-blue);
            opacity: 0.03;
            animation: twinkle 4s infinite ease-in-out;
        }

        .doodle.blob {
            width: 70px;
            height: 70px;
            border-radius: 50% 40% 60% 30% / 30% 60% 40% 50%;
            background: var(--color-green);
            opacity: 0.04;
            animation: morph 15s infinite ease-in-out;
        }

        /* Enhance doodles in dark mode */
        .theme-dark .doodle {
            opacity: 0.12;
        }

        .theme-dark .doodle.circle {
            border: 2px dashed var(--color-blue);
        }

        .theme-dark .doodle.square {
            border: 2px dotted var(--color-green);
        }

        .theme-dark .doodle.triangle {
            border-bottom: 70px solid var(--color-yellow);
            opacity: 0.08;
        }

        .theme-dark .doodle.zigzag {
            background: repeating-linear-gradient(-45deg,
                transparent,
                transparent 10px,
                var(--color-red) 10px,
                var(--color-red) 20px);
        }

        .theme-dark .doodle.star {
            border-bottom: 35px solid var(--color-blue);
            opacity: 0.1;
        }

        .theme-dark .doodle.blob {
            background: var(--color-green);
            opacity: 0.08;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(15px, 20px) rotate(5deg); }
            50% { transform: translate(0, 40px) rotate(0deg); }
            75% { transform: translate(-15px, 20px) rotate(-5deg); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes moveRight {
            from { transform: translateX(-100px); }
            to { transform: translateX(calc(100vw + 100px)); }
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.03; transform: scale(1); }
            50% { opacity: 0.1; transform: scale(1.1); }
        }

        @keyframes morph {
            0%, 100% { border-radius: 50% 40% 60% 30% / 30% 60% 40% 50%; }
            33% { border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; }
            66% { border-radius: 50% 60% 30% 70% / 40% 50% 60% 30%; }
        }

        /* ===== Buttons ===== */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-md);
            font-family: var(--font-family-base);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            border: none;
            outline: none;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .btn:focus {
            box-shadow: var(--shadow-focus);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: var(--color-on-primary);
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-blue-dark);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: var(--color-surface);
            color: var(--color-on-surface);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .theme-dark .btn-secondary {
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: rgba(0, 0, 0, 0.03);
            box-shadow: var(--shadow-md);
        }

        .theme-dark .btn-secondary:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .icon-button {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: var(--spacing-sm);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color var(--transition-fast);
        }

        .icon-button:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .theme-dark .icon-button:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* ===== Header ===== */
        header {
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: var(--spacing-md) 0;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 var(--spacing-md);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            text-decoration: none;
            color: var(--color-on-surface);
            font-family: var(--font-family-heading);
            font-size: 1.5rem;
            transition: color var(--transition-fast);
        }

        .logo:hover {
            color: var(--color-primary);
        }

        .logo-icon {
            font-size: 2rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        /* ===== Main Layout ===== */
        .game-area {
            display: flex;
            gap: var(--spacing-lg);
            margin-top: var(--spacing-md);
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
            padding: 0 var(--spacing-md);
        }

        /* ===== Sidebar ===== */
        .game-sidebar {
            width: 300px;
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
            padding: var(--spacing-md);
            overflow-y: auto;
            max-height: calc(100vh - 200px);
            transition: transform var(--transition-normal);
            z-index: var(--z-sidebar);
            border: 1px solid rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 100px;
            align-self: flex-start;
        }

        .theme-dark .game-sidebar {
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-sidebar.hidden {
            transform: translateX(-110%);
            position: absolute;
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .theme-dark .sidebar-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-title {
            font-family: var(--font-family-heading);
            font-size: 1.5rem;
            font-weight: 400;
            margin: 0;
            color: var(--color-primary);
        }

        .toggle-sidebar {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            display: none;
        }

        .game-list {
            list-style: none;
        }

        .game-list-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            cursor: pointer;
            transition: background-color var(--transition-fast);
            margin-bottom: var(--spacing-xs);
        }

        .game-list-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .theme-dark .game-list-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .game-list-item.active {
            background-color: rgba(66, 133, 244, 0.15); /* Primary color with opacity */
            font-weight: 600;
        }

        .game-list-icon {
            font-size: 1.5rem;
        }

        .game-list-text {
            flex: 1;
            color: var(--color-on-surface);
        }

        /* ===== Main Content ===== */
        .games-main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-sm);
        }

        .game-tile {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            cursor: pointer;
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .game-tile:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-md);
        }

        .game-tile::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--color-blue) 0%, var(--color-green) 25%, var(--color-yellow) 50%, var(--color-red) 75%, var(--color-blue) 100%);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform var(--transition-normal);
        }

        .game-tile:hover::before {
            transform: scaleX(1);
        }

        .game-icon {
            width: 70px;
            height: 70px;
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            border-radius: var(--border-radius-md);
            background-color: var(--color-primary);
            color: var(--color-on-primary);
            transition: transform var(--transition-normal);
            position: relative;
            box-shadow: var(--shadow-md);
            animation: float-subtle 3s ease-in-out infinite alternate;
        }

        @keyframes float-subtle {
            from { transform: translateY(0px); }
            to { transform: translateY(-5px); }
        }

        .game-tile:hover .game-icon {
            animation: wiggle 0.6s ease;
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }

        .game-title {
            font-family: var(--font-family-heading);
            font-size: 1.25rem;
            font-weight: 400;
            margin-bottom: var(--spacing-xs);
            color: var(--color-on-surface);
        }

        .game-description {
            font-size: 0.875rem;
            color: var(--color-on-surface);
            opacity: 0.7;
            transform: translateY(0);
            transition: transform var(--transition-fast);
        }

        .game-tile:hover .game-description {
            transform: translateY(2px);
        }

        .game-view {
            display: none;
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            height: calc(100vh - 160px);
            flex-direction: column;
            margin-top: var(--spacing-md);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .theme-dark .game-view {
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-view.active {
            display: flex;
        }

        .game-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .theme-dark .game-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-title-bar {
            font-family: var(--font-family-heading);
            font-size: 1.5rem;
            color: var(--color-on-surface);
            margin: 0;
        }

        .game-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* ===== Modals ===== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-modal);
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal), visibility var(--transition-normal);
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background-color: var(--color-background);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(20px);
            transition: transform var(--transition-normal);
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .theme-dark .modal-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            font-family: var(--font-family-heading);
            font-size: 1.5rem;
            margin: 0;
            color: var(--color-on-surface);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color var(--transition-fast);
        }

        .modal-close:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .theme-dark .modal-close:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .modal-body {
            padding: var(--spacing-md);
        }

        .modal-footer {
            padding: var(--spacing-sm) var(--spacing-md);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .theme-dark .modal-footer {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-group label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: 600;
            color: var(--color-on-surface);
        }

        .form-control {
            width: 100%;
            padding: var(--spacing-sm);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius-sm);
            font-family: var(--font-family-base);
            font-size: 1rem;
            background-color: var(--color-surface);
            color: var(--color-on-surface);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }

        .theme-dark .form-control {
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: var(--color-background);
        }

        .form-control:focus {
            border-color: var(--color-primary);
            box-shadow: var(--shadow-focus);
            outline: none;
        }

        /* ===== Toasts ===== */
        .toast-container {
            position: fixed;
            bottom: var(--spacing-lg);
            right: var(--spacing-lg);
            z-index: var(--z-toast);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .toast {
            background-color: var(--color-surface);
            color: var(--color-on-surface);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            transform: translateX(120%);
            transition: transform var(--transition-normal);
            border-left: 4px solid var(--color-primary);
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            margin-left: auto;
            padding: var(--spacing-xs);
            border-radius: var(--border-radius-sm);
            transition: background-color var(--transition-fast);
        }

        .toast-close:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .theme-dark .toast-close:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* ===== Animations ===== */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .fade-in {
            animation: fadeIn var(--transition-normal) ease-in;
        }

        /* ===== Game Specific Styles ===== */

        /* Snake Game */
        .snake-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .snake-canvas-container {
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        .snake-canvas {
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-sm);
            display: block;
            width: 100%;
            height: auto;
            border: 1px solid #b2ebf2;
        }

        .theme-dark .snake-canvas {
            background: linear-gradient(to bottom, #263238, #37474f);
            border: 1px solid #455a64;
        }

        .snake-stats {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        .snake-controls {
            display: flex;
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Tic Tac Toe Game */
        .tictactoe-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 400px;
        }

        .tictactoe-status {
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            min-height: 30px;
        }

        .tictactoe-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: var(--spacing-sm);
            width: 100%;
            max-width: 300px;
        }

        .tictactoe-cell {
            aspect-ratio: 1;
            background-color: var(--color-surface);
            border-radius: var(--border-radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color var(--transition-fast), transform var(--transition-fast);
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .theme-dark .tictactoe-cell {
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .tictactoe-cell:hover:not(.win) {
            background-color: rgba(0, 0, 0, 0.03);
            transform: scale(1.05);
        }

        .theme-dark .tictactoe-cell:hover:not(.win) {
            background-color: rgba(255, 255, 255, 0.08);
        }

        .tictactoe-cell.win {
            background-color: rgba(168, 230, 207, 0.4);
            animation: pulse 0.5s ease-in-out;
        }

        .theme-dark .tictactoe-cell.win {
            background-color: rgba(138, 201, 160, 0.4);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .tictactoe-score {
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            margin: var(--spacing-md) 0;
        }

        .tictactoe-controls {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
            flex-wrap: wrap;
            justify-content: center;
        }

        .tictactoe-mode-selector {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
            margin-bottom: var(--spacing-sm);
            flex-wrap: wrap;
            justify-content: center;
        }

        .tictactoe-mode-selector .btn {
            font-size: 0.8rem;
            padding: var(--spacing-xs) var(--spacing-sm);
        }

        .tictactoe-mode-selector .btn.active {
            background-color: var(--color-primary);
            color: var(--color-on-primary);
        }

        /* Reaction Tester Game */
        .reaction-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .reaction-display {
            width: 100%;
            max-width: 300px;
            height: 150px;
            border-radius: var(--border-radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: background-color var(--transition-fast), transform var(--transition-fast);
            box-shadow: var(--shadow-sm);
            user-select: none;
        }

        .reaction-display:hover {
            transform: scale(1.02);
        }

        .reaction-ready {
            background: linear-gradient(135deg, var(--color-blue), var(--color-green));
            color: var(--color-on-primary);
        }

        .reaction-wait {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            color: var(--color-on-primary);
        }

        .reaction-go {
            background: linear-gradient(135deg, #4caf50, #388e3c);
            color: var(--color-on-primary);
            animation: pulse-bg 1s infinite;
        }

        @keyframes pulse-bg {
            0% { background-size: 100% 100%; }
            50% { background-size: 110% 110%; }
            100% { background-size: 100% 100%; }
        }

        .reaction-result {
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            min-height: 30px;
            color: var(--color-primary);
        }

        .reaction-attempts {
            font-size: 1rem;
            opacity: 0.8;
        }

        /* Whack-a-Doodle Game */
        .whack-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .whack-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: var(--spacing-md);
            width: 100%;
            max-width: 350px;
        }

        .whack-hole {
            aspect-ratio: 1;
            background: radial-gradient(circle, #795548, #5d4037);
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 8px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .whack-doodle {
            position: absolute;
            width: 70%;
            height: 70%;
            background: radial-gradient(circle at 30% 30%, #FFD3B6, #FFAAA5);
            border-radius: 50%;
            bottom: -100%;
            transition: bottom 0.3s ease, transform 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 2px solid #d7ccc8;
        }

        .whack-doodle:hover {
            transform: scale(1.1);
        }

        .whack-doodle.up {
            bottom: 15%;
            animation: peek 0.3s ease-out;
        }

        @keyframes peek {
            0% { bottom: -100%; }
            70% { bottom: 20%; }
            100% { bottom: 15%; }
        }

        .whack-stat {
            display: flex;
            gap: var(--spacing-lg);
            flex-wrap: wrap;
            justify-content: center;
        }

        .whack-stat-item {
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        /* Dice Game */
        .dice-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .dice-container {
            display: flex;
            gap: var(--spacing-md);
            justify-content: center;
            align-items: center;
        }

        .dice {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--color-surface), #f1f3f4);
            border-radius: var(--border-radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: 700;
            box-shadow: var(--shadow-sm);
        }

        .theme-dark .dice {
            background: linear-gradient(135deg, var(--color-surface), #2a2a30);
        }

        .dice-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
            width: 100%;
            max-width: 300px;
        }

        .dice-guess {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            width: 100%;
        }

        .dice-guess input {
            flex: 1;
            padding: var(--spacing-sm);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius-sm);
            font-size: 1rem;
            text-align: center;
            background-color: var(--color-surface);
            color: var(--color-on-surface);
        }

        .theme-dark .dice-guess input {
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: var(--color-background);
        }

        .dice-result {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            min-height: 30px;
            color: var(--color-primary);
        }

        .dice-stats {
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            margin-top: var(--spacing-sm);
        }

        /* Shaikh's Runner Game */
        .runner-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 700px;
        }

        .runner-canvas-container {
            position: relative;
            width: 100%;
            max-width: 600px;
        }

        .runner-canvas {
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-sm);
            display: block;
            width: 100%;
            height: auto;
            border: 1px solid #b2ebf2;
        }

        .theme-dark .runner-canvas {
            background: linear-gradient(to bottom, #263238, #37474f);
            border: 1px solid #455a64;
        }

        .runner-stats {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        .runner-controls {
            display: flex;
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
            justify-content: center;
        }

        /* ===== Responsive Design ===== */
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
            }

            .game-sidebar {
                width: 100%;
                position: relative;
                top: 0;
                max-height: none;
                box-shadow: none;
                border-bottom: 1px solid rgba(0, 0, 0, 0.1);
                border-radius: 0;
                padding: var(--spacing-md) 0;
            }

            .theme-dark .game-sidebar {
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .sidebar-header {
                padding: 0 var(--spacing-md);
            }

            .toggle-sidebar {
                display: block;
            }

            .game-sidebar.hidden {
                transform: none;
                position: relative;
                display: none;
            }

            .games-grid {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            }

            .game-view {
                height: calc(100vh - 180px);
            }
        }

        @media (max-width: 480px) {
            .header-content {
                flex-direction: column;
                gap: var(--spacing-md);
            }

            .games-grid {
                grid-template-columns: 1fr;
            }

            .game-icon {
                width: 60px;
                height: 60px;
                font-size: 1.8rem;
            }

            .game-title {
                font-size: 1.1rem;
            }

            .tictactoe-cell {
                font-size: 2rem;
            }

            .dice {
                width: 70px;
                height: 70px;
                font-size: 2rem;
            }

            .reaction-display {
                height: 120px;
                font-size: 1.2rem;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .doodle-bg {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Doodle Background -->
    <div class="doodle-bg">
        <div class="doodle circle" style="top: 10%; left: 5%;"></div>
        <div class="doodle square" style="top: 20%; right: 7%;"></div>
        <div class="doodle triangle" style="top: 60%; left: 8%;"></div>
        <div class="doodle zigzag" style="top: 40%; left: 15%;"></div>
        <div class="doodle star" style="top: 30%; right: 15%;"></div>
        <div class="doodle blob" style="top: 70%; right: 20%;"></div>
        <div class="doodle circle" style="top: 15%; left: 25%;"></div>
        <div class="doodle square" style="top: 50%; left: 30%;"></div>
        <div class="doodle triangle" style="top: 80%; right: 25%;"></div>
        <div class="doodle zigzag" style="top: 25%; right: 35%;"></div>
        <div class="doodle star" style="top: 65%; left: 20%;"></div>
        <div class="doodle blob" style="top: 45%; right: 40%;"></div>
    </div>

    <!-- Header -->
    <header>
        <div class="header-content">
            <a href="#" class="logo" id="logo">
                <span class="logo-icon">üé™</span>
                <span>Shaikh's Enhanced Arcade</span>
            </a>
            <div class="header-controls">
                <button class="icon-button" id="themeToggle" title="Toggle Theme">‚òÄÔ∏è</button>
                <button class="icon-button" id="soundToggle" title="Toggle Sound">üîä</button>
                <button class="icon-button" id="profileButton" title="Profile">üë§</button>
                <button class="icon-button" id="settingsButton" title="Settings">‚öôÔ∏è</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="game-area">
        <!-- Sidebar -->
        <aside class="game-sidebar" id="gameSidebar">
            <div class="sidebar-header">
                <h2 class="sidebar-title">Games</h2>
                <button class="toggle-sidebar" id="toggleSidebar">‚úï</button>
            </div>
            <ul class="game-list" id="gameList">
                <!-- Game list items will be populated by JavaScript -->
            </ul>
        </aside>

        <!-- Main Content Area -->
        <main class="games-main-content">
            <!-- Games Grid -->
            <div class="games-grid" id="gamesGrid">
                <!-- Game tiles will be populated by JavaScript -->
            </div>

            <!-- Game Views -->
            <div class="game-view" id="snakeView">
                <div class="game-header">
                    <h2 class="game-title-bar">üêç Shaikh's Snake</h2>
                    <button class="icon-button" id="closeSnakeView">‚úï</button>
                </div>
                <div class="game-content" id="snakeContent">
                    <!-- Snake game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="tictactoeView">
                <div class="game-header">
                    <h2 class="game-title-bar">‚≠ï Tic-Tac-Toe</h2>
                    <button class="icon-button" id="closeTicTacToeView">‚úï</button>
                </div>
                <div class="game-content" id="tictactoeContent">
                    <!-- Tic-Tac-Toe game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="reactionView">
                <div class="game-header">
                    <h2 class="game-title-bar">‚è±Ô∏è Reaction Tester</h2>
                    <button class="icon-button" id="closeReactionView">‚úï</button>
                </div>
                <div class="game-content" id="reactionContent">
                    <!-- Reaction Tester game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="whackView">
                <div class="game-header">
                    <h2 class="game-title-bar">üî® Whack-a-Doodle</h2>
                    <button class="icon-button" id="closeWhackView">‚úï</button>
                </div>
                <div class="game-content" id="whackContent">
                    <!-- Whack-a-Doodle game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="diceView">
                <div class="game-header">
                    <h2 class="game-title-bar">üé≤ Dice Guessing</h2>
                    <button class="icon-button" id="closeDiceView">‚úï</button>
                </div>
                <div class="game-content" id="diceContent">
                    <!-- Dice game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="runnerView">
                <div class="game-header">
                    <h2 class="game-title-bar">üèÉ Shaikh's Runner</h2>
                    <button class="icon-button" id="closeRunnerView">‚úï</button>
                </div>
                <div class="game-content" id="runnerContent">
                    <!-- Runner game content will be populated by JavaScript -->
                </div>
            </div>
        </main>
    </div>

    <!-- Profile Modal -->
    <div class="modal-overlay" id="profileModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">üë§ Profile</h3>
                <button class="modal-close" id="closeProfileModal">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <h4>Achievements</h4>
                    <div id="achievementsList">
                        <!-- Achievements will be populated by JavaScript -->
                    </div>
                </div>
                <div class="form-group">
                    <h4>High Scores</h4>
                    <div id="highScoresList">
                        <!-- High scores will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">‚öôÔ∏è Settings</h3>
                <button class="modal-close" id="closeSettingsModal">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="themeSelect">Theme</label>
                    <select class="form-control" id="themeSelect">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="auto">Auto (System)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="volumeSlider">Volume</label>
                    <input type="range" class="form-control" id="volumeSlider" min="0" max="100" value="50">
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="soundToggleSetting"> Sound Enabled
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- Onboarding Modal -->
    <div class="modal-overlay" id="onboardingModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Welcome to Shaikh's Enhanced Arcade!</h3>
                <button class="modal-close" id="closeOnboarding">‚úï</button>
            </div>
            <div class="modal-body">
                <div style="text-align: center; margin-bottom: var(--spacing-xl);">
                    <div style="font-size: 4rem; margin-bottom: var(--spacing-md);">üé™</div>
                    <p>Get ready for a doodle-filled adventure! Play classic games with a fun twist.</p>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="showOnboardingCheckbox"> Show this welcome screen again
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="startPlayingButton">Start Playing!</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer">
        <!-- Toasts will be added here dynamically -->
    </div>

    <script>
        // ===== Utility Functions =====
        const qs = (selector) => document.querySelector(selector);
        const qsa = (selector) => document.querySelectorAll(selector);
        const create = (tag, props = {}) => {
            const el = document.createElement(tag);
            Object.assign(el, props);
            return el;
        };

        // ===== Sound Manager =====
        const SoundManager = {
            context: null,
            sounds: {},
            soundOn: true,
            volume: 0.5,
            
            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API is not supported in this browser');
                }
            },
            
            play(name) {
                if (!this.soundOn || !this.context) return;
                
                let oscillator, gainNode;
                switch (name) {
                    case 'click':
                        oscillator = this.context.createOscillator();
                        gainNode = this.context.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(this.context.destination);
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 523.25; // C5
                        gainNode.gain.value = this.volume;
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.1);
                        break;
                    case 'success':
                        oscillator = this.context.createOscillator();
                        gainNode = this.context.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(this.context.destination);
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(523.25, this.context.currentTime);
                        oscillator.frequency.setValueAtTime(659.25, this.context.currentTime + 0.05); // E5
                        oscillator.frequency.setValueAtTime(783.99, this.context.currentTime + 0.1); // G5
                        gainNode.gain.value = this.volume;
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.3);
                        break;
                    case 'error':
                        oscillator = this.context.createOscillator();
                        gainNode = this.context.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(this.context.destination);
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.value = 220; // A3
                        gainNode.gain.value = this.volume;
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.2);
                        break;
                }
            },
            
            setVolume(value) {
                this.volume = value / 100;
            },
            
            toggleSound() {
                this.soundOn = !this.soundOn;
            }
        };

        // ===== Data Management =====
        const scores = JSON.parse(localStorage.getItem('shaikhArcadeScores')) || {};
        const achievements = JSON.parse(localStorage.getItem('shaikhArcadeAchievements')) || {};
        const settings = JSON.parse(localStorage.getItem('shaikhArcadeSettings')) || {
            theme: 'auto',
            soundOn: true,
            volume: 50,
            showOnboarding: true
        };

        function saveData() {
            localStorage.setItem('shaikhArcadeScores', JSON.stringify(scores));
            localStorage.setItem('shaikhArcadeAchievements', JSON.stringify(achievements));
            localStorage.setItem('shaikhArcadeSettings', JSON.stringify(settings));
        }

        function updateScores(gameId, newScore) {
            if (!scores[gameId]) scores[gameId] = {};
            Object.assign(scores[gameId], newScore);
            saveData();
        }

        function checkAchievement(id, condition, data = {}) {
            if (condition && !achievements[id]) {
                achievements[id] = { ...data, unlockedAt: new Date().toISOString() };
                saveData();
                showToast(`üèÜ Achievement Unlocked: ${id.replace(/_/g, ' ')}`, 'success');
                // Trigger confetti effect
                createConfetti();
                return true;
            }
            return false;
        }

        function loadData() {
            Object.assign(settings, JSON.parse(localStorage.getItem('shaikhArcadeSettings')) || {});
        }

        // ===== Toast System =====
        function showToast(message, type = 'info') {
            const toastContainer = qs('#toastContainer');
            const toast = create('div', { 
                className: 'toast show',
                innerHTML: `
                    <span>${message}</span>
                    <button class="toast-close">&times;</button>
                `
            });
            
            toastContainer.appendChild(toast);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
            
            // Close button
            toast.querySelector('.toast-close').addEventListener('click', () => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            });
        }

        // ===== Confetti Effect =====
        function createConfetti() {
            const container = document.body;
            const colors = ['#4285f4', '#34a853', '#fbbc04', '#ea4335'];
            
            for (let i = 0; i < 100; i++) {
                const confetti = create('div');
                confetti.style.position = 'fixed';
                confetti.style.width = '10px';
                confetti.style.height = '10px';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.borderRadius = '50%';
                confetti.style.left = `${Math.random() * 100}%`;
                confetti.style.top = '-10px';
                confetti.style.zIndex = '1000';
                confetti.style.pointerEvents = 'none';
                
                container.appendChild(confetti);
                
                const animation = confetti.animate([
                    { transform: 'translateY(0) rotate(0deg)', opacity: 1 },
                    { transform: `translateY(${window.innerHeight}px) rotate(${Math.random() * 360}deg)`, opacity: 0 }
                ], {
                    duration: Math.random() * 3000 + 2000,
                    easing: 'cubic-bezier(0,0.9,0.57,1)'
                });
                
                animation.onfinish = () => confetti.remove();
            }
        }

        // ===== Game Definitions =====
        const games = {
            // Snake Game
            snake: {
                id: 'snake',
                title: 'Shaikh\'s Snake',
                description: 'Guide the snake to eat food and grow longer',
                icon: 'üêç',
                init(container) {
                    let canvas, ctx;
                    let gameState = {
                        snake: [{x: 10, y: 10}],
                        food: {x: 5, y: 5},
                        direction: 'right',
                        nextDirection: 'right',
                        score: 0,
                        speed: 150, // ms
                        gridSize: 20,
                        canvasWidth: 400,
                        canvasHeight: 400,
                        paused: false,
                        gameActive: false,
                        lastUpdate: 0,
                        interpolation: 0
                    };
                    
                    let highScore = scores.snake?.highScore || 0;
                    let animationId = null;
                    
                    // Create game elements
                    const gameElement = create('div', { className: 'snake-game' });
                    const canvasContainer = create('div', { className: 'snake-canvas-container' });
                    canvas = create('canvas', { 
                        className: 'snake-canvas',
                        width: gameState.canvasWidth,
                        height: gameState.canvasHeight
                    });
                    ctx = canvas.getContext('2d');
                    canvasContainer.appendChild(canvas);
                    
                    const scoreElement = create('div', { 
                        className: 'snake-stats', 
                        textContent: `Score: ${gameState.score} | High Score: ${highScore}` 
                    });
                    
                    const controlsElement = create('div', { className: 'snake-controls' });
                    const startButton = create('button', { 
                        className: 'btn btn-primary', 
                        textContent: 'Start Game' 
                    });
                    const pauseButton = create('button', { 
                        className: 'btn btn-secondary', 
                        textContent: 'Pause' 
                    });
                    
                    controlsElement.append(startButton, pauseButton);
                    gameElement.append(canvasContainer, scoreElement, controlsElement);
                    container.appendChild(gameElement);
                    
                    // Handle keyboard input
                    const handleKeyDown = (e) => {
                        if (!gameState.gameActive) return;
                        
                        switch(e.key) {
                            case 'ArrowUp':
                                if (gameState.direction !== 'down') gameState.nextDirection = 'up';
                                e.preventDefault();
                                break;
                            case 'ArrowDown':
                                if (gameState.direction !== 'up') gameState.nextDirection = 'down';
                                e.preventDefault();
                                break;
                            case 'ArrowLeft':
                                if (gameState.direction !== 'right') gameState.nextDirection = 'left';
                                e.preventDefault();
                                break;
                            case 'ArrowRight':
                                if (gameState.direction !== 'left') gameState.nextDirection = 'right';
                                e.preventDefault();
                                break;
                        }
                    };
                    
                    document.addEventListener('keydown', handleKeyDown);
                    
                    // Handle touch/swipe input
                    let touchStartX = 0;
                    let touchStartY = 0;
                    
                    canvas.addEventListener('touchstart', (e) => {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        e.preventDefault();
                    }, { passive: false });
                    
                    canvas.addEventListener('touchmove', (e) => {
                        if (!touchStartX || !touchStartY || !gameState.gameActive) return;
                        
                        const touchEndX = e.touches[0].clientX;
                        const touchEndY = e.touches[0].clientY;
                        
                        const diffX = touchStartX - touchEndX;
                        const diffY = touchStartY - touchEndY;
                        
                        // Determine swipe direction
                        if (Math.abs(diffX) > Math.abs(diffY)) {
                            // Horizontal swipe
                            if (diffX > 0 && gameState.direction !== 'right') {
                                gameState.nextDirection = 'left';
                            } else if (diffX < 0 && gameState.direction !== 'left') {
                                gameState.nextDirection = 'right';
                            }
                        } else {
                            // Vertical swipe
                            if (diffY > 0 && gameState.direction !== 'down') {
                                gameState.nextDirection = 'up';
                            } else if (diffY < 0 && gameState.direction !== 'up') {
                                gameState.nextDirection = 'down';
                            }
                        }
                        
                        touchStartX = 0;
                        touchStartY = 0;
                        e.preventDefault();
                    }, { passive: false });
                    
                    // Start game
                    const startGame = () => {
                        if (gameState.gameActive) return;
                        
                        gameState = {
                            snake: [{x: 10, y: 10}],
                            food: generateFood(),
                            direction: 'right',
                            nextDirection: 'right',
                            score: 0,
                            speed: 150,
                            gridSize: 20,
                            canvasWidth: 400,
                            canvasHeight: 400,
                            paused: false,
                            gameActive: true,
                            lastUpdate: 0,
                            interpolation: 0
                        };
                        
                        scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore}`;
                        startButton.textContent = 'Restart Game';
                        gameState.lastUpdate = performance.now();
                        update();
                        SoundManager.play('click');
                    };
                    
                    // Generate food at random position
                    const generateFood = () => {
                        let newFood;
                        let overlapping;
                        do {
                            overlapping = false;
                            newFood = {
                                x: Math.floor(Math.random() * (gameState.canvasWidth / gameState.gridSize)),
                                y: Math.floor(Math.random() * (gameState.canvasHeight / gameState.gridSize))
                            };
                            
                            // Check if food overlaps with snake
                            for (let segment of gameState.snake) {
                                if (segment.x === newFood.x && segment.y === newFood.y) {
                                    overlapping = true;
                                    break;
                                }
                            }
                        } while (overlapping);
                        
                        return newFood;
                    };
                    
                    // Update game state
                    const update = (currentTime = 0) => {
                        if (!gameState.gameActive || gameState.paused) return;
                        
                        animationId = requestAnimationFrame(update);
                        
                        const deltaTime = currentTime - gameState.lastUpdate;
                        gameState.lastUpdate = currentTime;
                        gameState.interpolation += deltaTime;
                        
                        // Update at fixed interval
                        while (gameState.interpolation >= gameState.speed) {
                            gameState.direction = gameState.nextDirection;
                            
                            // Calculate new head position
                            const head = {...gameState.snake[0]};
                            switch (gameState.direction) {
                                case 'up': head.y -= 1; break;
                                case 'down': head.y += 1; break;
                                case 'left': head.x -= 1; break;
                                case 'right': head.x += 1; break;
                            }
                            
                            // Check collision with walls
                            if (
                                head.x < 0 || 
                                head.y < 0 || 
                                head.x >= gameState.canvasWidth / gameState.gridSize || 
                                head.y >= gameState.canvasHeight / gameState.gridSize
                            ) {
                                endGame();
                                return;
                            }
                            
                            // Check collision with self
                            for (let i = 0; i < gameState.snake.length; i++) {
                                if (gameState.snake[i].x === head.x && gameState.snake[i].y === head.y) {
                                    endGame();
                                    return;
                                }
                            }
                            
                            // Add new head
                            gameState.snake.unshift(head);
                            
                            // Check if food is eaten
                            if (head.x === gameState.food.x && head.y === gameState.food.y) {
                                gameState.score += 10;
                                gameState.food = generateFood();
                                SoundManager.play('success');
                                
                                // Increase speed slightly every 50 points
                                if (gameState.score % 50 === 0 && gameState.speed > 50) {
                                    gameState.speed -= 5;
                                }
                                
                                // Check achievements
                                checkAchievement('snake_first_apple', gameState.score >= 10);
                                checkAchievement('snake_100_score', gameState.score >= 100);
                                checkAchievement('snake_200_score', gameState.score >= 200);
                            } else {
                                // Remove tail if no food eaten
                                gameState.snake.pop();
                            }
                            
                            gameState.interpolation -= gameState.speed;
                        }
                        
                        // Draw everything
                        draw();
                    };
                    
                    // Draw game
                    const draw = () => {
                        // Clear canvas
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-background');
                        ctx.fillRect(0, 0, gameState.canvasWidth, gameState.canvasHeight);
                        
                        // Draw grid
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
                        ctx.lineWidth = 0.5;
                        for (let i = 0; i <= gameState.canvasWidth / gameState.gridSize; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * gameState.gridSize, 0);
                            ctx.lineTo(i * gameState.gridSize, gameState.canvasHeight);
                            ctx.stroke();
                        }
                        for (let i = 0; i <= gameState.canvasHeight / gameState.gridSize; i++) {
                            ctx.beginPath();
                            ctx.moveTo(0, i * gameState.gridSize);
                            ctx.lineTo(gameState.canvasWidth, i * gameState.gridSize);
                            ctx.stroke();
                        }
                        
                        // Draw snake
                        gameState.snake.forEach((segment, index) => {
                            ctx.fillStyle = index === 0 ? '#4285f4' : '#8ab4f8'; // Head is darker
                            ctx.fillRect(
                                segment.x * gameState.gridSize, 
                                segment.y * gameState.gridSize, 
                                gameState.gridSize, 
                                gameState.gridSize
                            );
                            
                            // Add rounded corners
                            ctx.strokeStyle = '#1a56db';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(
                                segment.x * gameState.gridSize + 1, 
                                segment.y * gameState.gridSize + 1, 
                                gameState.gridSize - 2, 
                                gameState.gridSize - 2
                            );
                        });
                        
                        // Draw food
                        ctx.fillStyle = '#ea4335';
                        ctx.beginPath();
                        ctx.arc(
                            gameState.food.x * gameState.gridSize + gameState.gridSize/2,
                            gameState.food.y * gameState.gridSize + gameState.gridSize/2,
                            gameState.gridSize/2 - 2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Draw score
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-on-background');
                        ctx.font = '16px sans-serif';
                        ctx.fillText(`Score: ${gameState.score}`, 10, 20);
                    };
                    
                    // End game
                    const endGame = () => {
                        gameState.gameActive = false;
                        if (animationId) {
                            cancelAnimationFrame(animationId);
                        }
                        
                        if (gameState.score > highScore) {
                            highScore = gameState.score;
                            updateScores('snake', { highScore });
                            scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore} üéâ`;
                            showToast(`New High Score: ${highScore}!`, 'success');
                        } else {
                            scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore}`;
                        }
                        
                        SoundManager.play('error');
                    };
                    
                    // Button event listeners
                    startButton.addEventListener('click', startGame);
                    
                    pauseButton.addEventListener('click', () => {
                        if (!gameState.gameActive) return;
                        
                        gameState.paused = !gameState.paused;
                        pauseButton.textContent = gameState.paused ? 'Resume' : 'Pause';
                        
                        if (!gameState.paused) {
                            gameState.lastUpdate = performance.now();
                            update();
                        }
                        SoundManager.play('click');
                    });
                    
                    // Return game methods
                    return {
                        destroy() {
                            document.removeEventListener('keydown', handleKeyDown);
                            if (animationId) {
                                cancelAnimationFrame(animationId);
                            }
                            container.innerHTML = '';
                        },
                        pause() {
                            if (gameState.gameActive && !gameState.paused) {
                                gameState.paused = true;
                                pauseButton.textContent = 'Resume';
                            }
                        },
                        resume() {
                            if (gameState.gameActive && gameState.paused) {
                                gameState.paused = false;
                                pauseButton.textContent = 'Pause';
                                gameState.lastUpdate = performance.now();
                                update();
                            }
                        },
                        restart() {
                            endGame();
                            setTimeout(startGame, 100);
                        }
                    };
                }
            },
            
            // Tic-Tac-Toe Game (Fixed with Minimax AI)
            tictactoe: {
                id: 'tictactoe',
                title: 'Tic-Tac-Toe',
                description: 'Classic X and O game. Play against AI (Minimax) or a friend!',
                icon: '‚≠ï',
                init(container) {
                    let currentPlayer = 'X';
                    let gameBoard = Array(9).fill('');
                    let gameActive = true;
                    let isTwoPlayer = false; // Default to AI mode
                    let playerScore = scores.tictactoe?.playerWins || 0;
                    let aiScore = scores.tictactoe?.aiWins || 0;
                    let draws = scores.tictactoe?.draws || 0;
                    
                    // Create game elements
                    const gameElement = create('div', { className: 'tictactoe-game' });
                    const statusElement = create('div', { 
                        className: 'tictactoe-status', 
                        textContent: isTwoPlayer ? `Player ${currentPlayer}'s turn` : `Player ${currentPlayer}'s turn` 
                    });
                    
                    const modeSelector = create('div', { className: 'tictactoe-mode-selector' });
                    const modeLabel = create('span', { textContent: 'Mode:' });
                    const onePButton = create('button', { 
                        className: 'btn btn-secondary active', 
                        textContent: '1 Player (vs AI)' 
                    });
                    const twoPButton = create('button', { 
                        className: 'btn btn-secondary', 
                        textContent: '2 Players' 
                    });
                    
                    onePButton.addEventListener('click', () => {
                        isTwoPlayer = false;
                        onePButton.classList.add('active');
                        twoPButton.classList.remove('active');
                        restartGame();
                    });
                    
                    twoPButton.addEventListener('click', () => {
                        isTwoPlayer = true;
                        twoPButton.classList.add('active');
                        onePButton.classList.remove('active');
                        restartGame();
                    });
                    
                    modeSelector.append(modeLabel, onePButton, twoPButton);
                    
                    const boardElement = create('div', { className: 'tictactoe-board' });
                    const scoreElement = create('div', { 
                        className: 'tictactoe-score', 
                        textContent: `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}` 
                    });
                    
                    const controlsElement = create('div', { className: 'tictactoe-controls' });
                    const restartButton = create('button', { 
                        className: 'btn btn-primary', 
                        textContent: 'Restart' 
                    });
                    
                    controlsElement.appendChild(restartButton);
                    
                    // Create cells
                    const cells = [];
                    for (let i = 0; i < 9; i++) {
                        const cell = create('div', { 
                            className: 'tictactoe-cell',
                            onclick: () => handleCellClick(i)
                        });
                        cells.push(cell);
                        boardElement.appendChild(cell);
                    }
                    
                    gameElement.append(statusElement, modeSelector, boardElement, scoreElement, controlsElement);
                    container.appendChild(gameElement);
                    
                    // Handle cell click
                    const handleCellClick = (index) => {
                        if (!gameActive || gameBoard[index] !== '') return;
                        
                        // Make player move
                        makeMove(index, currentPlayer);
                        
                        // Check game result
                        const result = checkGameState();
                        if (result) {
                            handleGameEnd(result);
                            return;
                        }
                        
                        // AI move if it's AI's turn
                        if (!isTwoPlayer && gameActive && currentPlayer === 'O') {
                            setTimeout(() => {
                                if (gameActive) {
                                    const aiMove = getBestMove();
                                    makeMove(aiMove, 'O');
                                    
                                    // Check game result after AI move
                                    const aiResult = checkGameState();
                                    if (aiResult) {
                                        handleGameEnd(aiResult);
                                    }
                                }
                            }, 500);
                        }
                    };
                    
                    // Make a move
                    const makeMove = (index, player) => {
                        gameBoard[index] = player;
                        cells[index].textContent = player;
                        
                        // Add animation
                        cells[index].style.transform = 'scale(0)';
                        setTimeout(() => {
                            cells[index].style.transform = 'scale(1)';
                        }, 10);
                        
                        SoundManager.play('click');
                        
                        // Switch player
                        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                        statusElement.textContent = isTwoPlayer ? 
                            `Player ${currentPlayer}'s turn` : 
                            `Player ${currentPlayer === 'X' ? 'X' : 'O (AI)'}'s turn`;
                    };
                    
                    // Check game state (win, draw, or ongoing)
                    const checkGameState = () => {
                        const winPatterns = [
                            [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                            [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                            [0, 4, 8], [2, 4, 6]             // diagonals
                        ];
                        
                        // Check for win
                        for (const pattern of winPatterns) {
                            const [a, b, c] = pattern;
                            if (gameBoard[a] && gameBoard[a] === gameBoard[b] && gameBoard[a] === gameBoard[c]) {
                                return gameBoard[a]; // Return the winning player
                            }
                        }
                        
                        // Check for draw
                        if (!gameBoard.includes('')) {
                            return 'draw';
                        }
                        
                        // Game ongoing
                        return null;
                    };
                    
                    // Handle game end
                    const handleGameEnd = (result) => {
                        gameActive = false;
                        
                        if (result === 'draw') {
                            statusElement.textContent = "It's a draw!";
                            draws++;
                            updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                            checkAchievement('tic_master', draws >= 10, { draws });
                        } else {
                            statusElement.textContent = `Player ${result} wins!`;
                            if (result === 'X') {
                                playerScore++;
                                updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                            } else {
                                if (isTwoPlayer) {
                                    playerScore++; // Player O in 2P mode
                                    updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                                } else {
                                    aiScore++; // AI wins
                                    updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                                }
                            }
                            
                            // Highlight winning cells
                            const winPatterns = [
                                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                                [0, 4, 8], [2, 4, 6]
                            ];
                            
                            for (const pattern of winPatterns) {
                                const [a, b, c] = pattern;
                                if (gameBoard[a] && gameBoard[a] === gameBoard[b] && gameBoard[a] === gameBoard[c]) {
                                    cells[a].classList.add('win');
                                    cells[b].classList.add('win');
                                    cells[c].classList.add('win');
                                    break;
                                }
                            }
                        }
                        
                        scoreElement.textContent = `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}`;
                    };
                    
                    // Minimax algorithm for AI
                    const minimax = (board, depth, isMaximizing) => {
                        const result = checkWinLocal(board);
                        
                        if (result === 'O') return 10 - depth;
                        if (result === 'X') return depth - 10;
                        if (board.every(cell => cell !== '')) return 0;
                        
                        if (isMaximizing) {
                            let bestScore = -Infinity;
                            for (let i = 0; i < 9; i++) {
                                if (board[i] === '') {
                                    board[i] = 'O';
                                    const score = minimax(board, depth + 1, false);
                                    board[i] = '';
                                    bestScore = Math.max(score, bestScore);
                                }
                            }
                            return bestScore;
                        } else {
                            let bestScore = Infinity;
                            for (let i = 0; i < 9; i++) {
                                if (board[i] === '') {
                                    board[i] = 'X';
                                    const score = minimax(board, depth + 1, true);
                                    board[i] = '';
                                    bestScore = Math.min(score, bestScore);
                                }
                            }
                            return bestScore;
                        }
                    };
                    
                    // Check win for local board (used in minimax)
                    const checkWinLocal = (board) => {
                        const winPatterns = [
                            [0, 1, 2], [3, 4, 5], [6, 7, 8],
                            [0, 3, 6], [1, 4, 7], [2, 5, 8],
                            [0, 4, 8], [2, 4, 6]
                        ];
                        
                        for (let pattern of winPatterns) {
                            const [a, b, c] = pattern;
                            if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                                return board[a];
                            }
                        }
                        
                        if (board.every(cell => cell !== '')) {
                            return 'draw';
                        }
                        
                        return null;
                    };
                    
                    // Get best move for AI
                    const getBestMove = () => {
                        let bestScore = -Infinity;
                        let bestMove = null;
                        
                        for (let i = 0; i < 9; i++) {
                            if (gameBoard[i] === '') {
                                gameBoard[i] = 'O';
                                const score = minimax(gameBoard, 0, false);
                                gameBoard[i] = '';
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestMove = i;
                                }
                            }
                        }
                        
                        return bestMove;
                    };
                    
                    // Restart game
                    const restartGame = () => {
                        gameBoard = Array(9).fill('');
                        currentPlayer = 'X';
                        gameActive = true;
                        statusElement.textContent = isTwoPlayer ? 
                            `Player ${currentPlayer}'s turn` : 
                            `Player ${currentPlayer}'s turn`;
                        
                        cells.forEach(cell => {
                            cell.textContent = '';
                            cell.classList.remove('win');
                        });
                        
                        scoreElement.textContent = `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}`;
                        SoundManager.play('click');
                    };
                    
                    restartButton.addEventListener('click', restartGame);
                    
                    return {
                        destroy() {
                            container.innerHTML = '';
                        },
                        pause() {
                            // Pause logic if needed
                        },
                        resume() {
                            // Resume logic if needed
                        },
                        restart: restartGame
                    };
                }
            },
            
            // Reaction Tester Game
            reaction: {
                id: 'reaction',
                title: 'Reaction Tester',
                description: 'Test your reaction speed!',
                icon: '‚è±Ô∏è',
                init(container) {
                    let gameState = 'ready'; // 'ready', 'wait', 'go', 'result'
                    let startTime = 0;
                    let attempts = 0;
                    let bestTime = scores.reaction?.bestTime || null;
                    
                    // Create game elements
                    const gameElement = create('div', { className: 'reaction-game' });
                    const displayElement = create('div', { 
                        className: 'reaction-display reaction-ready',
                        textContent: 'Click or tap when screen turns green!'
                    });
                    const resultElement = create('div', { 
                        className: 'reaction-result',
                        textContent: ' '
                    });
                    const attemptsElement = create('div', { 
                        className: 'reaction-attempts',
                        textContent: `Attempts: ${attempts} | Best: ${bestTime ? bestTime + 'ms' : '--'}`
                    });
                    
                    gameElement.append(displayElement, resultElement, attemptsElement);
                    container.appendChild(gameElement);
                    
                    // Handle display click
                    displayElement.addEventListener('click', () => {
                        if (gameState === 'ready') {
                            // Start waiting phase
                            gameState = 'wait';
                            displayElement.className = 'reaction-display reaction-wait';
                            displayElement.textContent = 'Wait for green...';
                            resultElement.textContent = ' ';
                            
                            // Random delay before green
                            const delay = Math.random() * 3000 + 2000; // 2-5 seconds
                            setTimeout(() => {
                                if (gameState === 'wait') {
                                    gameState = 'go';
                                    displayElement.className = 'reaction-display reaction-go';
                                    displayElement.textContent = 'CLICK NOW!';
                                    startTime = performance.now();
                                }
                            }, delay);
                            
                            SoundManager.play('click');
                        } else if (gameState === 'go') {
                            // Player clicked during green phase
                            const endTime = performance.now();
                            const reactionTime = Math.round(endTime - startTime);
                            
                            gameState = 'result';
                            displayElement.className = 'reaction-display reaction-ready';
                            displayElement.textContent = 'Click or tap when screen turns green!';
                            resultElement.textContent = `Reaction Time: ${reactionTime}ms`;
                            
                            attempts++;
                            if (!bestTime || reactionTime < bestTime) {
                                bestTime = reactionTime;
                                updateScores('reaction', { bestTime });
                                showToast(`New Best Time: ${bestTime}ms!`, 'success');
                            }
                            
                            attemptsElement.textContent = `Attempts: ${attempts} | Best: ${bestTime}ms`;
                            SoundManager.play('success');
                        } else if (gameState === 'wait') {
                            // Player clicked too early
                            gameState = 'result';
                            displayElement.className = 'reaction-display reaction-ready';
                            displayElement.textContent = 'Too early! Click to try again.';
                            resultElement.textContent = 'You clicked too early!';
                            attempts++;
                            attemptsElement.textContent = `Attempts: ${attempts} | Best: ${bestTime ? bestTime + 'ms' : '--'}`;
                            SoundManager.play('error');
                        }
                    });
                    
                    return {
                        destroy() {
                            container.innerHTML = '';
                        },
                        pause() {
                            // Pause logic if needed
                        },
                        resume() {
                            // Resume logic if needed
                        },
                        restart() {
                            gameState = 'ready';
                            displayElement.className = 'reaction-display reaction-ready';
                            displayElement.textContent = 'Click or tap when screen turns green!';
                            resultElement.textContent = ' ';
                            attempts = 0;
                            attemptsElement.textContent = `Attempts: ${attempts} | Best: ${bestTime ? bestTime + 'ms' : '--'}`;
                            SoundManager.play('click');
                        }
                    };
                }
            },
            
            // Whack-a-Doodle Game
            whack: {
                id: 'whack',
                title: 'Whack-a-Doodle',
                description: 'Whack the doodles as they appear',
                icon: 'üî®',
                init(container) {
                    let score = 0;
                    let timeLeft = 30;
                    let gameActive = false;
                    let timerInterval = null;
                    let popInterval = null;
                    let highScore = scores.whack?.highScore || 0;
                    let difficulty = 1000; // ms, decreases as score increases
                    
                    // Create game elements
                    const gameElement = create('div', { className: 'whack-game' });
                    const boardElement = create('div', { className: 'whack-board' });
                    const scoreElement = create('div', { 
                        className: 'whack-stat-item', 
                        textContent: `Score: ${score}` 
                    });
                    const timeElement = create('div', { 
                        className: 'whack-stat-item', 
                        textContent: `Time: ${timeLeft}s` 
                    });
                    const highScoreElement = create('div', { 
                        className: 'whack-stat-item', 
                        textContent: `High Score: ${highScore}` 
                    });
                    
                    const statsElement = create('div', { className: 'whack-stat' });
                    statsElement.append(scoreElement, timeElement, highScoreElement);
                    
                    const startButton = create('button', { 
                        className: 'btn btn-primary', 
                        textContent: 'Start Game' 
                    });
                    
                    // Create holes
                    const holes = [];
                    for (let i = 0; i < 9; i++) {
                        const hole = create('div', { className: 'whack-hole' });
                        const doodle = create('div', { 
                            className: 'whack-doodle', 
                            innerHTML: 'ü§™' 
                        });
                        doodle.addEventListener('click', () => whackDoodle(doodle));
                        hole.appendChild(doodle);
                        boardElement.appendChild(hole);
                        holes.push(hole);
                    }
                    
                    gameElement.append(statsElement, boardElement, startButton);
                    container.appendChild(gameElement);
                    
                    // Start game
                    const startGame = () => {
                        if (gameActive) return;
                        gameActive = true;
                        score = 0;
                        timeLeft = 30;
                        difficulty = 1000;
                        scoreElement.textContent = `Score: ${score}`;
                        timeElement.textContent = `Time: ${timeLeft}s`;
                        startButton.disabled = true;
                        startButton.textContent = 'Game On!';
                        
                        timerInterval = setInterval(() => {
                            timeLeft--;
                            timeElement.textContent = `Time: ${timeLeft}s`;
                            if (timeLeft <= 0) {
                                endGame();
                            }
                        }, 1000);
                        
                        popInterval = setInterval(popDoodle, difficulty);
                        SoundManager.play('click');
                    };
                    
                    // Pop a doodle
                    const popDoodle = () => {
                        if (!gameActive) return;
                        
                        // Hide all doodles first
                        holes.forEach(hole => {
                            const doodle = hole.querySelector('.whack-doodle');
                            doodle.classList.remove('up');
                        });
                        
                        // Then show a random one
                        const randomHole = holes[Math.floor(Math.random() * holes.length)];
                        const doodle = randomHole.querySelector('.whack-doodle');
                        if (!doodle.classList.contains('up')) {
                            doodle.classList.add('up');
                            setTimeout(() => {
                                if (gameActive) {
                                    doodle.classList.remove('up');
                                }
                            }, 600);
                        }
                    };
                    
                    // Whack a doodle
                    const whackDoodle = (doodle) => {
                        if (!gameActive || !doodle.classList.contains('up')) return;
                        score++;
                        scoreElement.textContent = `Score: ${score}`;
                        doodle.classList.remove('up');
                        SoundManager.play('success');
                        
                        // Increase difficulty
                        if (score % 5 === 0 && difficulty > 300) {
                            difficulty -= 50;
                            clearInterval(popInterval);
                            popInterval = setInterval(popDoodle, difficulty);
                        }
                        
                        // Check achievements
                        checkAchievement('whack_streak', score >= 30, { score });
                    };
                    
                    // End game
                    const endGame = () => {
                        gameActive = false;
                        clearInterval(timerInterval);
                        clearInterval(popInterval);
                        startButton.disabled = false;
                        startButton.textContent = 'Start Game';
                        
                        holes.forEach(hole => {
                            const doodle = hole.querySelector('.whack-doodle');
                            doodle.classList.remove('up');
                        });
                        
                        if (score > highScore) {
                            highScore = score;
                            updateScores('whack', { highScore });
                            highScoreElement.textContent = `High Score: ${highScore} üéâ`;
                            showToast(`New High Score: ${highScore}!`, 'success');
                        }
                        
                        SoundManager.play('error');
                    };
                    
                    startButton.addEventListener('click', startGame);
                    
                    return {
                        destroy() {
                            clearInterval(timerInterval);
                            clearInterval(popInterval);
                            container.innerHTML = '';
                        },
                        pause() {
                            if (gameActive) {
                                clearInterval(timerInterval);
                                clearInterval(popInterval);
                            }
                        },
                        resume() {
                            if (gameActive) {
                                timerInterval = setInterval(() => {
                                    timeLeft--;
                                    timeElement.textContent = `Time: ${timeLeft}s`;
                                    if (timeLeft <= 0) {
                                        endGame();
                                    }
                                }, 1000);
                                popInterval = setInterval(popDoodle, difficulty);
                            }
                        },
                        restart() {
                            if (gameActive) {
                                endGame();
                            }
                            setTimeout(startGame, 100);
                        }
                    };
                }
            },
            
            // Dice Game
            dice: {
                id: 'dice',
                title: 'Guess & Dice',
                description: 'Guess numbers and roll dice',
                icon: 'üé≤',
                init(container) {
                    let totalScore = 0;
                    let rolls = 0;
                    let correctGuesses = 0;
                    let consecutiveWins = 0;
                    let bestStreak = scores.dice?.bestStreak || 0;
                    
                    // Create game elements
                    const gameElement = create('div', { className: 'dice-game' });
                    const diceContainer = create('div', { className: 'dice-container' });
                    const dice1 = create('div', { 
                        className: 'dice', 
                        textContent: '?' 
                    });
                    const dice2 = create('div', { 
                        className: 'dice', 
                        textContent: '?' 
                    });
                    diceContainer.append(dice1, dice2);
                    
                    const controlsElement = create('div', { className: 'dice-controls' });
                    const guessElement = create('div', { className: 'dice-guess' });
                    const guessLabel = create('span', { textContent: 'Your guess (2-12):' });
                    const guessInput = create('input', { 
                        type: 'number', 
                        min: '2', 
                        max: '12', 
                        value: '7' 
                    });
                    guessElement.append(guessLabel, guessInput);
                    
                    const rollButton = create('button', { 
                        className: 'btn btn-primary', 
                        textContent: 'Roll Dice' 
                    });
                    
                    const resultElement = create('div', { 
                        className: 'dice-result', 
                        textContent: 'Roll the dice!' 
                    });
                    
                    const statsElement = create('div', { 
                        className: 'dice-stats', 
                        textContent: `Total Score: ${totalScore} | Rolls: ${rolls} | Correct: ${correctGuesses}` 
                    });
                    
                    controlsElement.append(guessElement, rollButton);
                    gameElement.append(diceContainer, controlsElement, resultElement, statsElement);
                    container.appendChild(gameElement);
                    
                    // Roll dice
                    const rollDice = () => {
                        const guess = parseInt(guessInput.value);
                        if (isNaN(guess) || guess < 2 || guess > 12) {
                            resultElement.textContent = 'Please enter a valid guess between 2 and 12';
                            return;
                        }
                        
                        // Rolling animation
                        dice1.textContent = '?';
                        dice2.textContent = '?';
                        resultElement.textContent = 'Rolling...';
                        SoundManager.play('click');
                        
                        setTimeout(() => {
                            const die1 = Math.floor(Math.random() * 6) + 1;
                            const die2 = Math.floor(Math.random() * 6) + 1;
                            const sum = die1 + die2;
                            
                            dice1.textContent = die1;
                            dice2.textContent = die2;
                            
                            rolls++;
                            let roundScore = 0;
                            
                            if (guess === sum) {
                                roundScore = 10;
                                correctGuesses++;
                                consecutiveWins++;
                                resultElement.textContent = `You guessed ${guess} and rolled ${sum}! Correct! +10 points`;
                                SoundManager.play('success');
                                
                                // Check achievements
                                if (consecutiveWins >= 3) {
                                    checkAchievement('dice_three_in_a_row', true);
                                }
                                if (die1 === 6 && die2 === 6) {
                                    checkAchievement('dice_double_six', true);
                                }
                            } else {
                                consecutiveWins = 0;
                                resultElement.textContent = `You guessed ${guess} but rolled ${sum}. Try again!`;
                                SoundManager.play('error');
                            }
                            
                            totalScore += roundScore;
                            
                            if (consecutiveWins > bestStreak) {
                                bestStreak = consecutiveWins;
                                updateScores('dice', { bestStreak });
                            }
                            
                            statsElement.textContent = `Total Score: ${totalScore} | Rolls: ${rolls} | Correct: ${correctGuesses} | Streak: ${consecutiveWins}`;
                            updateScores('dice', { totalScore, rolls, correctGuesses, bestStreak });
                        }, 1000);
                    };
                    
                    rollButton.addEventListener('click', rollDice);
                    
                    return {
                        destroy() {
                            container.innerHTML = '';
                        },
                        pause() {
                            // Pause logic
                        },
                        resume() {
                            // Resume logic
                        },
                        restart() {
                            guessInput.value = '7';
                            dice1.textContent = '?';
                            dice2.textContent = '?';
                            resultElement.textContent = 'Roll the dice!';
                            SoundManager.play('click');
                        }
                    };
                }
            },
            
            // Shaikh's Runner Game
            runner: {
                id: 'runner',
                title: 'Shaikh\'s Runner',
                description: 'Endless runner game',
                icon: 'üèÉ',
                init(container) {
                    let canvas, ctx;
                    const gameState = {
                        player: { x: 50, y: 150, width: 20, height: 40, velocityY: 0, jumping: false },
                        obstacles: [],
                        score: 0,
                        gameSpeed: 5,
                        obstacleSpawnTimer: 0,
                        obstacleSpawnInterval: 1500, // ms
                        gameActive: false,
                        lastTime: 0,
                        animationId: null,
                        jumpForce: -15,
                        gravity: 0.8
                    };
                    
                    let highScore = scores.runner?.highScore || 0;
                    
                    // Create game elements
                    const gameElement = create('div', { className: 'runner-game' });
                    const canvasContainer = create('div', { className: 'runner-canvas-container' });
                    canvas = create('canvas', { 
                        className: 'runner-canvas',
                        width: 600,
                        height: 200
                    });
                    ctx = canvas.getContext('2d');
                    canvasContainer.appendChild(canvas);
                    
                    const scoreElement = create('div', { 
                        className: 'runner-stats', 
                        textContent: `Score: ${gameState.score} | High Score: ${highScore}` 
                    });
                    
                    const controlsElement = create('div', { className: 'runner-controls' });
                    const startButton = create('button', { 
                        className: 'btn btn-primary', 
                        textContent: 'Start Game' 
                    });
                    const jumpButton = create('button', { 
                        className: 'btn btn-secondary', 
                        textContent: 'Jump (Space)' 
                    });
                    
                    controlsElement.append(startButton, jumpButton);
                    gameElement.append(canvasContainer, scoreElement, controlsElement);
                    container.appendChild(gameElement);
                    
                    // Initialize game
                    gameState.init = () => {
                        gameState.reset();
                        gameState.resizeCanvas();
                        window.addEventListener('resize', () => gameState.resizeCanvas());
                        canvas.addEventListener('click', () => gameState.jump());
                        document.addEventListener('keydown', (e) => {
                            if (e.code === 'Space' || e.key === 'ArrowUp') {
                                e.preventDefault();
                                gameState.jump();
                            }
                        });
                    };
                    
                    // Reset game state
                    gameState.reset = () => {
                        gameState.player = { x: 50, y: 150, width: 20, height: 40, velocityY: 0, jumping: false };
                        gameState.obstacles = [];
                        gameState.score = 0;
                        gameState.gameSpeed = 5;
                        gameState.obstacleSpawnTimer = 0;
                        gameState.gameActive = false;
                        scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore}`;
                    };
                    
                    // Resize canvas
                    gameState.resizeCanvas = () => {
                        if (canvas) {
                            canvas.width = canvas.clientWidth;
                            canvas.height = canvas.clientHeight;
                        }
                    };
                    
                    // Jump
                    gameState.jump = () => {
                        if (gameState.gameActive && !gameState.player.jumping) {
                            gameState.player.velocityY = gameState.jumpForce;
                            gameState.player.jumping = true;
                            SoundManager.play('click');
                        }
                    };
                    
                    // Update game state
                    gameState.update = (currentTime = 0) => {
                        if (!gameState.gameActive) return;
                        
                        const deltaTime = currentTime - gameState.lastTime;
                        gameState.lastTime = currentTime;
                        
                        // Clear canvas
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw background
                        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                        if (document.body.classList.contains('theme-dark')) {
                            gradient.addColorStop(0, '#263238');
                            gradient.addColorStop(1, '#37474f');
                        } else {
                            gradient.addColorStop(0, '#87CEEB');
                            gradient.addColorStop(1, '#E0F7FA');
                        }
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Update player
                        gameState.player.velocityY += gameState.gravity;
                        gameState.player.y += gameState.player.velocityY;
                        
                        // Ground collision
                        if (gameState.player.y > 150) {
                            gameState.player.y = 150;
                            gameState.player.velocityY = 0;
                            gameState.player.jumping = false;
                        }
                        
                        // Draw player (doodle character)
                        ctx.fillStyle = '#4285f4';
                        ctx.fillRect(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);
                        // Draw player face
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(gameState.player.x + 15, gameState.player.y + 10, 3, 3); // Eye
                        ctx.fillRect(gameState.player.x + 15, gameState.player.y + 20, 5, 2); // Smile
                        
                        // Update obstacles
                        gameState.obstacleSpawnTimer += deltaTime;
                        if (gameState.obstacleSpawnTimer > gameState.obstacleSpawnInterval) {
                            const height = Math.random() * 30 + 20;
                            gameState.obstacles.push({
                                x: canvas.width,
                                y: 200 - height,
                                width: 20,
                                height: height
                            });
                            gameState.obstacleSpawnTimer = 0;
                            
                            // Increase game speed over time
                            gameState.gameSpeed += 0.01;
                            gameState.obstacleSpawnInterval = Math.max(500, gameState.obstacleSpawnInterval - 1);
                        }
                        
                        // Move and draw obstacles
                        for (let i = gameState.obstacles.length - 1; i >= 0; i--) {
                            const obstacle = gameState.obstacles[i];
                            obstacle.x -= gameState.gameSpeed;
                            
                            // Draw obstacle
                            ctx.fillStyle = '#34a853';
                            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                            
                            // Remove obstacles that are off screen
                            if (obstacle.x + obstacle.width < 0) {
                                gameState.obstacles.splice(i, 1);
                                gameState.score += 1;
                            }
                            
                            // Collision detection
                            if (
                                gameState.player.x < obstacle.x + obstacle.width &&
                                gameState.player.x + gameState.player.width > obstacle.x &&
                                gameState.player.y < obstacle.y + obstacle.height &&
                                gameState.player.y + gameState.player.height > obstacle.y
                            ) {
                                gameState.endGame();
                                return;
                            }
                        }
                        
                        // Draw ground
                        ctx.fillStyle = '#795548';
                        ctx.fillRect(0, 190, canvas.width, 10);
                        
                        // Draw score
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-on-background');
                        ctx.font = '16px sans-serif';
                        ctx.fillText(`Score: ${Math.floor(gameState.score)}`, 10, 20);
                        
                        // Continue animation loop
                        gameState.animationId = requestAnimationFrame((time) => gameState.update(time));
                    };
                    
                    // End game
                    gameState.endGame = () => {
                        gameState.gameActive = false;
                        if (gameState.animationId) {
                            cancelAnimationFrame(gameState.animationId);
                        }
                        
                        const finalScore = Math.floor(gameState.score);
                        if (finalScore > highScore) {
                            highScore = finalScore;
                            updateScores('runner', { highScore });
                            scoreElement.textContent = `Score: ${finalScore} | High Score: ${highScore} üéâ`;
                            showToast(`New High Score: ${highScore}!`, 'success');
                        } else {
                            scoreElement.textContent = `Score: ${finalScore} | High Score: ${highScore}`;
                        }
                        
                        SoundManager.play('error');
                    };
                    
                    // Start game
                    const startGame = () => {
                        if (gameState.gameActive) return;
                        gameState.reset();
                        gameState.gameActive = true;
                        startButton.textContent = 'Restart Game';
                        gameState.lastTime = performance.now();
                        gameState.update();
                        SoundManager.play('click');
                    };
                    
                    // Button event listeners
                    startButton.addEventListener('click', startGame);
                    jumpButton.addEventListener('click', () => gameState.jump());
                    
                    // Initialize the game
                    gameState.init();
                    
                    // Return game methods
                    return {
                        destroy() {
                            gameState.gameActive = false;
                            if (gameState.animationId) {
                                cancelAnimationFrame(gameState.animationId);
                            }
                            window.removeEventListener('resize', gameState.resizeCanvas);
                            document.removeEventListener('keydown', (e) => {
                                if (e.code === 'Space' || e.key === 'ArrowUp') {
                                    e.preventDefault();
                                    gameState.jump();
                                }
                            });
                            container.innerHTML = '';
                        },
                        pause() {
                            if (gameState.gameActive) {
                                gameState.gameActive = false;
                                if (gameState.animationId) {
                                    cancelAnimationFrame(gameState.animationId);
                                }
                            }
                        },
                        resume() {
                            if (!gameState.gameActive) {
                                gameState.gameActive = true;
                                gameState.lastTime = performance.now();
                                gameState.update();
                            }
                        },
                        restart() {
                            gameState.endGame();
                            setTimeout(startGame, 100);
                        }
                    };
                }
            }
        };

        // ===== UI Functions =====
        function renderGamesGrid() {
            const gamesGrid = qs('#gamesGrid');
            gamesGrid.innerHTML = '';
            
            Object.values(games).forEach(game => {
                const gameTile = create('div', { className: 'game-tile' });
                gameTile.innerHTML = `
                    <div class="game-icon">${game.icon}</div>
                    <h3 class="game-title">${game.title}</h3>
                    <p class="game-description">${game.description}</p>
                `;
                gameTile.addEventListener('click', () => {
                    showGameView(game.id);
                    SoundManager.play('click');
                });
                gamesGrid.appendChild(gameTile);
            });
        }

        function renderGameList() {
            const gameList = qs('#gameList');
            gameList.innerHTML = '';
            
            Object.values(games).forEach(game => {
                const listItem = create('li', { className: 'game-list-item' });
                listItem.innerHTML = `
                    <span class="game-list-icon">${game.icon}</span>
                    <span class="game-list-text">${game.title}</span>
                `;
                listItem.addEventListener('click', () => {
                    showGameView(game.id);
                    SoundManager.play('click');
                });
                gameList.appendChild(listItem);
            });
        }

        function showGameView(gameId) {
            // Hide all game views
            qsa('.game-view').forEach(view => view.classList.remove('active'));
            
            // Show the selected game view
            const gameView = qs(`#${gameId}View`);
            if (gameView) {
                gameView.classList.add('active');
                
                // Clear previous game content
                const contentContainer = qs(`#${gameId}Content`);
                if (contentContainer) {
                    contentContainer.innerHTML = '';
                    
                    // Initialize the game
                    const game = games[gameId];
                    if (game && game.init) {
                        const gameMethods = game.init(contentContainer);
                        // Store game methods for later use (pause/resume/destroy)
                        gameView.gameMethods = gameMethods;
                    }
                }
            }
            
            // Hide sidebar on mobile
            if (window.innerWidth <= 768) {
                qs('#gameSidebar').classList.add('hidden');
            }
        }

        function hideGameView() {
            // Hide all game views
            qsa('.game-view').forEach(view => {
                view.classList.remove('active');
                // Destroy the game if it has a destroy method
                if (view.gameMethods && view.gameMethods.destroy) {
                    view.gameMethods.destroy();
                }
                delete view.gameMethods;
            });
        }

        // ===== Event Listeners =====
        qs('#themeToggle').addEventListener('click', () => {
            document.body.classList.toggle('theme-dark');
            const isDark = document.body.classList.contains('theme-dark');
            qs('#themeToggle').textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
            settings.theme = isDark ? 'dark' : 'light';
            saveData();
            SoundManager.play('click');
        });

        qs('#soundToggle').addEventListener('click', () => {
            SoundManager.toggleSound();
            qs('#soundToggle').textContent = SoundManager.soundOn ? 'üîä' : 'üîá';
            settings.soundOn = SoundManager.soundOn;
            saveData();
            SoundManager.play('click');
        });

        qs('#profileButton').addEventListener('click', () => {
            // Populate achievements
            const achievementsList = qs('#achievementsList');
            achievementsList.innerHTML = '';
            let hasAchievements = false;
            
            for (const [id, achievement] of Object.entries(achievements)) {
                hasAchievements = true;
                const achievementEl = create('div', { className: 'achievement-item' });
                achievementEl.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <span style="font-size: 24px; margin-right: 10px;">üèÜ</span>
                        <div>
                            <div style="font-weight: bold;">${id.replace(/_/g, ' ')}</div>
                            <div style="font-size: 0.8rem; opacity: 0.7;">Unlocked: ${new Date(achievement.unlockedAt).toLocaleDateString()}</div>
                        </div>
                    </div>
                `;
                achievementsList.appendChild(achievementEl);
            }
            
            if (!hasAchievements) {
                achievementsList.innerHTML = '<p>No achievements yet. Start playing to unlock some!</p>';
            }
            
            // Populate high scores
            const highScoresList = qs('#highScoresList');
            highScoresList.innerHTML = '';
            let hasScores = false;
            
            for (const [gameId, score] of Object.entries(scores)) {
                hasScores = true;
                const game = games[gameId];
                if (game) {
                    const scoreEl = create('div', { 
                        style: 'margin-bottom: 10px;',
                        innerHTML: `<strong>${game.title}:</strong> ${JSON.stringify(score)}`
                    });
                    highScoresList.appendChild(scoreEl);
                }
            }
            
            if (!hasScores) {
                highScoresList.innerHTML = '<p>No high scores yet. Start playing to set some!</p>';
            }
            
            qs('#profileModal').classList.add('active');
            SoundManager.play('click');
        });

        qs('#settingsButton').addEventListener('click', () => {
            qs('#settingsModal').classList.add('active');
            SoundManager.play('click');
        });

        qs('#closeProfileModal').addEventListener('click', () => {
            qs('#profileModal').classList.remove('active');
            SoundManager.play('click');
        });

        qs('#closeSettingsModal').addEventListener('click', () => {
            qs('#settingsModal').classList.remove('active');
            SoundManager.play('click');
        });

        qs('#closeOnboarding').addEventListener('click', () => {
            qs('#onboardingModal').classList.remove('active');
            settings.showOnboarding = qs('#showOnboardingCheckbox').checked;
            saveData();
            SoundManager.play('click');
        });

        qs('#startPlayingButton').addEventListener('click', () => {
            qs('#onboardingModal').classList.remove('active');
            settings.showOnboarding = qs('#showOnboardingCheckbox').checked;
            saveData();
            SoundManager.play('click');
        });

        // Close modals when clicking outside
        qsa('.modal-overlay').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                    SoundManager.play('click');
                }
            });
        });

        // Close game views
        qsa('[id^="close"][id$="View"]').forEach(button => {
            button.addEventListener('click', () => {
                hideGameView();
                SoundManager.play('click');
            });
        });

        // Toggle sidebar
        qs('#toggleSidebar').addEventListener('click', () => {
            qs('#gameSidebar').classList.toggle('hidden');
            SoundManager.play('click');
        });

        // Theme select
        qs('#themeSelect').addEventListener('change', (e) => {
            const theme = e.target.value;
            settings.theme = theme;
            saveData();
            
            if (theme === 'dark') {
                document.body.classList.add('theme-dark');
                qs('#themeToggle').textContent = 'üåô';
            } else if (theme === 'light') {
                document.body.classList.remove('theme-dark');
                qs('#themeToggle').textContent = '‚òÄÔ∏è';
            } else {
                // Auto theme based on system preference
                const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                if (isDark) {
                    document.body.classList.add('theme-dark');
                    qs('#themeToggle').textContent = 'üåô';
                } else {
                    document.body.classList.remove('theme-dark');
                    qs('#themeToggle').textContent = '‚òÄÔ∏è';
                }
            }
            SoundManager.play('click');
        });

        // Volume slider
        qs('#volumeSlider').addEventListener('input', (e) => {
            const volume = e.target.value;
            SoundManager.setVolume(volume);
            settings.volume = volume;
            saveData();
        });

        // Sound toggle setting
        qs('#soundToggleSetting').addEventListener('change', (e) => {
            SoundManager.soundOn = e.target.checked;
            qs('#soundToggle').textContent = SoundManager.soundOn ? 'üîä' : 'üîá';
            settings.soundOn = SoundManager.soundOn;
            saveData();
        });

        // ===== Initialize =====
        function checkOnboarding() {
            if (settings.showOnboarding) {
                qs('#onboardingModal').classList.add('active');
            }
        }

        function applyTheme() {
            if (settings.theme === 'dark') {
                document.body.classList.add('theme-dark');
                qs('#themeToggle').textContent = 'üåô';
            } else if (settings.theme === 'light') {
                document.body.classList.remove('theme-dark');
                qs('#themeToggle').textContent = '‚òÄÔ∏è';
            } else {
                // Auto theme based on system preference
                const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                if (isDark) {
                    document.body.classList.add('theme-dark');
                    qs('#themeToggle').textContent = 'üåô';
                } else {
                    document.body.classList.remove('theme-dark');
                    qs('#themeToggle').textContent = '‚òÄÔ∏è';
                }
            }
            qs('#themeSelect').value = settings.theme;
        }

        function applySettings() {
            // Sound
            qs('#soundToggle').textContent = settings.soundOn ? 'üîä' : 'üîá';
            qs('#soundToggleSetting').checked = settings.soundOn;
            qs('#volumeSlider').value = settings.volume;
            SoundManager.soundOn = settings.soundOn;
            SoundManager.setVolume(settings.volume);
        }

        function init() {
            SoundManager.init();
            loadData();
            applyTheme();
            applySettings();
            renderGamesGrid();
            renderGameList();
            checkOnboarding();
            
            // Add first game achievement
            checkAchievement('first_game', true);
        }

        // Start the app
        init();
    </script>
</body>
</html>


    
              <script>
                              
              </script>
                        </body>
                        </html>
