<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shaikh's Arcade</title>
  <style>
    /* ====== STYLE ====== */
    :root {
      /* Light Theme Colors */
      --color-background: #FFECD2;
      --color-surface: #FFFFFF;
      --color-primary: #F7D379;
      --color-secondary: #C4D6E7;
      --color-accent: #F9B288;
      --color-text: #333333;
      --color-text-secondary: #666666;
      --color-border: #DCEAF7;
      
      /* Spacing & Sizes */
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
      --border-radius-sm: 4px;
      --border-radius-md: 8px;
      --border-radius-lg: 16px;
      --border-radius-circle: 50%;
      
      /* Shadows */
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
      --shadow-md: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
      --shadow-lg: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
      --shadow-focus: 0 0 0 3px rgba(66, 133, 244, 0.4);
      
      /* Transitions */
      --transition-fast: 0.1s ease;
      --transition-normal: 0.3s ease;
      --transition-slow: 0.5s ease;
      
      /* Z-Index */
      --z-modal: 1000;
      --z-toast: 1100;
    }

    .theme-dark {
      --color-background: #1a1a2e;
      --color-surface: #16213e;
      --color-primary: #0f3460;
      --color-secondary: #e94560;
      --color-accent: #533483;
      --color-text: #f1f1f1;
      --color-text-secondary: #cccccc;
      --color-border: #0f3460;
    }

    .theme-neon {
      --color-background: #0d0d1a;
      --color-surface: #1a1a2e;
      --color-primary: #00ffff; /* Cyan */
      --color-secondary: #ff00ff; /* Magenta */
      --color-accent: #ffff00; /* Yellow */
      --color-text: #ffffff;
      --color-text-secondary: #cccccc;
      --color-border: #33334d;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--color-background);
      color: var(--color-text);
      line-height: 1.5;
      overflow-x: hidden;
      transition: background-color var(--transition-normal);
      position: relative;
      min-height: 100vh;
    }

    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(circle at 10% 20%, rgba(255, 255, 255, 0.05) 0%, transparent 20%),
        radial-gradient(circle at 90% 80%, rgba(255, 255, 255, 0.05) 0%, transparent 20%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 30%);
      pointer-events: none;
      z-index: -1;
    }

    .theme-neon body::before {
      background-image: 
        radial-gradient(circle at 10% 20%, rgba(0, 255, 255, 0.05) 0%, transparent 20%),
        radial-gradient(circle at 90% 80%, rgba(255, 0, 255, 0.05) 0%, transparent 20%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 0, 0.03) 0%, transparent 30%);
    }

    button {
      background: none;
      border: none;
      cursor: pointer;
      font-family: inherit;
      color: inherit;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .app {
      max-width: 1200px;
      margin: 0 auto;
      padding: var(--spacing-md);
    }

    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md) 0;
      margin-bottom: var(--spacing-lg);
    }

    .logo {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .logo-icon {
      font-size: 2rem;
      animation: bounce 2s infinite;
    }

    .logo h1 {
      font-size: 1.75rem;
      font-weight: 700;
      background: linear-gradient(45deg, var(--color-primary), var(--color-secondary));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: hueShift 5s infinite linear;
    }

    .controls {
      display: flex;
      gap: var(--spacing-sm);
    }

    .icon-button {
      width: 44px;
      height: 44px;
      border-radius: var(--border-radius-circle);
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--color-surface);
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-fast);
      position: relative;
      overflow: hidden;
    }

    .icon-button::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, var(--color-primary), var(--color-secondary));
      opacity: 0;
      transition: opacity 0.3s;
      z-index: -1;
    }

    .icon-button:hover::before,
    .icon-button:focus::before {
      opacity: 0.2;
    }

    .icon-button:hover, 
    .icon-button:focus {
      transform: translateY(-3px);
      box-shadow: var(--shadow-md);
    }

    .icon-button:focus {
      outline: none;
      box-shadow: var(--shadow-focus);
    }

    .search-container {
      margin: var(--spacing-lg) auto;
      max-width: 500px;
      width: 100%;
    }

    .search-input {
      width: 100%;
      padding: var(--spacing-md);
      border-radius: var(--border-radius-lg);
      border: 2px solid var(--color-border);
      background-color: var(--color-surface);
      color: var(--color-text);
      font-size: 1rem;
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-fast);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: var(--shadow-focus);
    }

    .games-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: var(--spacing-lg);
      margin-bottom: var(--spacing-xl);
    }

    .game-tile {
      background-color: var(--color-surface);
      border-radius: var(--border-radius-lg);
      padding: var(--spacing-lg);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--spacing-md);
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-normal);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      border: 2px solid transparent;
    }

    .game-tile:hover,
    .game-tile:focus {
      transform: translateY(-5px);
      box-shadow: var(--shadow-lg);
      border-color: var(--color-primary);
    }

    .game-tile::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, var(--color-primary), var(--color-secondary));
      opacity: 0;
      transition: opacity 0.3s;
      z-index: -1;
    }

    .game-tile:hover::before,
    .game-tile:focus::before {
      opacity: 0.1;
    }

    .game-icon {
      font-size: 3rem;
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--border-radius-md);
      background-color: var(--color-primary);
      color: white;
      box-shadow: var(--shadow-sm);
      transition: transform 0.3s ease;
    }

    .game-tile:hover .game-icon {
      transform: scale(1.1) rotate(5deg);
    }

    .game-title {
      font-size: 1.25rem;
      font-weight: 600;
      text-align: center;
    }

    .game-description {
      font-size: 0.9rem;
      color: var(--color-text-secondary);
      text-align: center;
    }

    .game-view {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--color-background);
      z-index: var(--z-modal);
      display: flex;
      flex-direction: column;
      transform: translateY(100%);
      transition: transform var(--transition-normal);
      overflow: hidden;
    }

    .game-view.active {
      transform: translateY(0);
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md);
      background-color: var(--color-surface);
      box-shadow: var(--shadow-sm);
      position: relative;
      z-index: 1;
    }

    .game-title-bar {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .game-title-bar h2 {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .game-actions {
      display: flex;
      gap: var(--spacing-sm);
    }

    .game-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-lg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* Game Specific Styles */
    .snake-canvas {
      background-color: var(--color-surface);
      border-radius: var(--border-radius-md);
      box-shadow: var(--shadow-md);
    }

    .tictactoe-board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-gap: var(--spacing-sm);
      width: 300px;
      height: 300px;
      margin: 0 auto;
    }

    .tictactoe-cell {
      background-color: var(--color-surface);
      border-radius: var(--border-radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      font-weight: bold;
      cursor: pointer;
      transition: all var(--transition-fast);
      box-shadow: var(--shadow-sm);
    }

    .tictactoe-cell:hover {
      background-color: var(--color-primary);
      transform: scale(1.05);
    }

    .memory-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--spacing-sm);
      max-width: 400px;
      margin: 0 auto;
    }

    .memory-card {
      width: 80px;
      height: 80px;
      perspective: 1000px;
      cursor: pointer;
    }

    .memory-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }

    .memory-card.flipped .memory-card-inner {
      transform: rotateY(180deg);
    }

    .memory-card-front, .memory-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: var(--border-radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      box-shadow: var(--shadow-sm);
    }

    .memory-card-front {
      background-color: var(--color-primary);
      color: white;
    }

    .memory-card-back {
      background-color: var(--color-surface);
      color: var(--color-text);
      transform: rotateY(180deg);
    }

    .reaction-box {
      width: 300px;
      height: 300px;
      border-radius: var(--border-radius-lg);
      background-color: var(--color-accent);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.5rem;
      font-weight: bold;
      cursor: pointer;
      box-shadow: var(--shadow-md);
      transition: background-color 0.2s;
    }

    .reaction-box.waiting {
      background-color: #FF9800;
    }

    .reaction-box.ready {
      background-color: #4CAF50;
      animation: pulse 1s infinite;
    }

    .reaction-history {
      display: flex;
      gap: var(--spacing-xs);
      height: 40px;
      align-items: flex-end;
      margin-top: var(--spacing-md);
    }

    .reaction-bar {
      width: 8px;
      background-color: var(--color-primary);
      border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0;
    }

    .whack-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 16px;
      max-width: 400px;
      margin: 0 auto;
    }

    .whack-hole {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background-color: #555;
      position: relative;
      overflow: hidden;
    }

    .whack-mole {
      position: absolute;
      width: 60px;
      height: 60px;
      background-color: var(--color-accent);
      border-radius: 50%;
      bottom: -60px;
      left: 10px;
      transition: bottom 0.3s;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
    }

    .whack-mole.up {
      bottom: 0;
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: var(--z-modal);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-normal);
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background-color: var(--color-surface);
      border-radius: var(--border-radius-lg);
      box-shadow: var(--shadow-lg);
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow: auto;
      transform: scale(0.9) translateY(20px);
      transition: transform var(--transition-normal);
    }

    .modal-overlay.active .modal {
      transform: scale(1) translateY(0);
    }

    .modal-header {
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--color-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
    }

    .modal-close {
      width: 32px;
      height: 32px;
      border-radius: var(--border-radius-circle);
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: transparent;
      transition: background-color var(--transition-fast);
    }

    .modal-close:hover {
      background-color: rgba(0, 0, 0, 0.1);
    }

    .modal-body {
      padding: var(--spacing-md);
    }

    .modal-footer {
      padding: var(--spacing-md);
      border-top: 1px solid var(--color-border);
      display: flex;
      justify-content: flex-end;
      gap: var(--spacing-sm);
    }

    /* Form Elements */
    .form-group {
      margin-bottom: var(--spacing-md);
    }

    .form-label {
      display: block;
      margin-bottom: var(--spacing-xs);
      font-weight: 500;
    }

    .form-control {
      width: 100%;
    }

    select, input[type="range"] {
      width: 100%;
      padding: var(--spacing-sm);
      border-radius: var(--border-radius-md);
      border: 1px solid var(--color-border);
      background-color: var(--color-surface);
      color: var(--color-text);
      font-size: 1rem;
    }

    input[type="checkbox"] {
      margin-right: var(--spacing-sm);
    }

    /* Buttons */
    .btn {
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--border-radius-md);
      font-weight: 500;
      transition: all var(--transition-fast);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-xs);
    }

    .btn:focus {
      outline: none;
      box-shadow: var(--shadow-focus);
    }

    .btn-primary {
      background-color: var(--color-primary);
      color: white;
    }

    .btn-primary:hover {
      background-color: #e6c260;
      transform: translateY(-2px);
    }

    .btn-secondary {
      background-color: var(--color-surface);
      color: var(--color-text);
      border: 1px solid var(--color-border);
    }

    .btn-secondary:hover {
      background-color: rgba(0, 0, 0, 0.05);
      transform: translateY(-2px);
    }

    /* Toast */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: var(--z-toast);
    }

    .toast {
      background-color: var(--color-surface);
      color: var(--color-text);
      padding: var(--spacing-md);
      border-radius: var(--border-radius-md);
      box-shadow: var(--shadow-lg);
      margin-bottom: var(--spacing-sm);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      max-width: 300px;
    }

    .toast.show {
      transform: translateX(0);
    }

    .toast-success {
      border-left: 4px solid #4CAF50;
    }

    /* Animations */
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-10px);
      }
      60% {
        transform: translateY(-5px);
      }
    }

    @keyframes hueShift {
      0% {
        filter: hue-rotate(0deg);
      }
      100% {
        filter: hue-rotate(360deg);
      }
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }

    @keyframes wiggle {
      0%, 100% {
        transform: rotate(-3deg);
      }
      50% {
        transform: rotate(3deg);
      }
    }

    .game-tile:hover {
      animation: wiggle 0.5s ease;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .games-grid {
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      }
      
      .tictactoe-board {
        width: 250px;
        height: 250px;
      }
      
      .memory-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      
      .memory-card {
        width: 70px;
        height: 70px;
      }
    }

    @media (max-width: 480px) {
      .app-header {
        flex-direction: column;
        gap: var(--spacing-md);
      }
      
      .games-grid {
        grid-template-columns: 1fr;
      }
      
      .tictactoe-board {
        width: 200px;
        height: 200px;
      }
      
      .memory-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      
      .memory-card {
        width: 60px;
        height: 60px;
      }
      
      .reaction-box {
        width: 200px;
        height: 200px;
      }
    }

    /* Confetti */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #f00;
      opacity: 0.8;
      z-index: 9999;
    }

    /* Doodle Background Elements */
    .doodle-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
      overflow: hidden;
    }

    .doodle-element {
      position: absolute;
      opacity: 0.1;
      animation: float 15s infinite ease-in-out;
    }

    @keyframes float {
      0%, 100% {
        transform: translate(0, 0) rotate(0deg);
      }
      25% {
        transform: translate(10px, 15px) rotate(5deg);
      }
      50% {
        transform: translate(20px, 5px) rotate(-5deg);
      }
      75% {
        transform: translate(5px, 20px) rotate(3deg);
      }
    }
  </style>
</head>
<body>
  <!-- ====== TEMPLATE ====== -->
  <div class="doodle-bg" id="doodleBg"></div>
  
  <div class="app">
    <header class="app-header">
      <div class="logo">
        <div class="logo-icon" id="logoIcon">üéÆ</div>
        <h1>Shaikh's Arcade</h1>
      </div>
      <div class="controls">
        <button class="icon-button" id="soundToggle" aria-label="Toggle sound">
          <span class="sound-icon">üîä</span>
        </button>
        <button class="icon-button" id="themeToggle" aria-label="Toggle theme">
          <span class="theme-icon">üåô</span>
        </button>
        <button class="icon-button" id="settingsButton" aria-label="Open settings">
          <span class="settings-icon">‚öôÔ∏è</span>
        </button>
        <button class="icon-button" id="profileButton" aria-label="Open profile">
          <span class="profile-icon">üë§</span>
        </button>
      </div>
    </header>

    <div class="search-container">
      <input type="text" class="search-input" id="gameSearch" placeholder="Search games...">
    </div>

    <div class="games-grid" id="gamesGrid"></div>
  </div>

  <!-- Game View -->
  <div class="game-view" id="gameView">
    <div class="game-header">
      <div class="game-title-bar">
        <button class="icon-button" id="backButton" aria-label="Back to menu">
          <span>‚Üê</span>
        </button>
        <h2 id="currentGameTitle">Game Title</h2>
      </div>
      <div class="game-actions">
        <button class="icon-button" id="gameInfo" aria-label="Game info">
          <span>‚ÑπÔ∏è</span>
        </button>
        <button class="icon-button" id="gameRestart" aria-label="Restart game">
          <span>üîÑ</span>
        </button>
        <button class="icon-button" id="gamePause" aria-label="Pause game">
          <span>‚è∏Ô∏è</span>
        </button>
      </div>
    </div>
    <div class="game-content" id="gameContent"></div>
  </div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Settings</h3>
        <button class="modal-close" id="closeSettings">‚úï</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label class="form-label" for="soundToggleSetting">Sound</label>
          <div class="form-control">
            <label>
              <input type="checkbox" id="soundToggleSetting"> Enable sound
            </label>
          </div>
        </div>
        <div class="form-group">
          <label class="form-label" for="volumeSlider">Volume</label>
          <input type="range" id="volumeSlider" min="0" max="1" step="0.1" class="form-control">
        </div>
        <div class="form-group">
          <label class="form-label" for="themeSelect">Theme</label>
          <select id="themeSelect" class="form-control">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="neon">Neon</option>
            <option value="auto">Auto (system)</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label" for="onboardingToggle">Show onboarding</label>
          <div class="form-control">
            <label>
              <input type="checkbox" id="onboardingToggle"> Show onboarding on startup
            </label>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="resetProgress">Reset Progress</button>
        <button class="btn btn-primary" id="saveSettings">Save</button>
      </div>
    </div>
  </div>

  <!-- Profile Modal -->
  <div class="modal-overlay" id="profileModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Profile</h3>
        <button class="modal-close" id="closeProfile">‚úï</button>
      </div>
      <div class="modal-body">
        <h4>Achievements</h4>
        <div id="achievementsList">No achievements yet</div>
        <h4 style="margin-top: 20px;">High Scores</h4>
        <div id="scoresList">No scores yet</div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="closeProfileBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Onboarding Modal -->
  <div class="modal-overlay" id="onboardingModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Welcome to Shaikh's Arcade!</h3>
        <button class="modal-close" id="closeOnboarding">‚úï</button>
      </div>
      <div class="modal-body">
        <p>Explore a collection of fun mini-games. Test your skills and earn achievements!</p>
        <p>Use the settings to customize your experience.</p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-primary" id="startPlaying">Start Playing</button>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>

  <script>
    /* ====== SCRIPTS ====== */
    (function() {
      // DOM Helpers
      const qs = (selector) => document.querySelector(selector);
      const qsa = (selector) => document.querySelectorAll(selector);
      const create = (tag, props = {}, children = []) => {
        const el = document.createElement(tag);
        Object.assign(el, props);
        if (props.className) el.className = props.className;
        if (props.style) el.style = props.style;
        children.forEach(child => {
          if (typeof child === 'string') {
            el.innerHTML += child;
          } else {
            el.appendChild(child);
          }
        });
        return el;
      };

      // App state
      let activeGame = null;
      let gamesRegistry = {};
      let settings = {
        soundOn: true,
        volume: 0.5,
        theme: 'light',
        showOnboarding: true
      };
      let scores = {};
      let achievements = {};

      // DOM elements
      const gamesGrid = qs('#gamesGrid');
      const gameView = qs('#gameView');
      const gameContent = qs('#gameContent');
      const currentGameTitle = qs('#currentGameTitle');
      const gameSearch = qs('#gameSearch');
      const backButton = qs('#backButton');
      const soundToggle = qs('#soundToggle');
      const themeToggle = qs('#themeToggle');
      const settingsButton = qs('#settingsButton');
      const profileButton = qs('#profileButton');
      const gamePause = qs('#gamePause');
      const gameRestart = qs('#gameRestart');
      const gameInfo = qs('#gameInfo');
      const logoIcon = qs('#logoIcon');

      // Modals
      const settingsModal = qs('#settingsModal');
      const profileModal = qs('#profileModal');
      const onboardingModal = qs('#onboardingModal');
      const closeSettings = qs('#closeSettings');
      const closeProfile = qs('#closeProfile');
      const closeOnboarding = qs('#closeOnboarding');
      const soundToggleSetting = qs('#soundToggleSetting');
      const volumeSlider = qs('#volumeSlider');
      const themeSelect = qs('#themeSelect');
      const onboardingToggle = qs('#onboardingToggle');
      const resetProgressBtn = qs('#resetProgress');
      const saveSettingsBtn = qs('#saveSettings');
      const startPlayingBtn = qs('#startPlaying');
      const closeProfileBtn = qs('#closeProfileBtn');

      // Toast container
      const toastContainer = qs('#toastContainer');
      const doodleBg = qs('#doodleBg');

      // Sound Manager
      const SoundManager = {
        audioContext: null,
        enabled: false,
        init() {
          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.enabled = true;
          } catch (e) {
            console.warn('Web Audio API is not supported in this browser');
            this.enabled = false;
          }
        },
        setVolume(volume) {
          // In a real implementation, we would use a gain node
        },
        play(kind) {
          if (!this.enabled || !this.audioContext || !settings.soundOn) return;
          
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          
          let frequency = 440;
          let duration = 0.1;
          
          switch (kind) {
            case 'click':
              frequency = 523.25;
              break;
            case 'success':
              frequency = 783.99;
              break;
            case 'error':
              frequency = 349.23;
              break;
          }
          
          oscillator.frequency.value = frequency;
          gainNode.gain.value = settings.volume;
          
          oscillator.start();
          setTimeout(() => {
            oscillator.stop();
          }, duration * 1000);
        },
        toggle() {
          this.enabled = !this.enabled;
          return this.enabled;
        }
      };

      // Toast system
      const Toast = {
        container: toastContainer,
        show(message, type = 'info', duration = 3000) {
          const toast = create('div', {
            className: `toast toast-${type}`,
            innerHTML: `<span>${message}</span>`
          });
          
          this.container.appendChild(toast);
          
          // Trigger reflow
          toast.offsetHeight;
          toast.classList.add('show');
          
          setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
              if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
              }
            }, 300);
          }, duration);
        }
      };

      // Confetti effect
      const Confetti = {
        create(x, y, color) {
          const confetti = create('div', {
            className: 'confetti',
            style: `background-color: ${color}; left: ${x}px; top: ${y}px;`
          });
          
          document.body.appendChild(confetti);
          
          const angle = Math.random() * Math.PI * 2;
          const velocity = 2 + Math.random() * 2;
          const spin = Math.random() * 10 - 5;
          let posX = x;
          let posY = y;
          let rotation = 0;
          
          const animate = () => {
            posX += Math.cos(angle) * velocity;
            posY += Math.sin(angle) * velocity + 0.1; // gravity
            rotation += spin;
            
            confetti.style.left = `${posX}px`;
            confetti.style.top = `${posY}px`;
            confetti.style.transform = `rotate(${rotation}deg)`;
            
            if (posY < window.innerHeight) {
              requestAnimationFrame(animate);
            } else {
              confetti.parentNode.removeChild(confetti);
            }
          };
          
          animate();
        },
        burst(x, y, count = 20) {
          const colors = ['#4285F4', '#34A853', '#EA4335', '#FBBC05', '#9C27B0', '#FF9800'];
          
          for (let i = 0; i < count; i++) {
            setTimeout(() => {
              this.create(x, y, colors[Math.floor(Math.random() * colors.length)]);
            }, i * 30);
          }
        }
      };

      // Ripple effect
      const addRippleEffect = (element) => {
        element.addEventListener('click', function(e) {
          const rect = this.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          const ripple = create('span', {
            className: 'ripple',
            style: `top: ${y}px; left: ${x}px;`
          });
          
          this.appendChild(ripple);
          
          setTimeout(() => {
            ripple.remove();
          }, 600);
        });
      };

      // LocalStorage management
      const Storage = {
        get(key) {
          try {
            const item = localStorage.getItem(`shaikhArcade.${key}`);
            return item ? JSON.parse(item) : null;
          } catch (e) {
            console.error('Error reading from localStorage', e);
            return null;
          }
        },
        set(key, value) {
          try {
            localStorage.setItem(`shaikhArcade.${key}`, JSON.stringify(value));
          } catch (e) {
            console.error('Error writing to localStorage', e);
          }
        },
        remove(key) {
          try {
            localStorage.removeItem(`shaikhArcade.${key}`);
          } catch (e) {
            console.error('Error removing from localStorage', e);
          }
        }
      };

      // Load data
      function loadData() {
        const savedSettings = Storage.get('settings');
        if (savedSettings) {
          settings = { ...settings, ...savedSettings };
        }
        
        const savedScores = Storage.get('scores');
        if (savedScores) {
          scores = savedScores;
        }
        
        const savedAchievements = Storage.get('achievements');
        if (savedAchievements) {
          achievements = savedAchievements;
        }
      }

      // Save data
      function saveData() {
        Storage.set('settings', settings);
        Storage.set('scores', scores);
        Storage.set('achievements', achievements);
      }

      // Apply settings to UI
      function applySettings() {
        // Apply theme
        document.body.className = '';
        if (settings.theme === 'dark') {
          document.body.classList.add('theme-dark');
          themeToggle.querySelector('.theme-icon').textContent = '‚òÄÔ∏è';
        } else if (settings.theme === 'neon') {
          document.body.classList.add('theme-neon');
          themeToggle.querySelector('.theme-icon').textContent = '‚òÄÔ∏è';
        } else if (settings.theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.body.classList.add('theme-dark');
          themeToggle.querySelector('.theme-icon').textContent = '‚òÄÔ∏è';
        } else {
          themeToggle.querySelector('.theme-icon').textContent = 'üåô';
        }
        
        // Apply sound settings
        soundToggle.querySelector('.sound-icon').textContent = settings.soundOn ? 'üîä' : 'üîá';
        SoundManager.setVolume(settings.volume);
        
        // Update settings modal
        soundToggleSetting.checked = settings.soundOn;
        volumeSlider.value = settings.volume;
        themeSelect.value = settings.theme;
        onboardingToggle.checked = settings.showOnboarding;
      }

      // Show onboarding if needed
      function checkOnboarding() {
        if (settings.showOnboarding) {
          onboardingModal.classList.add('active');
        }
      }

      // Create doodle background elements
      function createDoodleBackground() {
        doodleBg.innerHTML = '';
        const doodles = ['üéÆ', 'üïπÔ∏è', 'üëæ', 'üéØ', 'üé≤', 'üé™', 'üé®', 'üé≠', 'üé™', 'üé®'];
        
        for (let i = 0; i < 20; i++) {
          const doodle = create('div', {
            className: 'doodle-element',
            innerHTML: doodles[Math.floor(Math.random() * doodles.length)],
            style: `
              left: ${Math.random() * 100}%;
              top: ${Math.random() * 100}%;
              font-size: ${20 + Math.random() * 30}px;
              animation-delay: ${Math.random() * 5}s;
              animation-duration: ${10 + Math.random() * 20}s;
            `
          });
          
          doodleBg.appendChild(doodle);
        }
      }

      // Game modules
      const GameModules = {
        // Smooth Snake game
        snake: {
          id: 'snake',
          title: 'Smooth Snake',
          description: 'Guide the snake to eat food and grow longer',
          icon: 'üêç',
          init(container) {
            const canvas = create('canvas', {
              className: 'snake-canvas',
              width: 400,
              height: 400
            });
            
            const ctx = canvas.getContext('2d');
            
            const gameState = {
              snake: [{x: 10, y: 10}],
              food: {x: 5, y: 5},
              direction: 'right',
              score: 0,
              gameSpeed: 150,
              gameRunning: true,
              lastRenderTime: 0
            };
            
            function placeFood() {
              let newFood;
              let overlapping;
              
              do {
                newFood = {
                  x: Math.floor(Math.random() * (canvas.width / 20)),
                  y: Math.floor(Math.random() * (canvas.height / 20))
                };
                
                overlapping = false;
                for (const segment of gameState.snake) {
                  if (segment.x === newFood.x && segment.y === newFood.y) {
                    overlapping = true;
                    break;
                  }
                }
              } while (overlapping);
              
              gameState.food = newFood;
            }
            
            function draw() {
              // Clear canvas
              ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-background');
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              
              // Draw snake
              gameState.snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#4CAF50' : '#8BC34A';
                ctx.fillRect(segment.x * 20, segment.y * 20, 20, 20);
                
                // Add rounded corners
                ctx.strokeStyle = '#388E3C';
                ctx.lineWidth = 2;
                ctx.strokeRect(segment.x * 20, segment.y * 20, 20, 20);
              });
              
              // Draw food
              ctx.fillStyle = '#F44336';
              ctx.beginPath();
              ctx.arc(
                gameState.food.x * 20 + 10,
                gameState.food.y * 20 + 10,
                10,
                0,
                Math.PI * 2
              );
              ctx.fill();
            }
            
            function update() {
              if (!gameState.gameRunning) return;
              
              // Move snake
              const head = {x: gameState.snake[0].x, y: gameState.snake[0].y};
              
              switch (gameState.direction) {
                case 'up':
                  head.y -= 1;
                  break;
                case 'down':
                  head.y += 1;
                  break;
                case 'left':
                  head.x -= 1;
                  break;
                case 'right':
                  head.x += 1;
                  break;
              }
              
              // Check collision with walls
              if (
                head.x < 0 || 
                head.y < 0 || 
                head.x >= canvas.width / 20 || 
                head.y >= canvas.height / 20
              ) {
                gameState.gameRunning = false;
                Toast.show('Game Over! Snake hit the wall.', 'error');
                return;
              }
              
              // Check collision with self
              for (let i = 0; i < gameState.snake.length; i++) {
                if (gameState.snake[i].x === head.x && gameState.snake[i].y === head.y) {
                  gameState.gameRunning = false;
                  Toast.show('Game Over! Snake hit itself.', 'error');
                  return;
                }
              }
              
              gameState.snake.unshift(head);
              
              // Check if food is eaten
              if (head.x === gameState.food.x && head.y === gameState.food.y) {
                gameState.score += 10;
                placeFood();
                
                // Increase speed slightly
                if (gameState.gameSpeed > 50) {
                  gameState.gameSpeed -= 2;
                }
                
                // Show confetti for every 50 points
                if (gameState.score % 50 === 0) {
                  Confetti.burst(canvas.width/2, canvas.height/2);
                }
              } else {
                gameState.snake.pop();
              }
              
              draw();
            }
            
            function gameLoop(timestamp) {
              if (!gameState.gameRunning) return;
              
              const secondsSinceLastRender = (timestamp - gameState.lastRenderTime) / 1000;
              if (secondsSinceLastRender < 1 / (1000 / gameState.gameSpeed)) {
                requestAnimationFrame(gameLoop);
                return;
              }
              
              gameState.lastRenderTime = timestamp;
              update();
              requestAnimationFrame(gameLoop);
            }
            
            // Handle keyboard input
            function handleKeydown(e) {
              switch (e.key) {
                case 'ArrowUp':
                  if (gameState.direction !== 'down') gameState.direction = 'up';
                  break;
                case 'ArrowDown':
                  if (gameState.direction !== 'up') gameState.direction = 'down';
                  break;
                case 'ArrowLeft':
                  if (gameState.direction !== 'right') gameState.direction = 'left';
                  break;
                case 'ArrowRight':
                  if (gameState.direction !== 'left') gameState.direction = 'right';
                  break;
              }
            }
            
            // Initialize game
            placeFood();
            draw();
            requestAnimationFrame(gameLoop);
            document.addEventListener('keydown', handleKeydown);
            
            container.appendChild(canvas);
            
            // Return game API
            return {
              destroy() {
                document.removeEventListener('keydown', handleKeydown);
                container.innerHTML = '';
              },
              pause() {
                gameState.gameRunning = false;
              },
              resume() {
                if (!gameState.gameRunning) {
                  gameState.gameRunning = true;
                  requestAnimationFrame(gameLoop);
                }
              },
              restart() {
                gameState.snake = [{x: 10, y: 10}];
                gameState.direction = 'right';
                gameState.score = 0;
                gameState.gameSpeed = 150;
                gameState.gameRunning = true;
                placeFood();
                draw();
                requestAnimationFrame(gameLoop);
              }
            };
          }
        },
        
        // Tic-Tac-Toe game
        tictactoe: {
          id: 'tictactoe',
          title: 'Tic-Tac-Toe',
          description: 'Classic game of X\'s and O\'s',
          icon: '‚ùå',
          init(container) {
            const gameState = {
              board: Array(9).fill(null),
              currentPlayer: 'X',
              gameActive: true,
              mode: 'pvp' // pvp or ai
            };
            
            const boardElement = create('div', { className: 'tictactoe-board' });
            
            function checkWinner() {
              const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                [0, 4, 8], [2, 4, 6]             // diagonals
              ];
              
              for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (gameState.board[a] && 
                    gameState.board[a] === gameState.board[b] && 
                    gameState.board[a] === gameState.board[c]) {
                  return gameState.board[a];
                }
              }
              
              return gameState.board.includes(null) ? null : 'T'; // Tie
            }
            
            function makeMove(index) {
              if (!gameState.gameActive || gameState.board[index]) return;
              
              gameState.board[index] = gameState.currentPlayer;
              updateBoard();
              
              const winner = checkWinner();
              if (winner) {
                gameState.gameActive = false;
                if (winner === 'T') {
                  Toast.show("It's a tie!", 'info');
                } else {
                  Toast.show(`Player ${winner} wins!`, 'success');
                  if (winner === 'X') {
                    unlockAchievement('tic_master');
                  }
                }
                return;
              }
              
              // Switch player
              gameState.currentPlayer = gameState.currentPlayer === 'X' ? 'O' : 'X';
            }
            
            function updateBoard() {
              boardElement.innerHTML = '';
              gameState.board.forEach((cell, index) => {
                const cellElement = create('div', {
                  className: 'tictactoe-cell',
                  innerHTML: cell || '',
                  onclick: () => makeMove(index)
                });
                boardElement.appendChild(cellElement);
              });
            }
            
            function restartGame() {
              gameState.board = Array(9).fill(null);
              gameState.currentPlayer = 'X';
              gameState.gameActive = true;
              updateBoard();
            }
            
            // Initialize game
            updateBoard();
            container.appendChild(boardElement);
            
            // Return game API
            return {
              destroy() {
                container.innerHTML = '';
              },
              pause() {
                // Not pausable
              },
              resume() {
                // Not pausable
              },
              restart() {
                restartGame();
              }
            };
          }
        },
        
        // Memory Match game
        memory: {
          id: 'memory',
          title: 'Memory Match',
          description: 'Find matching pairs of cards',
          icon: 'üß†',
          init(container) {
            const gameState = {
              cards: [],
              flippedCards: [],
              matchedPairs: 0,
              moves: 0,
              gameActive: true
            };
            
            const symbols = ['üçé', 'üçå', 'üçá', 'üçä', 'üçì', 'üçí', 'üçë', 'üçç'];
            const cardValues = [...symbols, ...symbols];
            
            function shuffleArray(array) {
              for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
              }
              return array;
            }
            
            function createCards() {
              const shuffledCards = shuffleArray([...cardValues]);
              gameState.cards = shuffledCards.map((value, index) => ({
                id: index,
                value: value,
                flipped: false,
                matched: false
              }));
            }
            
            function flipCard(card) {
              if (!gameState.gameActive || card.flipped || card.matched || gameState.flippedCards.length === 2) {
                return;
              }
              
              card.flipped = true;
              gameState.flippedCards.push(card);
              renderBoard();
              
              if (gameState.flippedCards.length === 2) {
                gameState.moves++;
                setTimeout(checkMatch, 500);
              }
            }
            
            function checkMatch() {
              const [card1, card2] = gameState.flippedCards;
              
              if (card1.value === card2.value) {
                card1.matched = true;
                card2.matched = true;
                gameState.matchedPairs++;
                
                if (gameState.matchedPairs === symbols.length) {
                  gameState.gameActive = false;
                  Toast.show(`You won in ${gameState.moves} moves!`, 'success');
                  unlockAchievement('memory_champ');
                }
              } else {
                card1.flipped = false;
                card2.flipped = false;
              }
              
              gameState.flippedCards = [];
              renderBoard();
            }
            
            function renderBoard() {
              boardElement.innerHTML = '';
              gameState.cards.forEach(card => {
                const cardElement = create('div', {
                  className: `memory-card ${card.flipped || card.matched ? 'flipped' : ''}`,
                  onclick: () => flipCard(card)
                });
                
                const cardInner = create('div', { className: 'memory-card-inner' });
                const cardFront = create('div', { 
                  className: 'memory-card-front',
                  innerHTML: '?'
                });
                const cardBack = create('div', { 
                  className: 'memory-card-back',
                  innerHTML: card.value
                });
                
                cardInner.appendChild(cardFront);
                cardInner.appendChild(cardBack);
                cardElement.appendChild(cardInner);
                boardElement.appendChild(cardElement);
              });
            }
            
            function restartGame() {
              gameState.flippedCards = [];
              gameState.matchedPairs = 0;
              gameState.moves = 0;
              gameState.gameActive = true;
              createCards();
              renderBoard();
            }
            
            // Create board
            const boardElement = create('div', { className: 'memory-grid' });
            createCards();
            renderBoard();
            container.appendChild(boardElement);
            
            // Return game API
            return {
              destroy() {
                container.innerHTML = '';
              },
              pause() {
                // Not pausable
              },
              resume() {
                // Not pausable
              },
              restart() {
                restartGame();
              }
            };
          }
        },
        
        // Reaction Tester game
        reaction: {
          id: 'reaction',
          title: 'Reaction Tester',
          description: 'Test your reaction speed',
          icon: '‚è±Ô∏è',
          init(container) {
            const gameState = {
              gameState: 'waiting', // waiting, ready, clicked
              startTime: 0,
              reactionTimes: [],
              gameActive: true
            };
            
            const reactionBox = create('div', {
              className: 'reaction-box waiting',
              innerHTML: 'Wait for green...',
              onclick: handleClick
            });
            
            const historyElement = create('div', { className: 'reaction-history' });
            
            function handleClick() {
              if (gameState.gameState === 'waiting') {
                // Too early
                reactionBox.textContent = 'Too early! Wait for green.';
                reactionBox.className = 'reaction-box waiting';
                setTimeout(() => {
                  if (gameState.gameActive) {
                    setWaitingState();
                  }
                }, 1000);
              } else if (gameState.gameState === 'ready') {
                // Calculate reaction time
                const reactionTime = Date.now() - gameState.startTime;
                gameState.reactionTimes.push(reactionTime);
                
                reactionBox.textContent = `${reactionTime} ms`;
                reactionBox.className = 'reaction-box';
                
                // Update history
                updateHistory();
                
                // Show achievement for fast reaction
                if (reactionTime < 300) {
                  unlockAchievement('speed_demon');
                }
                
                // Reset after delay
                setTimeout(() => {
                  if (gameState.gameActive) {
                    setWaitingState();
                  }
                }, 2000);
              }
            }
            
            function setWaitingState() {
              reactionBox.textContent = 'Wait for green...';
              reactionBox.className = 'reaction-box waiting';
              gameState.gameState = 'waiting';
              
              // Random delay before ready state
              const delay = 2000 + Math.random() * 3000;
              setTimeout(() => {
                if (gameState.gameActive && gameState.gameState === 'waiting') {
                  reactionBox.textContent = 'CLICK NOW!';
                  reactionBox.className = 'reaction-box ready';
                  gameState.gameState = 'ready';
                  gameState.startTime = Date.now();
                }
              }, delay);
            }
            
            function updateHistory() {
              historyElement.innerHTML = '';
              const recentTimes = gameState.reactionTimes.slice(-10);
              
              recentTimes.forEach(time => {
                const bar = create('div', {
                  className: 'reaction-bar',
                  style: `height: ${Math.min(time / 10, 40)}px;`
                });
                historyElement.appendChild(bar);
              });
            }
            
            function restartGame() {
              gameState.reactionTimes = [];
              gameState.gameActive = true;
              updateHistory();
              setWaitingState();
            }
            
            // Initialize game
            container.appendChild(reactionBox);
            container.appendChild(historyElement);
            setWaitingState();
            
            // Return game API
            return {
              destroy() {
                gameState.gameActive = false;
                container.innerHTML = '';
              },
              pause() {
                gameState.gameActive = false;
              },
              resume() {
                gameState.gameActive = true;
                setWaitingState();
              },
              restart() {
                restartGame();
              }
            };
          }
        },
        
        // Whack-a-Doodle game
        whack: {
          id: 'whack',
          title: 'Whack-a-Doodle',
          description: 'Whack the doodles as they appear',
          icon: 'üî®',
          init(container) {
            const gameState = {
              score: 0,
              timeLeft: 30,
              gameActive: false,
              timer: null
            };
            
            const scoreElement = create('div', {
              style: 'font-size: 1.5rem; margin-bottom: 20px;',
              innerHTML: `Score: <span id="whackScore">0</span> | Time: <span id="whackTime">30</span>s`
            });
            
            const gameContainer = create('div', { className: 'whack-container' });
            
            // Create holes
            for (let i = 0; i < 9; i++) {
              const hole = create('div', { className: 'whack-hole' });
              const mole = create('div', {
                className: 'whack-mole',
                innerHTML: 'üëæ',
                onclick: () => whackMole(mole)
              });
              
              hole.appendChild(mole);
              gameContainer.appendChild(hole);
            }
            
            function whackMole(mole) {
              if (!gameState.gameActive || !mole.classList.contains('up')) return;
              
              mole.classList.remove('up');
              gameState.score++;
              updateScore();
              SoundManager.play('success');
            }
            
            function popMole() {
              if (!gameState.gameActive) return;
              
              const moles = qsa('.whack-mole');
              const randomMole = moles[Math.floor(Math.random() * moles.length)];
              
              randomMole.classList.add('up');
              
              setTimeout(() => {
                if (randomMole.classList.contains('up')) {
                  randomMole.classList.remove('up');
                }
              }, 1000);
            }
            
            function updateScore() {
              qs('#whackScore').textContent = gameState.score;
            }
            
            function updateTime() {
              qs('#whackTime').textContent = gameState.timeLeft;
            }
            
            function startGame() {
              gameState.score = 0;
              gameState.timeLeft = 30;
              gameState.gameActive = true;
              updateScore();
              updateTime();
              
              gameState.timer = setInterval(() => {
                if (gameState.timeLeft <= 0) {
                  endGame();
                  return;
                }
                
                gameState.timeLeft--;
                updateTime();
                popMole();
              }, 1000);
              
              // Pop first mole immediately
              setTimeout(popMole, 500);
            }
            
            function endGame() {
              gameState.gameActive = false;
              clearInterval(gameState.timer);
              Toast.show(`Game over! Final score: ${gameState.score}`, 'info');
              
              // Unlock achievement for high score
              if (gameState.score >= 20) {
                unlockAchievement('whack_streak');
              }
            }
            
            function restartGame() {
              if (gameState.timer) {
                clearInterval(gameState.timer);
              }
              startGame();
            }
            
            // Initialize game
            container.appendChild(scoreElement);
            container.appendChild(gameContainer);
            startGame();
            
            // Return game API
            return {
              destroy() {
                if (gameState.timer) {
                  clearInterval(gameState.timer);
                }
                container.innerHTML = '';
              },
              pause() {
                gameState.gameActive = false;
                clearInterval(gameState.timer);
              },
              resume() {
                if (!gameState.gameActive) {
                  gameState.gameActive = true;
                  gameState.timer = setInterval(() => {
                    if (gameState.timeLeft <= 0) {
                      endGame();
                      return;
                    }
                    
                    gameState.timeLeft--;
                    updateTime();
                    popMole();
                  }, 1000);
                }
              },
              restart() {
                restartGame();
              }
            };
          }
        }
      };

      // Register games
      function registerGames() {
        for (const gameId in GameModules) {
          gamesRegistry[gameId] = GameModules[gameId];
        }
      }

      // Render game tiles
      function renderGameTiles() {
        gamesGrid.innerHTML = '';
        
        for (const gameId in gamesRegistry) {
          const game = gamesRegistry[gameId];
          
          const tile = create('div', {
            className: 'game-tile',
            tabIndex: 0,
            onclick: () => openGame(gameId),
            onkeydown: (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                openGame(gameId);
              }
            }
          }, [
            create('div', { className: 'game-icon', innerHTML: game.icon }),
            create('h3', { className: 'game-title', innerHTML: game.title }),
            create('p', { className: 'game-description', innerHTML: game.description })
          ]);
          
          gamesGrid.appendChild(tile);
        }
      }

      // Open game
      function openGame(gameId) {
        const game = gamesRegistry[gameId];
        if (!game) return;
        
        currentGameTitle.textContent = game.title;
        gameView.classList.add('active');
        
        // Destroy previous game if exists
        if (activeGame && activeGame.destroy) {
          activeGame.destroy();
        }
        
        // Initialize new game
        activeGame = game.init(gameContent);
      }

      // Close game
      function closeGame() {
        if (activeGame && activeGame.destroy) {
          activeGame.destroy();
        }
        gameView.classList.remove('active');
        activeGame = null;
      }

      // Unlock achievement
      function unlockAchievement(achievementId) {
        if (achievements[achievementId]) return; // Already unlocked
        
        achievements[achievementId] = true;
        saveData();
        
        let message = '';
        switch (achievementId) {
          case 'tic_master':
            message = 'Achievement Unlocked: Tic-Tac-Toe Master!';
            break;
          case 'memory_champ':
            message = 'Achievement Unlocked: Memory Champion!';
            break;
          case 'speed_demon':
            message = 'Achievement Unlocked: Speed Demon!';
            break;
          case 'whack_streak':
            message = 'Achievement Unlocked: Whack-a-Doodle Streak!';
            break;
        }
        
        if (message) {
          Toast.show(message, 'success');
          // Show confetti for major achievements
          if (['tic_master', 'memory_champ', 'speed_demon', 'whack_streak'].includes(achievementId)) {
            Confetti.burst(window.innerWidth/2, window.innerHeight/2, 50);
          }
        }
      }

      // Event Listeners
      backButton.addEventListener('click', closeGame);
      
      soundToggle.addEventListener('click', () => {
        settings.soundOn = !settings.soundOn;
        applySettings();
        saveData();
        SoundManager.play('click');
      });
      
      themeToggle.addEventListener('click', () => {
        if (settings.theme === 'light') {
          settings.theme = 'dark';
        } else if (settings.theme === 'dark') {
          settings.theme = 'neon';
        } else {
          settings.theme = 'light';
        }
        applySettings();
        saveData();
        SoundManager.play('click');
      });
      
      settingsButton.addEventListener('click', () => {
        settingsModal.classList.add('active');
        SoundManager.play('click');
      });
      
      profileButton.addEventListener('click', () => {
        profileModal.classList.add('active');
        SoundManager.play('click');
      });
      
      closeSettings.addEventListener('click', () => {
        settingsModal.classList.remove('active');
      });
      
      closeProfile.addEventListener('click', () => {
        profileModal.classList.remove('active');
      });
      
      closeProfileBtn.addEventListener('click', () => {
        profileModal.classList.remove('active');
      });
      
      closeOnboarding.addEventListener('click', () => {
        onboardingModal.classList.remove('active');
      });
      
      saveSettingsBtn.addEventListener('click', () => {
        settings.soundOn = soundToggleSetting.checked;
        settings.volume = parseFloat(volumeSlider.value);
        settings.theme = themeSelect.value;
        settings.showOnboarding = onboardingToggle.checked;
        
        applySettings();
        saveData();
        settingsModal.classList.remove('active');
        Toast.show('Settings saved!', 'success');
        SoundManager.play('success');
      });
      
      resetProgressBtn.addEventListener('click', () => {
        if (confirm('Are you sure you want to reset all progress?')) {
          scores = {};
          achievements = {};
          saveData();
          Toast.show('Progress reset!', 'info');
          SoundManager.play('click');
        }
      });
      
      startPlayingBtn.addEventListener('click', () => {
        onboardingModal.classList.remove('active');
      });
      
      gameRestart.addEventListener('click', () => {
        if (activeGame && activeGame.restart) {
          activeGame.restart();
          Toast.show('Game restarted!', 'info');
          SoundManager.play('click');
        }
      });
      
      gamePause.addEventListener('click', () => {
        if (activeGame) {
          if (activeGame.pause) {
            activeGame.pause();
            Toast.show('Game paused', 'info');
          } else if (activeGame.resume) {
            activeGame.resume();
            Toast.show('Game resumed', 'info');
          }
          SoundManager.play('click');
        }
      });

      // Initialize app
      function initApp() {
        SoundManager.init();
        loadData();
        applySettings();
        registerGames();
        renderGameTiles();
        createDoodleBackground();
        checkOnboarding();
      }

      // Start the app
      initApp();
    })();
  </script>
</body>
</html>
