

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaikh's Enhanced Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700&family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        /* ===== CSS Variables - Enhanced Theme with Google Doodle Colors ===== */
        :root {
            /* Light Theme (Default) - Google Doodle Palette */
            --color-blue: #4285f4;
            --color-green: #34a853;
            --color-yellow: #fbbc04;
            --color-red: #ea4335;
            --color-blue-light: #8ab4f8;
            --color-green-light: #7bcfa9;
            --color-yellow-light: #fcd669;
            --color-red-light: #f28b82;
            --color-blue-dark: #1a56db;
            --color-green-dark: #2e8b57;
            --color-yellow-dark: #e6ac00;
            --color-red-dark: #c5221f;
            --color-background: #ffffff;
            --color-on-background: #202124;
            --color-surface: #f8f9fa;
            --color-on-surface: #5f6368;
            --color-primary: var(--color-blue);
            --color-on-primary: #ffffff;
            --color-secondary: var(--color-green);
            --color-on-secondary: #ffffff;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15), 0 5px 10px rgba(0, 0, 0, 0.08);
            --shadow-focus: 0 0 0 3px rgba(66, 133, 244, 0.3);
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --border-radius-lg: 12px;
            --border-radius-xl: 16px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-xxl: 48px;
            --font-family-base: 'Nunito', sans-serif;
            --font-family-heading: 'Fredoka One', cursive;
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
            --z-sidebar: 10;
            --z-modal: 100;
            --z-toast: 110;
        }

        .theme-dark {
            --color-background: #202124;
            --color-on-background: #e8eaed;
            --color-surface: #303134;
            --color-on-surface: #9aa0a6;
            --color-blue: #8ab4f8;
            --color-green: #7bcfa9;
            --color-yellow: #fcd669;
            --color-red: #f28b82;
            --color-blue-light: #a8c7fa;
            --color-green-light: #9ddbc9;
            --color-yellow-light: #fde39c;
            --color-red-light: #f6a5a0;
            --color-blue-dark: #5e97f6;
            --color-green-dark: #5bb974;
            --color-yellow-dark: #fcc93a;
            --color-red-dark: #ee6761;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.15);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.3), 0 5px 10px rgba(0, 0, 0, 0.22);
            --shadow-focus: 0 0 0 3px rgba(138, 180, 248, 0.3);
        }

        /* ===== Base Styles ===== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family-base);
            background-color: var(--color-background);
            color: var(--color-on-background);
            line-height: 1.6;
            overflow-x: hidden;
            transition: background-color var(--transition-normal), color var(--transition-normal);
            position: relative;
            min-height: 100vh;
        }

        /* ===== Enhanced Doodle Background with More Detail ===== */
        .doodle-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .doodle {
            position: absolute;
            opacity: 0.05; /* Subtle in light mode */
        }

        .doodle.circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px dashed var(--color-blue);
            animation: float 25s infinite ease-in-out;
        }

        .doodle.square {
            width: 60px;
            height: 60px;
            border: 2px dotted var(--color-green);
            animation: rotate 35s infinite linear;
        }

        .doodle.triangle {
            width: 0;
            height: 0;
            border-left: 40px solid transparent;
            border-right: 40px solid transparent;
            border-bottom: 70px solid var(--color-yellow);
            opacity: 0.04;
            animation: float 30s infinite ease-in-out reverse;
        }

        .doodle.zigzag {
            width: 100px;
            height: 20px;
            background: repeating-linear-gradient(-45deg,
                transparent,
                transparent 10px,
                var(--color-red) 10px,
                var(--color-red) 20px);
            animation: moveRight 45s infinite linear;
        }

        /* New doodle types for more detail */
        .doodle.star {
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 35px solid var(--color-blue);
            opacity: 0.03;
            animation: twinkle 4s infinite ease-in-out;
        }

        .doodle.blob {
            width: 70px;
            height: 70px;
            border-radius: 50% 40% 60% 30% / 30% 60% 40% 50%;
            background: var(--color-green);
            opacity: 0.04;
            animation: morph 15s infinite ease-in-out;
        }

        /* Enhance doodles in dark mode */
        .theme-dark .doodle {
            opacity: 0.12;
        }

        .theme-dark .doodle.circle {
            border: 2px dashed var(--color-blue);
        }

        .theme-dark .doodle.square {
            border: 2px dotted var(--color-green);
        }

        .theme-dark .doodle.triangle {
            border-bottom: 70px solid var(--color-yellow);
            opacity: 0.08;
        }

        .theme-dark .doodle.zigzag {
            background: repeating-linear-gradient(-45deg,
                transparent,
                transparent 10px,
                var(--color-red) 10px,
                var(--color-red) 20px);
        }

        .theme-dark .doodle.star {
            border-bottom: 35px solid var(--color-blue);
            opacity: 0.1;
        }

        .theme-dark .doodle.blob {
            background: var(--color-green);
            opacity: 0.08;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(15px, 20px) rotate(5deg); }
            50% { transform: translate(0, 40px) rotate(0deg); }
            75% { transform: translate(-15px, 20px) rotate(-5deg); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes moveRight {
            from { transform: translateX(-100px); }
            to { transform: translateX(calc(100vw + 100px)); }
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.03; transform: scale(1); }
            50% { opacity: 0.1; transform: scale(1.1); }
        }

        @keyframes morph {
            0%, 100% { border-radius: 50% 40% 60% 30% / 30% 60% 40% 50%; }
            33% { border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; }
            66% { border-radius: 50% 60% 30% 70% / 40% 50% 60% 30%; }
        }

        /* ===== Buttons ===== */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-md);
            font-family: var(--font-family-base);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            border: none;
            outline: none;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .btn:focus {
            box-shadow: var(--shadow-focus);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: var(--color-on-primary);
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-blue-dark);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: var(--color-surface);
            color: var(--color-on-surface);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .theme-dark .btn-secondary {
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: rgba(0, 0, 0, 0.03);
            box-shadow: var(--shadow-md);
        }

        .theme-dark .btn-secondary:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .icon-button {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: var(--spacing-sm);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color var(--transition-fast);
        }

        .icon-button:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .theme-dark .icon-button:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* ===== Header ===== */
        header {
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: var(--spacing-md) 0;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 var(--spacing-md);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            text-decoration: none;
            color: var(--color-on-surface);
            font-family: var(--font-family-heading);
            font-size: 1.5rem;
            transition: color var(--transition-fast);
        }

        .logo:hover {
            color: var(--color-primary);
        }

        .logo-icon {
            font-size: 2rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        /* ===== Main Layout ===== */
        .game-area {
            display: flex;
            gap: var(--spacing-lg);
            margin-top: var(--spacing-md);
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
            padding: 0 var(--spacing-md);
        }

        /* ===== Sidebar ===== */
        .game-sidebar {
            width: 300px;
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
            padding: var(--spacing-md);
            overflow-y: auto;
            max-height: calc(100vh - 200px);
            transition: transform var(--transition-normal);
            z-index: var(--z-sidebar);
            border: 1px solid rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 100px;
            align-self: flex-start;
        }

        .theme-dark .game-sidebar {
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-sidebar.hidden {
            transform: translateX(-110%);
            position: absolute;
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .theme-dark .sidebar-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-title {
            font-family: var(--font-family-heading);
            font-size: 1.5rem;
            font-weight: 400;
            margin: 0;
            color: var(--color-primary);
        }

        .toggle-sidebar {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            display: none;
        }

        .game-list {
            list-style: none;
        }

        .game-list-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            cursor: pointer;
            transition: background-color var(--transition-fast);
            margin-bottom: var(--spacing-xs);
        }

        .game-list-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .theme-dark .game-list-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .game-list-item.active {
            background-color: rgba(66, 133, 244, 0.15); /* Primary color with opacity */
            font-weight: 600;
        }

        .game-list-icon {
            font-size: 1.5rem;
        }

        .game-list-text {
            flex: 1;
            color: var(--color-on-surface);
        }

        /* ===== Main Content ===== */
        .games-main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-sm);
        }

        .game-tile {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            cursor: pointer;
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .game-tile:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-md);
        }

        .game-tile::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--color-blue) 0%, var(--color-green) 25%, var(--color-yellow) 50%, var(--color-red) 75%, var(--color-blue) 100%);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform var(--transition-normal);
        }

        .game-tile:hover::before {
            transform: scaleX(1);
        }

        .game-icon {
            width: 70px;
            height: 70px;
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            border-radius: var(--border-radius-md);
            background-color: var(--color-primary);
            color: var(--color-on-primary);
            transition: transform var(--transition-normal);
            position: relative;
            box-shadow: var(--shadow-md);
            animation: float-subtle 3s ease-in-out infinite alternate;
        }

        @keyframes float-subtle {
            from { transform: translateY(0px); }
            to { transform: translateY(-5px); }
        }

        .game-tile:hover .game-icon {
            animation: wiggle 0.6s ease;
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }

        .game-title {
            font-family: var(--font-family-heading);
            font-size: 1.25rem;
            font-weight: 400;
            margin-bottom: var(--spacing-xs);
            color: var(--color-on-surface);
        }

        .game-description {
            font-size: 0.875rem;
            color: var(--color-on-surface);
            opacity: 0.7;
            transform: translateY(0);
            transition: transform var(--transition-fast);
        }

        .game-tile:hover .game-description {
            transform: translateY(2px);
        }

        .game-view {
            display: none;
            background-color: var(--color-surface);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            height: calc(100vh - 160px);
            flex-direction: column;
            margin-top: var(--spacing-md);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .theme-dark .game-view {
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-view.active {
            display: flex;
        }

        .game-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .theme-dark .game-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-title-bar {
            font-family: var(--font-family-heading);
            font-size: 1.5rem;
            color: var(--color-on-surface);
            margin: 0;
        }

        .game-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* ===== Modals ===== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-modal);
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal), visibility var(--transition-normal);
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background-color: var(--color-background);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(20px);
            transition: transform var(--transition-normal);
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .theme-dark .modal-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            font-family: var(--font-family-heading);
            font-size: 1.5rem;
            margin: 0;
            color: var(--color-on-surface);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color var(--transition-fast);
        }

        .modal-close:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .theme-dark .modal-close:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .modal-body {
            padding: var(--spacing-md);
        }

        .modal-footer {
            padding: var(--spacing-sm) var(--spacing-md);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .theme-dark .modal-footer {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-group label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: 600;
            color: var(--color-on-surface);
        }

        .form-control {
            width: 100%;
            padding: var(--spacing-sm);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius-sm);
            font-family: var(--font-family-base);
            font-size: 1rem;
            background-color: var(--color-surface);
            color: var(--color-on-surface);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }

        .theme-dark .form-control {
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: var(--color-background);
        }

        .form-control:focus {
            border-color: var(--color-primary);
            box-shadow: var(--shadow-focus);
            outline: none;
        }

        /* ===== Toasts ===== */
        .toast-container {
            position: fixed;
            bottom: var(--spacing-lg);
            right: var(--spacing-lg);
            z-index: var(--z-toast);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .toast {
            background-color: var(--color-surface);
            color: var(--color-on-surface);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            transform: translateX(120%);
            transition: transform var(--transition-normal);
            border-left: 4px solid var(--color-primary);
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            margin-left: auto;
            padding: var(--spacing-xs);
            border-radius: var(--border-radius-sm);
            transition: background-color var(--transition-fast);
        }

        .toast-close:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .theme-dark .toast-close:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* ===== Animations ===== */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .fade-in {
            animation: fadeIn var(--transition-normal) ease-in;
        }

        /* ===== Game Specific Styles ===== */

        /* Snake Game */
        .snake-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .snake-canvas-container {
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        .snake-canvas {
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-sm);
            display: block;
            width: 100%;
            height: auto;
            border: 1px solid #b2ebf2;
        }

        .theme-dark .snake-canvas {
            background: linear-gradient(to bottom, #263238, #37474f);
            border: 1px solid #455a64;
        }

        .snake-stats {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        .snake-controls {
            display: flex;
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Tic Tac Toe Game */
        .tictactoe-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 400px;
        }

        .tictactoe-status {
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            min-height: 30px;
        }

        .tictactoe-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: var(--spacing-sm);
            width: 100%;
            max-width: 300px;
        }

        .tictactoe-cell {
            aspect-ratio: 1;
            background-color: var(--color-surface);
            border-radius: var(--border-radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color var(--transition-fast), transform var(--transition-fast);
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .theme-dark .tictactoe-cell {
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .tictactoe-cell:hover:not(.win) {
            background-color: rgba(0, 0, 0, 0.03);
            transform: scale(1.05);
        }

        .theme-dark .tictactoe-cell:hover:not(.win) {
            background-color: rgba(255, 255, 255, 0.08);
        }

        .tictactoe-cell.win {
            background-color: rgba(168, 230, 207, 0.4);
            animation: pulse 0.5s ease-in-out;
        }

        .theme-dark .tictactoe-cell.win {
            background-color: rgba(138, 201, 160, 0.4);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .tictactoe-score {
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            margin: var(--spacing-md) 0;
        }

        .tictactoe-controls {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
            flex-wrap: wrap;
            justify-content: center;
        }

        .tictactoe-mode-selector {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
            margin-bottom: var(--spacing-sm);
            flex-wrap: wrap;
            justify-content: center;
        }

        .tictactoe-mode-selector .btn {
            font-size: 0.8rem;
            padding: var(--spacing-xs) var(--spacing-sm);
        }

        .tictactoe-mode-selector .btn.active {
            background-color: var(--color-primary);
            color: var(--color-on-primary);
        }

        /* Reaction Tester Game */
        .reaction-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .reaction-display {
            width: 100%;
            max-width: 300px;
            height: 150px;
            border-radius: var(--border-radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: background-color var(--transition-fast), transform var(--transition-fast);
            box-shadow: var(--shadow-sm);
            user-select: none;
        }

        .reaction-display:hover {
            transform: scale(1.02);
        }

        .reaction-ready {
            background: linear-gradient(135deg, var(--color-blue), var(--color-green));
            color: var(--color-on-primary);
        }

        .reaction-wait {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            color: var(--color-on-primary);
        }

        .reaction-go {
            background: linear-gradient(135deg, #4caf50, #388e3c);
            color: var(--color-on-primary);
            animation: pulse-bg 1s infinite;
        }

        @keyframes pulse-bg {
            0% { background-size: 100% 100%; }
            50% { background-size: 110% 110%; }
            100% { background-size: 100% 100%; }
        }

        .reaction-result {
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            min-height: 30px;
            color: var(--color-primary);
        }

        .reaction-attempts {
            font-size: 1rem;
            opacity: 0.8;
        }

        /* Whack-a-Doodle Game */
        .whack-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .whack-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: var(--spacing-md);
            width: 100%;
            max-width: 350px;
        }

        .whack-hole {
            aspect-ratio: 1;
            background: radial-gradient(circle, #795548, #5d4037);
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 8px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .whack-doodle {
            position: absolute;
            width: 70%;
            height: 70%;
            background: radial-gradient(circle at 30% 30%, #FFD3B6, #FFAAA5);
            border-radius: 50%;
            bottom: -100%;
            transition: bottom 0.3s ease, transform 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 2px solid #d7ccc8;
        }

        .whack-doodle:hover {
            transform: scale(1.1);
        }

        .whack-doodle.up {
            bottom: 15%;
            animation: peek 0.3s ease-out;
        }

        @keyframes peek {
            0% { bottom: -100%; }
            70% { bottom: 20%; }
            100% { bottom: 15%; }
        }

        .whack-stat {
            display: flex;
            gap: var(--spacing-lg);
            flex-wrap: wrap;
            justify-content: center;
        }

        .whack-stat-item {
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        /* Dice Game */
        .dice-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .dice-container {
            display: flex;
            gap: var(--spacing-md);
            justify-content: center;
            align-items: center;
        }

        .dice {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--color-surface), #f1f3f4);
            border-radius: var(--border-radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: 700;
            box-shadow: var(--shadow-sm);
        }

        .theme-dark .dice {
            background: linear-gradient(135deg, var(--color-surface), #2a2a30);
        }

        .dice-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
            width: 100%;
            max-width: 300px;
        }

        .dice-guess {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            width: 100%;
        }

        .dice-guess input {
            flex: 1;
            padding: var(--spacing-sm);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius-sm);
            font-size: 1rem;
            text-align: center;
            background-color: var(--color-surface);
            color: var(--color-on-surface);
        }

        .theme-dark .dice-guess input {
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: var(--color-background);
        }

        .dice-result {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            min-height: 30px;
            color: var(--color-primary);
        }

        .dice-stats {
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            margin-top: var(--spacing-sm);
        }

        /* Shaikh's Runner Game */
        .runner-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 700px;
        }

        .runner-canvas-container {
            position: relative;
            width: 100%;
            max-width: 600px;
        }

        .runner-canvas {
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-sm);
            display: block;
            width: 100%;
            height: auto;
            border: 1px solid #b2ebf2;
        }

        .theme-dark .runner-canvas {
            background: linear-gradient(to bottom, #263238, #37474f);
            border: 1px solid #455a64;
        }

        .runner-stats {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        .runner-controls {
            display: flex;
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
            justify-content: center;
        }

        /* NEW GAMES STYLES */

        /* Memory Match Game */
        .memory-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 600px;
        }

        .memory-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-gap: var(--spacing-sm);
            width: 100%;
            max-width: 400px;
        }

        .memory-card {
            aspect-ratio: 1;
            background-color: var(--color-primary);
            border-radius: var(--border-radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            cursor: pointer;
            transition: transform var(--transition-normal), background-color var(--transition-fast);
            transform-style: preserve-3d;
            box-shadow: var(--shadow-sm);
        }

        .memory-card.flipped {
            transform: rotateY(180deg);
            background-color: var(--color-surface);
        }

        .memory-card.matched {
            transform: rotateY(180deg);
            background-color: var(--color-green-light);
            cursor: default;
        }

        .memory-stats {
            display: flex;
            gap: var(--spacing-lg);
            flex-wrap: wrap;
            justify-content: center;
        }

        .memory-stat-item {
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        /* Space Invaders Game */
        .space-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .space-canvas-container {
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        .space-canvas {
            background: linear-gradient(to bottom, #000033, #000066);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-sm);
            display: block;
            width: 100%;
            height: auto;
            border: 1px solid #1a237e;
        }

        .theme-dark .space-canvas {
            background: linear-gradient(to bottom, #000033, #000066);
            border: 1px solid #3949ab;
        }

        .space-stats {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        .space-controls {
            display: flex;
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Flappy Bird Game */
        .flappy-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .flappy-canvas-container {
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        .flappy-canvas {
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-sm);
            display: block;
            width: 100%;
            height: auto;
            border: 1px solid #b2ebf2;
        }

        .theme-dark .flappy-canvas {
            background: linear-gradient(to bottom, #263238, #37474f);
            border: 1px solid #455a64;
        }

        .flappy-stats {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        .flappy-controls {
            display: flex;
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Breakout Game */
        .breakout-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .breakout-canvas-container {
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        .breakout-canvas {
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-sm);
            display: block;
            width: 100%;
            height: auto;
            border: 1px solid #b2ebf2;
        }

        .theme-dark .breakout-canvas {
            background: linear-gradient(to bottom, #263238, #37474f);
            border: 1px solid #455a64;
        }

        .breakout-stats {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            color: var(--color-primary);
        }

        .breakout-controls {
            display: flex;
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Rock Paper Scissors Game */
        .rps-game {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-lg);
            width: 100%;
            max-width: 500px;
        }

        .rps-choices {
            display: flex;
            gap: var(--spacing-md);
            justify-content: center;
            margin-bottom: var(--spacing-md);
        }

        .rps-choice {
            width: 80px;
            height: 80px;
            background-color: var(--color-surface);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            cursor: pointer;
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
            box-shadow: var(--shadow-sm);
        }

        .rps-choice:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow-md);
        }

        .rps-result {
            font-size: 1.5rem;
            font-weight: 600;
            text-align: center;
            min-height: 40px;
            margin: var(--spacing-md) 0;
            color: var(--color-primary);
        }

        .rps-score {
            display: flex;
            gap: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
        }

        .rps-score-item {
            text-align: center;
        }

        .rps-score-label {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .rps-score-value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        /* ===== Responsive Design ===== */
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
            }

            .game-sidebar {
                width: 100%;
                position: relative;
                top: 0;
                max-height: none;
                box-shadow: none;
                border-bottom: 1px solid rgba(0, 0, 0, 0.1);
                border-radius: 0;
                padding: var(--spacing-md) 0;
            }

            .theme-dark .game-sidebar {
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .sidebar-header {
                padding: 0 var(--spacing-md);
            }

            .toggle-sidebar {
                display: block;
            }

            .game-sidebar.hidden {
                transform: none;
                position: relative;
                display: none;
            }

            .games-grid {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            }

            .game-view {
                height: calc(100vh - 180px);
            }

            .memory-board {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 480px) {
            .header-content {
                flex-direction: column;
                gap: var(--spacing-md);
            }

            .games-grid {
                grid-template-columns: 1fr;
            }

            .game-icon {
                width: 60px;
                height: 60px;
                font-size: 1.8rem;
            }

            .game-title {
                font-size: 1.1rem;
            }

            .tictactoe-cell {
                font-size: 2rem;
            }

            .dice {
                width: 70px;
                height: 70px;
                font-size: 2rem;
            }

            .reaction-display {
                height: 120px;
                font-size: 1.2rem;
            }

            .memory-board {
                grid-template-columns: repeat(3, 1fr);
            }

            .rps-choices {
                gap: var(--spacing-sm);
            }

            .rps-choice {
                width: 60px;
                height: 60px;
                font-size: 1.8rem;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .doodle-bg {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Doodle Background -->
    <div class="doodle-bg">
        <div class="doodle circle" style="top: 10%; left: 5%;"></div>
        <div class="doodle square" style="top: 20%; right: 7%;"></div>
        <div class="doodle triangle" style="top: 60%; left: 8%;"></div>
        <div class="doodle zigzag" style="top: 40%; left: 15%;"></div>
        <div class="doodle star" style="top: 30%; right: 15%;"></div>
        <div class="doodle blob" style="top: 70%; right: 20%;"></div>
        <div class="doodle circle" style="top: 15%; left: 25%;"></div>
        <div class="doodle square" style="top: 50%; left: 30%;"></div>
        <div class="doodle triangle" style="top: 80%; right: 25%;"></div>
        <div class="doodle zigzag" style="top: 25%; right: 35%;"></div>
        <div class="doodle star" style="top: 65%; left: 20%;"></div>
        <div class="doodle blob" style="top: 45%; right: 40%;"></div>
    </div>

    <!-- Header -->
    <header>
        <div class="header-content">
            <a href="#" class="logo" id="logo">
                <span class="logo-icon">🎪</span>
                <span>Shaikh's Enhanced Arcade</span>
            </a>
            <div class="header-controls">
                <button class="icon-button" id="themeToggle" title="Toggle Theme">☀️</button>
                <button class="icon-button" id="soundToggle" title="Toggle Sound">🔊</button>
                <button class="icon-button" id="profileButton" title="Profile">👤</button>
                <button class="icon-button" id="settingsButton" title="Settings">⚙️</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="game-area">
        <!-- Sidebar -->
        <aside class="game-sidebar" id="gameSidebar">
            <div class="sidebar-header">
                <h2 class="sidebar-title">Games</h2>
                <button class="toggle-sidebar" id="toggleSidebar">✕</button>
            </div>
            <ul class="game-list" id="gameList">
                <!-- Game list items will be populated by JavaScript -->
            </ul>
        </aside>

        <!-- Main Content Area -->
        <main class="games-main-content">
            <!-- Games Grid -->
            <div class="games-grid" id="gamesGrid">
                <!-- Game tiles will be populated by JavaScript -->
            </div>

            <!-- Game Views -->
            <div class="game-view" id="snakeView">
                <div class="game-header">
                    <h2 class="game-title-bar">🐍 Shaikh's Snake</h2>
                    <button class="icon-button" id="closeSnakeView">✕</button>
                </div>
                <div class="game-content" id="snakeContent">
                    <!-- Snake game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="tictactoeView">
                <div class="game-header">
                    <h2 class="game-title-bar">⭕ Tic-Tac-Toe</h2>
                    <button class="icon-button" id="closeTicTacToeView">✕</button>
                </div>
                <div class="game-content" id="tictactoeContent">
                    <!-- Tic-Tac-Toe game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="reactionView">
                <div class="game-header">
                    <h2 class="game-title-bar">⏱️ Reaction Tester</h2>
                    <button class="icon-button" id="closeReactionView">✕</button>
                </div>
                <div class="game-content" id="reactionContent">
                    <!-- Reaction Tester game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="whackView">
                <div class="game-header">
                    <h2 class="game-title-bar">🔨 Whack-a-Doodle</h2>
                    <button class="icon-button" id="closeWhackView">✕</button>
                </div>
                <div class="game-content" id="whackContent">
                    <!-- Whack-a-Doodle game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="diceView">
                <div class="game-header">
                    <h2 class="game-title-bar">🎲 Dice Guessing</h2>
                    <button class="icon-button" id="closeDiceView">✕</button>
                </div>
                <div class="game-content" id="diceContent">
                    <!-- Dice game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="runnerView">
                <div class="game-header">
                    <h2 class="game-title-bar">🏃 Shaikh's Runner</h2>
                    <button class="icon-button" id="closeRunnerView">✕</button>
                </div>
                <div class="game-content" id="runnerContent">
                    <!-- Runner game content will be populated by JavaScript -->
                </div>
            </div>

            <!-- NEW GAME VIEWS -->
            <div class="game-view" id="memoryView">
                <div class="game-header">
                    <h2 class="game-title-bar">🧠 Memory Match</h2>
                    <button class="icon-button" id="closeMemoryView">✕</button>
                </div>
                <div class="game-content" id="memoryContent">
                    <!-- Memory Match game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="spaceView">
                <div class="game-header">
                    <h2 class="game-title-bar">👾 Space Invaders</h2>
                    <button class="icon-button" id="closeSpaceView">✕</button>
                </div>
                <div class="game-content" id="spaceContent">
                    <!-- Space Invaders game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="flappyView">
                <div class="game-header">
                    <h2 class="game-title-bar">🐦 Flappy Bird</h2>
                    <button class="icon-button" id="closeFlappyView">✕</button>
                </div>
                <div class="game-content" id="flappyContent">
                    <!-- Flappy Bird game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="breakoutView">
                <div class="game-header">
                    <h2 class="game-title-bar">🔨 Breakout</h2>
                    <button class="icon-button" id="closeBreakoutView">✕</button>
                </div>
                <div class="game-content" id="breakoutContent">
                    <!-- Breakout game content will be populated by JavaScript -->
                </div>
            </div>

            <div class="game-view" id="rpsView">
                <div class="game-header">
                    <h2 class="game-title-bar">✂️ Rock Paper Scissors</h2>
                    <button class="icon-button" id="closeRpsView">✕</button>
                </div>
                <div class="game-content" id="rpsContent">
                    <!-- Rock Paper Scissors game content will be populated by JavaScript -->
                </div>
            </div>
        </main>
    </div>

    <!-- Profile Modal -->
    <div class="modal-overlay" id="profileModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">👤 Profile</h3>
                <button class="modal-close" id="closeProfileModal">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <h4>Achievements</h4>
                    <div id="achievementsList">
                        <!-- Achievements will be populated by JavaScript -->
                    </div>
                </div>
                <div class="form-group">
                    <h4>High Scores</h4>
                    <div id="highScoresList">
                        <!-- High scores will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">⚙️ Settings</h3>
                <button class="modal-close" id="closeSettingsModal">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="themeSelect">Theme</label>
                    <select class="form-control" id="themeSelect">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="auto">Auto (System)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="volumeSlider">Volume</label>
                    <input type="range" class="form-control" id="volumeSlider" min="0" max="100" value="50">
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="soundToggleSetting"> Sound Enabled
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- Onboarding Modal -->
    <div class="modal-overlay" id="onboardingModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Welcome to Shaikh's Enhanced Arcade!</h3>
                <button class="modal-close" id="closeOnboarding">✕</button>
            </div>
            <div class="modal-body">
                <div style="text-align: center; margin-bottom: var(--spacing-xl);">
                    <div style="font-size: 4rem; margin-bottom: var(--spacing-md);">🎪</div>
                    <p>Get ready for a doodle-filled adventure! Play classic games with a fun twist.</p>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="showOnboardingCheckbox"> Show this welcome screen again
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="startPlayingButton">Start Playing!</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer">
        <!-- Toasts will be added here dynamically -->
    </div>

    <script>// ===== Utility Functions =====
const qs = (selector) => document.querySelector(selector);
const qsa = (selector) => document.querySelectorAll(selector);
const create = (tag, props = {}) => {
    const el = document.createElement(tag);
    Object.assign(el, props);
    return el;
};

// ===== Sound Manager =====
const SoundManager = {
    context: null,
    sounds: {},
    soundOn: true,
    volume: 0.5,
    
    init() {
        try {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Web Audio API is not supported in this browser');
        }
    },
    
    play(name) {
        if (!this.soundOn || !this.context) return;
        
        // Create simple tones for different sounds
        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);
        
        gainNode.gain.value = this.volume;
        
        switch(name) {
            case 'click':
                oscillator.type = 'square';
                oscillator.frequency.value = 440;
                gainNode.gain.setValueAtTime(this.volume, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.1);
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + 0.1);
                break;
            case 'success':
                oscillator.type = 'sine';
                // Play a simple success melody
                const now = this.context.currentTime;
                oscillator.frequency.setValueAtTime(523.25, now); // C5
                oscillator.frequency.setValueAtTime(659.25, now + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, now + 0.2); // G5
                oscillator.frequency.setValueAtTime(1046.50, now + 0.3); // C6
                
                gainNode.gain.setValueAtTime(this.volume, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
                break;
            case 'error':
                oscillator.type = 'sawtooth';
                oscillator.frequency.value = 220;
                gainNode.gain.setValueAtTime(this.volume, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.3);
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + 0.3);
                break;
        }
    },
    
    toggle() {
        this.soundOn = !this.soundOn;
        const soundToggle = qs('#soundToggle');
        if (soundToggle) {
            soundToggle.textContent = this.soundOn ? '🔊' : '🔇';
        }
        return this.soundOn;
    }
};

// ===== Toast Notifications =====
const Toast = {
    container: null,
    
    init() {
        this.container = create('div', { className: 'toast-container' });
        document.body.appendChild(this.container);
    },
    
    show(message, type = 'info') {
        const toast = create('div', {
            className: `toast toast-${type} show`,
            innerHTML: `
                <span>${message}</span>
                <button class="toast-close">&times;</button>
            `
        });
        
        this.container.appendChild(toast);
        
        // Add close functionality
        const closeBtn = toast.querySelector('.toast-close');
        closeBtn.addEventListener('click', () => {
            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        });
        
        // Auto remove after 5 seconds
        setTimeout(() => {
            if (toast.parentNode) {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }
        }, 5000);
    }
};

// ===== Confetti Effect =====
const Confetti = {
    canvas: null,
    ctx: null,
    particles: [],
    animationId: null,
    
    init() {
        this.canvas = create('canvas', {
            className: 'confetti-canvas',
            style: 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;'
        });
        this.ctx = this.canvas.getContext('2d');
        document.body.appendChild(this.canvas);
        this.resize();
        window.addEventListener('resize', () => this.resize());
    },
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    },
    
    createParticles(count) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x: Math.random() * this.canvas.width,
                y: -20,
                width: Math.random() * 10 + 5,
                height: Math.random() * 10 + 5,
                speed: Math.random() * 3 + 2,
                angle: Math.random() * Math.PI * 2,
                angularVelocity: Math.random() * 0.2 - 0.1,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`
            });
        }
    },
    
    update() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        for (let i = 0; i < this.particles.length; i++) {
            const p = this.particles[i];
            
            p.y += p.speed;
            p.angle += p.angularVelocity;
            
            // Draw particle
            this.ctx.save();
            this.ctx.translate(p.x, p.y);
            this.ctx.rotate(p.angle);
            this.ctx.fillStyle = p.color;
            this.ctx.fillRect(-p.width/2, -p.height/2, p.width, p.height);
            this.ctx.restore();
            
            // Remove particles that are off screen
            if (p.y > this.canvas.height) {
                this.particles.splice(i, 1);
                i--;
            }
        }
        
        if (this.particles.length > 0) {
            this.animationId = requestAnimationFrame(() => this.update());
        }
    },
    
    start(duration = 3000) {
        this.createParticles(150);
        this.update();
        
        setTimeout(() => {
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }
            this.particles = [];
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }, duration);
    }
};

// ===== Data Management =====
let scores = {};
let achievements = {};
let settings = {
    theme: 'light',
    sound: true
};

const saveData = () => {
    try {
        localStorage.setItem('arcadeScores', JSON.stringify(scores));
        localStorage.setItem('arcadeAchievements', JSON.stringify(achievements));
        localStorage.setItem('arcadeSettings', JSON.stringify(settings));
    } catch (e) {
        console.warn('Could not save data to localStorage');
    }
};

const loadData = () => {
    try {
        const savedScores = localStorage.getItem('arcadeScores');
        const savedAchievements = localStorage.getItem('arcadeAchievements');
        const savedSettings = localStorage.getItem('arcadeSettings');
        
        if (savedScores) scores = JSON.parse(savedScores);
        if (savedAchievements) achievements = JSON.parse(savedAchievements);
        if (savedSettings) settings = JSON.parse(savedSettings);
    } catch (e) {
        console.warn('Could not load data from localStorage');
    }
};

// ===== Achievement System =====
const checkAchievement = (id, condition, data = {}) => {
    if (achievements[id]) return; // Already unlocked
    
    if (condition) {
        achievements[id] = {
            unlocked: true,
            timestamp: new Date().toISOString(),
            ...data
        };
        saveData();
        Toast.show(`Achievement Unlocked: ${getAchievementTitle(id)}!`, 'success');
        Confetti.start();
    }
};

const getAchievementTitle = (id) => {
    const titles = {
        'memory_master': 'Memory Master',
        'tic_master': 'Tic-Tac-Toe Master',
        'snake_first_apple': 'First Apple',
        'snake_100_score': 'Snake Expert',
        'whack_streak': 'Whack Streak',
        'flappy_10_score': 'Flappy Beginner',
        'space_invader': 'Space Defender',
        'breakout_master': 'Breakout Master',
        'reaction_speed': 'Lightning Fast'
    };
    return titles[id] || id;
};

// ===== Game Definitions =====
const games = {
    // Whack-a-Doodle Game
    whack: {
        id: 'whack',
        name: 'Whack-a-Doodle',
        description: 'Whack the doodles as they pop up!',
        icon: '🔨',
        init(container) {
            let score = 0;
            let timeLeft = 30;
            let gameActive = false;
            let timerInterval, popInterval;
            let highScore = scores.whack?.highScore || 0;
            let difficulty = 1000; // ms between doodle pops

            // Create game elements
            const gameElement = create('div', { className: 'whack-game' });
            
            const scoreElement = create('div', {
                className: 'whack-stat-item',
                textContent: `Score: ${score}`
            });
            
            const timeElement = create('div', {
                className: 'whack-stat-item',
                textContent: `Time: ${timeLeft}s`
            });
            
            const highScoreElement = create('div', {
                className: 'whack-stat-item',
                textContent: `High Score: ${highScore}`
            });
            
            const statsElement = create('div', { className: 'whack-stat' });
            statsElement.append(scoreElement, timeElement, highScoreElement);
            
            const startButton = create('button', {
                className: 'btn btn-primary',
                textContent: 'Start Game'
            });
            
            // Create holes
            const holes = [];
            const gameGrid = create('div', { className: 'whack-grid' });
            
            for (let i = 0; i < 9; i++) {
                const hole = create('div', { className: 'whack-hole' });
                const doodle = create('div', { className: 'whack-doodle' });
                doodle.innerHTML = '🤪';
                hole.appendChild(doodle);
                gameGrid.appendChild(hole);
                holes.push(hole);
                
                // Add click event to doodle
                doodle.addEventListener('click', () => {
                    if (!gameActive || !doodle.classList.contains('up')) return;
                    doodle.classList.remove('up');
                    score++;
                    scoreElement.textContent = `Score: ${score}`;
                    SoundManager.play('success');
                });
            }
            
            gameElement.append(statsElement, gameGrid, startButton);
            container.appendChild(gameElement);
            
            // Pop a doodle randomly
            const popDoodle = () => {
                // Reset all doodles
                holes.forEach(hole => {
                    hole.querySelector('.whack-doodle').classList.remove('up');
                });
                
                // Select a random hole
                const randomIndex = Math.floor(Math.random() * holes.length);
                const doodle = holes[randomIndex].querySelector('.whack-doodle');
                doodle.classList.add('up');
                
                // Remove after a short time
                setTimeout(() => {
                    if (doodle.classList.contains('up')) {
                        doodle.classList.remove('up');
                    }
                }, 800);
            };
            
            // Start game
            const startGame = () => {
                if (gameActive) return;
                
                score = 0;
                timeLeft = 30;
                gameActive = true;
                
                scoreElement.textContent = `Score: ${score}`;
                timeElement.textContent = `Time: ${timeLeft}s`;
                startButton.disabled = true;
                startButton.textContent = 'Game Running...';
                
                // Start timers
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timeElement.textContent = `Time: ${timeLeft}s`;
                    
                    if (timeLeft <= 0) {
                        endGame();
                    }
                }, 1000);
                
                popInterval = setInterval(popDoodle, difficulty);
                popDoodle(); // Start immediately
                SoundManager.play('click');
            };
            
            // End game
            const endGame = () => {
                gameActive = false;
                clearInterval(timerInterval);
                clearInterval(popInterval);
                startButton.disabled = false;
                startButton.textContent = 'Start Game';
                
                holes.forEach(hole => {
                    const doodle = hole.querySelector('.whack-doodle');
                    doodle.classList.remove('up');
                });
                
                if (score > highScore) {
                    highScore = score;
                    updateScores('whack', { highScore });
                    highScoreElement.textContent = `High Score: ${highScore} 🎉`;
                    Toast.show(`New High Score: ${highScore}!`, 'success');
                }
                SoundManager.play('error');
            };
            
            startButton.addEventListener('click', startGame);
            
            return {
                destroy() {
                    clearInterval(timerInterval);
                    clearInterval(popInterval);
                    container.innerHTML = '';
                },
                pause() {
                    if (gameActive) {
                        clearInterval(timerInterval);
                        clearInterval(popInterval);
                    }
                },
                resume() {
                    if (gameActive) {
                        timerInterval = setInterval(() => {
                            timeLeft--;
                            timeElement.textContent = `Time: ${timeLeft}s`;
                            if (timeLeft <= 0) {
                                endGame();
                            }
                        }, 1000);
                        popInterval = setInterval(popDoodle, difficulty);
                    }
                },
                restart() {
                    if (gameActive) {
                        endGame();
                    }
                    setTimeout(startGame, 100);
                }
            };
        }
    },
    
    // Memory Game
    memory: {
        id: 'memory',
        name: 'Memory Match',
        description: 'Match pairs of cards in the shortest time',
        icon: '🧠',
        init(container) {
            const symbols = ['😀', '😎', '🤩', '🥳', '😍', '🤪', '😜', '😇'];
            let gameBoard = [];
            let flippedCards = [];
            let matchedPairs = 0;
            let moves = 0;
            let timer = 0;
            let timerInterval;
            let gameActive = false;
            let bestTime = scores.memory?.bestTime || null;
            let bestMoves = scores.memory?.bestMoves || null;

            // Create game elements
            const gameElement = create('div', { className: 'memory-game' });
            
            const movesElement = create('div', {
                className: 'memory-stat',
                textContent: `Moves: ${moves}`
            });
            
            const timeElement = create('div', {
                className: 'memory-stat',
                textContent: `Time: ${timer}s`
            });
            
            const bestElement = create('div', {
                className: 'memory-stat',
                textContent: bestTime ? `Best: ${bestTime}s / ${bestMoves} moves` : 'Best: --'
            });
            
            const statsElement = create('div', { className: 'memory-stats' });
            statsElement.append(movesElement, timeElement, bestElement);
            
            const boardElement = create('div', { className: 'memory-board' });
            
            const startButton = create('button', {
                className: 'btn btn-primary',
                textContent: 'Start Game'
            });
            
            gameElement.append(statsElement, boardElement, startButton);
            container.appendChild(gameElement);
            
            // Initialize board
            const initBoard = () => {
                boardElement.innerHTML = '';
                gameBoard = [...symbols, ...symbols];
                gameBoard.sort(() => Math.random() - 0.5);
                flippedCards = [];
                matchedPairs = 0;
                
                gameBoard.forEach((symbol, index) => {
                    const card = create('div', {
                        className: 'memory-card',
                        innerHTML: `
                            <div class="memory-card-inner">
                                <div class="memory-card-front">?</div>
                                <div class="memory-card-back">${symbol}</div>
                            </div>
                        `
                    });
                    
                    card.addEventListener('click', () => flipCard(card, index));
                    boardElement.appendChild(card);
                });
            };
            
            // Flip card
            const flipCard = (card, index) => {
                if (!gameActive || flippedCards.length >= 2 || card.classList.contains('flipped')) return;
                
                card.classList.add('flipped');
                flippedCards.push(index);
                
                if (flippedCards.length === 2) {
                    moves++;
                    movesElement.textContent = `Moves: ${moves}`;
                    checkMatch();
                }
            };
            
            // Check for match
            const checkMatch = () => {
                const [firstIndex, secondIndex] = flippedCards;
                const firstCard = boardElement.children[firstIndex];
                const secondCard = boardElement.children[secondIndex];
                
                if (gameBoard[firstIndex] === gameBoard[secondIndex]) {
                    // Match
                    matchedPairs++;
                    flippedCards = [];
                    SoundManager.play('success');
                    
                    if (matchedPairs === symbols.length) {
                        endGame();
                    }
                } else {
                    // No match
                    setTimeout(() => {
                        firstCard.classList.remove('flipped');
                        secondCard.classList.remove('flipped');
                        flippedCards = [];
                    }, 1000);
                }
            };
            
            // Start game
            const startGame = () => {
                if (gameActive) return;
                
                gameActive = true;
                flippedCards = [];
                matchedPairs = 0;
                moves = 0;
                timer = 0;
                
                movesElement.textContent = `Moves: ${moves}`;
                timeElement.textContent = `Time: ${timer}s`;
                startButton.textContent = 'Restart Game';
                
                initBoard();
                
                // Start timer
                timerInterval = setInterval(() => {
                    timer++;
                    timeElement.textContent = `Time: ${timer}s`;
                }, 1000);
                
                SoundManager.play('click');
            };
            
            // End game
            const endGame = () => {
                gameActive = false;
                clearInterval(timerInterval);
                
                // Update best scores
                let newBest = false;
                if (!bestTime || timer < bestTime) {
                    bestTime = timer;
                    newBest = true;
                }
                if (!bestMoves || moves < bestMoves) {
                    bestMoves = moves;
                    newBest = true;
                }
                
                if (newBest) {
                    updateScores('memory', { bestTime, bestMoves });
                    bestElement.textContent = `Best: ${bestTime}s / ${bestMoves} moves 🎉`;
                    Toast.show(`New Best Score: ${bestTime}s with ${bestMoves} moves!`, 'success');
                } else {
                    bestElement.textContent = `Best: ${bestTime}s / ${bestMoves} moves`;
                }
                
                // Check achievements
                checkAchievement('memory_master', moves <= 20, { moves });
                SoundManager.play('success');
            };
            
            startButton.addEventListener('click', startGame);
            
            // Initialize the board
            initBoard();
            
            return {
                destroy() {
                    clearInterval(timerInterval);
                    container.innerHTML = '';
                },
                pause() {
                    if (gameActive) {
                        clearInterval(timerInterval);
                    }
                },
                resume() {
                    if (gameActive) {
                        timerInterval = setInterval(() => {
                            timer++;
                            timeElement.textContent = `Time: ${timer}s`;
                        }, 1000);
                    }
                },
                restart() {
                    if (gameActive) {
                        clearInterval(timerInterval);
                    }
                    setTimeout(startGame, 100);
                }
            };
        }
    },
    
    // Dice Game
    dice: {
        id: 'dice',
        name: 'Dice Guessing',
        description: 'Guess if the next roll will be higher or lower',
        icon: '🎲',
        init(container) {
            let currentNumber = 0;
            let score = 0;
            let highScore = scores.dice?.highScore || 0;
            let gameActive = false;

            // Create game elements
            const gameElement = create('div', { className: 'dice-game' });
            
            const diceElement = create('div', {
                className: 'dice-display',
                textContent: '?'
            });
            
            const scoreElement = create('div', {
                className: 'dice-stat',
                textContent: `Score: ${score}`
            });
            
            const highScoreElement = create('div', {
                className: 'dice-stat',
                textContent: `High Score: ${highScore}`
            });
            
            const statsElement = create('div', { className: 'dice-stats' });
            statsElement.append(scoreElement, highScoreElement);
            
            const higherButton = create('button', {
                className: 'btn btn-primary',
                textContent: 'Higher'
            });
            
            const lowerButton = create('button', {
                className: 'btn btn-secondary',
                textContent: 'Lower'
            });
            
            const startButton = create('button', {
                className: 'btn btn-success',
                textContent: 'Roll Dice'
            });
            
            const controlsElement = create('div', { className: 'dice-controls' });
            controlsElement.append(higherButton, lowerButton, startButton);
            
            gameElement.append(diceElement, statsElement, controlsElement);
            container.appendChild(gameElement);
            
            // Roll dice
            const rollDice = () => {
                return Math.floor(Math.random() * 6) + 1;
            };
            
            // Start game
            const startGame = () => {
                if (gameActive) return;
                
                gameActive = true;
                currentNumber = rollDice();
                diceElement.textContent = currentNumber;
                startButton.textContent = 'Roll Again';
                higherButton.disabled = false;
                lowerButton.disabled = false;
                SoundManager.play('click');
            };
            
            // Make guess
            const makeGuess = (isHigher) => {
                if (!gameActive) return;
                
                const newNumber = rollDice();
                diceElement.textContent = newNumber;
                
                const isCorrect = isHigher ? newNumber > currentNumber : newNumber < currentNumber;
                
                if (isCorrect) {
                    score++;
                    scoreElement.textContent = `Score: ${score}`;
                    currentNumber = newNumber;
                    SoundManager.play('success');
                    
                    // Check achievements
                    if (score >= 5) {
                        checkAchievement('dice_master', true);
                    }
                } else {
                    endGame();
                }
            };
            
            // End game
            const endGame = () => {
                gameActive = false;
                higherButton.disabled = true;
                lowerButton.disabled = true;
                startButton.textContent = 'Game Over! Roll Dice';
                
                if (score > highScore) {
                    highScore = score;
                    updateScores('dice', { highScore });
                    highScoreElement.textContent = `High Score: ${highScore} 🎉`;
                    Toast.show(`New High Score: ${highScore}!`, 'success');
                }
                SoundManager.play('error');
            };
            
            // Event listeners
            startButton.addEventListener('click', startGame);
            higherButton.addEventListener('click', () => makeGuess(true));
            lowerButton.addEventListener('click', () => makeGuess(false));
            
            return {
                destroy() {
                    container.innerHTML = '';
                },
                pause() {},
                resume() {},
                restart() {
                    score = 0;
                    scoreElement.textContent = `Score: ${score}`;
                    diceElement.textContent = '?';
                    startButton.textContent = 'Roll Dice';
                    gameActive = false;
                }
            };
        }
    },
    
    // Shaikh's Runner Game
    runner: {
        id: 'runner',
        name: "Shaikh's Runner",
        description: 'Jump over obstacles in this endless runner',
        icon: '🏃',
        init(container) {
            let canvas, ctx;
            const gameState = {
                player: {
                    x: 50,
                    y: 130,
                    width: 30,
                    height: 50,
                    jumping: false,
                    velocityY: 0,
                    gravity: 0.5,
                    jumpForce: -12
                },
                obstacles: [],
                score: 0,
                gameActive: false,
                lastTime: 0,
                animationId: null,
                obstacleSpawnTimer: 0,
                obstacleSpawnInterval: 1500, // ms
                speed: 3
            };
            
            let highScore = scores.runner?.highScore || 0;

            // Create game elements
            const gameElement = create('div', { className: 'runner-game' });
            
            const canvasContainer = create('div', { className: 'runner-canvas-container' });
            canvas = create('canvas', {
                className: 'runner-canvas',
                width: 400,
                height: 200
            });
            ctx = canvas.getContext('2d');
            canvasContainer.appendChild(canvas);
            
            const scoreElement = create('div', {
                className: 'runner-stat',
                textContent: `Score: ${gameState.score} | High Score: ${highScore}`
            });
            
            const controlsElement = create('div', { className: 'runner-controls' });
            const startButton = create('button', {
                className: 'btn btn-primary',
                textContent: 'Start Game'
            });
            
            const jumpButton = create('button', {
                className: 'btn btn-secondary',
                textContent: 'Jump (Space)'
            });
            
            controlsElement.append(startButton, jumpButton);
            gameElement.append(canvasContainer, scoreElement, controlsElement);
            container.appendChild(gameElement);
            
            // Initialize game
            gameState.init = () => {
                gameState.reset();
                gameState.resizeCanvas();
                window.addEventListener('resize', () => gameState.resizeCanvas());
            };
            
            // Reset game state
            gameState.reset = () => {
                gameState.player.y = 130;
                gameState.player.jumping = false;
                gameState.player.velocityY = 0;
                gameState.obstacles = [];
                gameState.score = 0;
                gameState.gameActive = false;
                gameState.lastTime = 0;
                gameState.obstacleSpawnTimer = 0;
                scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore}`;
                
                if (gameState.animationId) {
                    cancelAnimationFrame(gameState.animationId);
                    gameState.animationId = null;
                }
            };
            
            // Resize canvas
            gameState.resizeCanvas = () => {
                const containerWidth = canvasContainer.clientWidth;
                const scale = containerWidth / canvas.width;
                canvas.style.transform = `scale(${scale})`;
                canvas.style.transformOrigin = 'top left';
            };
            
            // Jump
            gameState.jump = () => {
                if (gameState.gameActive && !gameState.player.jumping) {
                    gameState.player.velocityY = gameState.player.jumpForce;
                    gameState.player.jumping = true;
                    SoundManager.play('click');
                }
            };
            
            // Update game state
            gameState.update = (currentTime = 0) => {
                if (!gameState.gameActive) return;
                
                const deltaTime = currentTime - gameState.lastTime;
                gameState.lastTime = currentTime;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#E0F7FA');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw ground
                ctx.fillStyle = '#8BC34A';
                ctx.fillRect(0, 180, canvas.width, 20);
                
                // Update player
                gameState.player.velocityY += gameState.player.gravity;
                gameState.player.y += gameState.player.velocityY;
                
                // Ground collision
                if (gameState.player.y > 130) {
                    gameState.player.y = 130;
                    gameState.player.jumping = false;
                    gameState.player.velocityY = 0;
                }
                
                // Draw player
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(
                    gameState.player.x,
                    gameState.player.y,
                    gameState.player.width,
                    gameState.player.height
                );
                
                // Spawn obstacles
                gameState.obstacleSpawnTimer += deltaTime;
                if (gameState.obstacleSpawnTimer > gameState.obstacleSpawnInterval) {
                    gameState.obstacles.push({
                        x: canvas.width,
                        y: 150,
                        width: 20,
                        height: 30
                    });
                    gameState.obstacleSpawnTimer = 0;
                    
                    // Increase difficulty
                    if (gameState.obstacleSpawnInterval > 800) {
                        gameState.obstacleSpawnInterval -= 10;
                    }
                }
                
                // Update obstacles
                for (let i = 0; i < gameState.obstacles.length; i++) {
                    const obstacle = gameState.obstacles[i];
                    obstacle.x -= gameState.speed;
                    
                    // Draw obstacle
                    ctx.fillStyle = '#795548';
                    ctx.fillRect(
                        obstacle.x,
                        obstacle.y,
                        obstacle.width,
                        obstacle.height
                    );
                    
                    // Check collision
                    if (
                        gameState.player.x < obstacle.x + obstacle.width &&
                        gameState.player.x + gameState.player.width > obstacle.x &&
                        gameState.player.y < obstacle.y + obstacle.height &&
                        gameState.player.y + gameState.player.height > obstacle.y
                    ) {
                        endGame();
                        return;
                    }
                    
                    // Remove off-screen obstacles
                    if (obstacle.x + obstacle.width < 0) {
                        gameState.obstacles.splice(i, 1);
                        i--;
                        gameState.score++;
                        scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore}`;
                    }
                }
                
                // Continue animation loop
                gameState.animationId = requestAnimationFrame((time) => gameState.update(time));
            };
            
            // Start game
            const startGame = () => {
                if (gameState.gameActive) return;
                
                gameState.reset();
                gameState.gameActive = true;
                gameState.lastTime = performance.now();
                gameState.update();
                SoundManager.play('click');
            };
            
            // End game
            const endGame = () => {
                gameState.gameActive = false;
                if (gameState.animationId) {
                    cancelAnimationFrame(gameState.animationId);
                }
                
                if (gameState.score > highScore) {
                    highScore = gameState.score;
                    updateScores('runner', { highScore });
                    scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore} 🎉`;
                    Toast.show(`New High Score: ${highScore}!`, 'success');
                }
                
                SoundManager.play('error');
            };
            
            // Handle keyboard input
            const handleKeyDown = (e) => {
                if (e.code === 'Space') {
                    gameState.jump();
                    e.preventDefault();
                }
            };
            
            document.addEventListener('keydown', handleKeyDown);
            jumpButton.addEventListener('click', gameState.jump);
            startButton.addEventListener('click', startGame);
            
            // Initialize game
            gameState.init();
            
            return {
                destroy() {
                    document.removeEventListener('keydown', handleKeyDown);
                    if (gameState.animationId) {
                        cancelAnimationFrame(gameState.animationId);
                    }
                    container.innerHTML = '';
                },
                pause() {
                    if (gameState.gameActive) {
                        gameState.gameActive = false;
                        if (gameState.animationId) {
                            cancelAnimationFrame(gameState.animationId);
                        }
                    }
                },
                resume() {
                    if (!gameState.gameActive) {
                        gameState.gameActive = true;
                        gameState.lastTime = performance.now();
                        gameState.update();
                    }
                },
                restart() {
                    endGame();
                    setTimeout(startGame, 100);
                }
            };
        }
    },
    
    // Tic Tac Toe Game
    tictactoe: {
        id: 'tictactoe',
        name: 'Tic Tac Toe',
        description: 'Classic game of X and O',
        icon: '❌',
        init(container) {
            let gameBoard = Array(9).fill('');
            let currentPlayer = 'X';
            let gameActive = true;
            let playerScore = scores.tictactoe?.playerWins || 0;
            let aiScore = scores.tictactoe?.aiWins || 0;
            let draws = scores.tictactoe?.draws || 0;
            let isTwoPlayer = false;

            // Create game elements
            const gameElement = create('div', { className: 'tictactoe-game' });
            
            const modeSelector = create('div', { className: 'tictactoe-mode' });
            const modeLabel = create('span', { textContent: 'Mode: ' });
            const onePButton = create('button', {
                className: 'btn btn-primary active',
                textContent: '1 Player'
            });
            const twoPButton = create('button', {
                className: 'btn btn-secondary',
                textContent: '2 Players'
            });
            
            onePButton.addEventListener('click', () => {
                isTwoPlayer = false;
                onePButton.classList.add('active');
                twoPButton.classList.remove('active');
                restartGame();
            });
            
            twoPButton.addEventListener('click', () => {
                isTwoPlayer = true;
                twoPButton.classList.add('active');
                onePButton.classList.remove('active');
                restartGame();
            });
            
            modeSelector.append(modeLabel, onePButton, twoPButton);
            
            const boardElement = create('div', { className: 'tictactoe-board' });
            const cells = [];
            
            for (let i = 0; i < 9; i++) {
                const cell = create('div', { className: 'tictactoe-cell' });
                cell.addEventListener('click', () => handleCellClick(i));
                boardElement.appendChild(cell);
                cells.push(cell);
            }
            
            const statusElement = create('div', {
                className: 'tictactoe-status',
                textContent: isTwoPlayer ? 
                    `Player ${currentPlayer}'s turn` : 
                    `Player ${currentPlayer}'s turn`
            });
            
            const scoreElement = create('div', { className: 'tictactoe-score' });
            const scoreX = create('div', { 
                className: 'tictactoe-score-item',
                innerHTML: `<div class="tictactoe-score-label">Player X</div><div class="tictactoe-score-value">${playerScore}</div>`
            });
            const scoreO = create('div', { 
                className: 'tictactoe-score-item',
                innerHTML: `<div class="tictactoe-score-label">Player O${isTwoPlayer ? '' : ' (AI)'}</div><div class="tictactoe-score-value">${aiScore}</div>`
            });
            const scoreDraw = create('div', { 
                className: 'tictactoe-score-item',
                innerHTML: `<div class="tictactoe-score-label">Draws</div><div class="tictactoe-score-value">${draws}</div>`
            });
            scoreElement.append(scoreX, scoreO, scoreDraw);
            
            const restartButton = create('button', {
                className: 'btn btn-primary',
                textContent: 'Restart Game'
            });
            
            gameElement.append(modeSelector, boardElement, statusElement, scoreElement, restartButton);
            container.appendChild(gameElement);
            
            // Handle cell click
            const handleCellClick = (index) => {
                if (!gameActive || gameBoard[index] !== '') return;
                
                gameBoard[index] = currentPlayer;
                cells[index].textContent = currentPlayer;
                cells[index].classList.add(`player-${currentPlayer}`);
                
                const result = checkGameState();
                if (result) {
                    handleGameEnd(result);
                } else {
                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                    statusElement.textContent = isTwoPlayer ? 
                        `Player ${currentPlayer}'s turn` : 
                        `Player ${currentPlayer}'s turn`;
                    
                    // AI move if in 1-player mode
                    if (!isTwoPlayer && currentPlayer === 'O' && gameActive) {
                        setTimeout(makeAIMove, 500);
                    }
                }
            };
            
            // Make AI move
            const makeAIMove = () => {
                if (!gameActive) return;
                
                let move;
                // Simple AI - try to win, block player, or random
                move = getBestMove();
                
                if (move !== null) {
                    handleCellClick(move);
                }
            };
            
            // Minimax algorithm for AI
            const minimax = (board, depth, isMaximizing) => {
                const result = checkGameState();
                
                if (result === 'X') return -10 + depth;
                if (result === 'O') return 10 - depth;
                if (result === 'draw') return 0;
                
                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === '') {
                            board[i] = 'O';
                            const score = minimax(board, depth + 1, false);
                            board[i] = '';
                            bestScore = Math.max(score, bestScore);
                        }
                    }
                    return bestScore;
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === '') {
                            board[i] = 'X';
                            const score = minimax(board, depth + 1, true);
                            board[i] = '';
                            bestScore = Math.min(score, bestScore);
                        }
                    }
                    return bestScore;
                }
            };
            
            // Get best move for AI
            const getBestMove = () => {
                let bestScore = -Infinity;
                let bestMove = null;
                
                for (let i = 0; i < 9; i++) {
                    if (gameBoard[i] === '') {
                        gameBoard[i] = 'O';
                        const score = minimax(gameBoard, 0, false);
                        gameBoard[i] = '';
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = i;
                        }
                    }
                }
                return bestMove;
            };
            
            // Check game state (win, draw, or ongoing)
            const checkGameState = () => {
                const winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                    [0, 4, 8], [2, 4, 6] // diagonals
                ];
                
                // Check for win
                for (const pattern of winPatterns) {
                    const [a, b, c] = pattern;
                    if (gameBoard[a] && gameBoard[a] === gameBoard[b] && gameBoard[a] === gameBoard[c]) {
                        return gameBoard[a]; // Return the winning player
                    }
                }
                
                // Check for draw
                if (!gameBoard.includes('')) {
                    return 'draw';
                }
                
                // Game ongoing
                return null;
            };
            
            // Handle game end
            const handleGameEnd = (result) => {
                gameActive = false;
                
                if (result === 'draw') {
                    statusElement.textContent = "It's a draw!";
                    draws++;
                    updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                    checkAchievement('tic_master', draws >= 10, { draws });
                } else {
                    statusElement.textContent = `Player ${result} wins!`;
                    if (result === 'X') {
                        playerScore++;
                        updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                    } else {
                        if (isTwoPlayer) {
                            playerScore++; // Player O in 2P mode
                            updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                        } else {
                            aiScore++; // AI wins
                            updateScores('tictactoe', { playerWins: playerScore, aiWins: aiScore, draws: draws });
                        }
                    }
                }
                
                // Update score display
                scoreX.querySelector('.tictactoe-score-value').textContent = playerScore;
                scoreO.querySelector('.tictactoe-score-value').textContent = aiScore;
                scoreDraw.querySelector('.tictactoe-score-value').textContent = draws;
                
                SoundManager.play(result === 'draw' ? 'error' : 'success');
            };
            
            // Restart game
            const restartGame = () => {
                gameBoard = Array(9).fill('');
                currentPlayer = 'X';
                gameActive = true;
                statusElement.textContent = isTwoPlayer ? 
                    `Player ${currentPlayer}'s turn` : 
                    `Player ${currentPlayer}'s turn`;
                
                cells.forEach(cell => {
                    cell.textContent = '';
                    cell.className = 'tictactoe-cell';
                });
            };
            
            restartButton.addEventListener('click', restartGame);
            
            return {
                destroy() {
                    container.innerHTML = '';
                },
                pause() {},
                resume() {},
                restart: restartGame
            };
        }
    },
    
    // Breakout Game
    breakout: {
        id: 'breakout',
        name: 'Breakout',
        description: 'Break all the bricks with the ball',
        icon: '🔨',
        init(container) {
            let canvas, ctx;
            const gameState = {
                ball: {
                    x: 200,
                    y: 150,
                    radius: 8,
                    dx: 4,
                    dy: -4
                },
                paddle: {
                    x: 150,
                    y: 180,
                    width: 100,
                    height: 10,
                    dx: 0,
                    speed: 8
                },
                bricks: [],
                score: 0,
                lives: 3,
                gameActive: false,
                lastTime: 0,
                animationId: null,
                brickRowCount: 3,
                brickColumnCount: 5,
                brickWidth: 70,
                brickHeight: 20,
                brickPadding: 10,
                brickOffsetTop: 30,
                brickOffsetLeft: 30
            };
            
            let highScore = scores.breakout?.highScore || 0;

            // Create game elements
            const gameElement = create('div', { className: 'breakout-game' });
            
            const canvasContainer = create('div', { className: 'breakout-canvas-container' });
            canvas = create('canvas', {
                className: 'breakout-canvas',
                width: 400,
                height: 200
            });
            ctx = canvas.getContext('2d');
            canvasContainer.appendChild(canvas);
            
            const scoreElement = create('div', {
                className: 'breakout-stat',
                textContent: `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore}`
            });
            
            const controlsElement = create('div', { className: 'breakout-controls' });
            const startButton = create('button', {
                className: 'btn btn-primary',
                textContent: 'Start Game'
            });
            
            controlsElement.appendChild(startButton);
            gameElement.append(canvasContainer, scoreElement, controlsElement);
            container.appendChild(gameElement);
            
            // Initialize bricks
            const initBricks = () => {
                gameState.bricks = [];
                for (let c = 0; c < gameState.brickColumnCount; c++) {
                    gameState.bricks[c] = [];
                    for (let r = 0; r < gameState.brickRowCount; r++) {
                        gameState.bricks[c][r] = { x: 0, y: 0, status: 1 };
                    }
                }
            };
            
            // Draw ball
            const drawBall = () => {
                ctx.beginPath();
                ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FF5722';
                ctx.fill();
                ctx.closePath();
            };
            
            // Draw paddle
            const drawPaddle = () => {
                ctx.beginPath();
                ctx.rect(
                    gameState.paddle.x,
                    gameState.paddle.y,
                    gameState.paddle.width,
                    gameState.paddle.height
                );
                ctx.fillStyle = '#2196F3';
                ctx.fill();
                ctx.closePath();
            };
            
            // Draw bricks
            const drawBricks = () => {
                for (let c = 0; c < gameState.brickColumnCount; c++) {
                    for (let r = 0; r < gameState.brickRowCount; r++) {
                        if (gameState.bricks[c][r].status === 1) {
                            const brickX = c * (gameState.brickWidth + gameState.brickPadding) + gameState.brickOffsetLeft;
                            const brickY = r * (gameState.brickHeight + gameState.brickPadding) + gameState.brickOffsetTop;
                            gameState.bricks[c][r].x = brickX;
                            gameState.bricks[c][r].y = brickY;
                            
                            ctx.beginPath();
                            ctx.rect(brickX, brickY, gameState.brickWidth, gameState.brickHeight);
                            ctx.fillStyle = '#4CAF50';
                            ctx.fill();
                            ctx.closePath();
                        }
                    }
                }
            };
            
            // Collision detection
            const collisionDetection = () => {
                for (let c = 0; c < gameState.brickColumnCount; c++) {
                    for (let r = 0; r < gameState.brickRowCount; r++) {
                        const brick = gameState.bricks[c][r];
                        if (brick.status === 1) {
                            if (
                                gameState.ball.x > brick.x &&
                                gameState.ball.x < brick.x + gameState.brickWidth &&
                                gameState.ball.y > brick.y &&
                                gameState.ball.y < brick.y + gameState.brickHeight
                            ) {
                                gameState.ball.dy = -gameState.ball.dy;
                                brick.status = 0;
                                gameState.score += 10;
                                scoreElement.textContent = `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore}`;
                                
                                // Check if all bricks are broken
                                let allBroken = true;
                                for (let i = 0; i < gameState.brickColumnCount; i++) {
                                    for (let j = 0; j < gameState.brickRowCount; j++) {
                                        if (gameState.bricks[i][j].status === 1) {
                                            allBroken = false;
                                            break;
                                        }
                                    }
                                    if (!allBroken) break;
                                }
                                
                                if (allBroken) {
                                    // Level complete
                                    initBricks();
                                    gameState.ball.x = 200;
                                    gameState.ball.y = 150;
                                    gameState.ball.dx = 4;
                                    gameState.ball.dy = -4;
                                    checkAchievement('breakout_master', true);
                                }
                                
                                SoundManager.play('success');
                            }
                        }
                    }
                }
            };
            
            // Update game state
            gameState.update = (currentTime = 0) => {
                if (!gameState.gameActive) return;
                
                const deltaTime = currentTime - gameState.lastTime;
                gameState.lastTime = currentTime;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw game objects
                drawBricks();
                drawBall();
                drawPaddle();
                collisionDetection();
                
                // Move ball
                gameState.ball.x += gameState.ball.dx;
                gameState.ball.y += gameState.ball.dy;
                
                // Wall collision (left/right)
                if (
                    gameState.ball.x + gameState.ball.dx > canvas.width - gameState.ball.radius ||
                    gameState.ball.x + gameState.ball.dx < gameState.ball.radius
                ) {
                    gameState.ball.dx = -gameState.ball.dx;
                }
                
                // Wall collision (top)
                if (gameState.ball.y + gameState.ball.dy < gameState.ball.radius) {
                    gameState.ball.dy = -gameState.ball.dy;
                }
                // Paddle collision
                else if (
                    gameState.ball.y + gameState.ball.dy > canvas.height - gameState.ball.radius - gameState.paddle.height
                ) {
                    if (
                        gameState.ball.x > gameState.paddle.x &&
                        gameState.ball.x < gameState.paddle.x + gameState.paddle.width
                    ) {
                        // Change ball direction based on where it hits the paddle
                        const hitPosition = (gameState.ball.x - gameState.paddle.x) / gameState.paddle.width;
                        const angle = (hitPosition - 0.5) * Math.PI; // -π/2 to π/2
                        const speed = Math.sqrt(
                            gameState.ball.dx * gameState.ball.dx +
                            gameState.ball.dy * gameState.ball.dy
                        );
                        gameState.ball.dx = speed * Math.sin(angle);
                        gameState.ball.dy = -speed * Math.cos(angle);
                    }
                }
                
                // Bottom wall (lose life)
                if (gameState.ball.y + gameState.ball.dy > canvas.height - gameState.ball.radius) {
                    gameState.lives--;
                    scoreElement.textContent = `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore}`;
                    
                    if (gameState.lives <= 0) {
                        endGame();
                        return;
                    } else {
                        // Reset ball and paddle
                        gameState.ball.x = 200;
                        gameState.ball.y = 150;
                        gameState.ball.dx = 4;
                        gameState.ball.dy = -4;
                        gameState.paddle.x = 150;
                    }
                }
                
                // Move paddle
                gameState.paddle.x += gameState.paddle.dx;
                
                // Paddle boundary
                if (
                    gameState.paddle.x < 0 ||
                    gameState.paddle.x + gameState.paddle.width > canvas.width
                ) {
                    gameState.paddle.x = Math.max(
                        0,
                        Math.min(canvas.width - gameState.paddle.width, gameState.paddle.x)
                    );
                }
                
                // Continue animation loop
                gameState.animationId = requestAnimationFrame((time) => gameState.update(time));
            };
            
            // Start game
            const startGame = () => {
                if (gameState.gameActive) return;
                
                gameState.ball.x = 200;
                gameState.ball.y = 150;
                gameState.ball.dx = 4;
                gameState.ball.dy = -4;
                gameState.paddle.x = 150;
                gameState.score = 0;
                gameState.lives = 3;
                gameState.gameActive = true;
                scoreElement.textContent = `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore}`;
                initBricks();
                gameState.lastTime = performance.now();
                gameState.update();
                SoundManager.play('click');
            };
            
            // End game
            const endGame = () => {
                gameState.gameActive = false;
                if (gameState.animationId) {
                    cancelAnimationFrame(gameState.animationId);
                }
                
                if (gameState.score > highScore) {
                    highScore = gameState.score;
                    updateScores('breakout', { highScore });
                    scoreElement.textContent = `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore} 🎉`;
                    Toast.show(`New High Score: ${highScore}!`, 'success');
                }
                
                SoundManager.play('error');
            };
            
            // Handle keyboard input
            const keys = {};
            const handleKeyDown = (e) => {
                keys[e.key] = true;
                
                if (e.key === 'ArrowLeft') {
                    gameState.paddle.dx = -gameState.paddle.speed;
                } else if (e.key === 'ArrowRight') {
                    gameState.paddle.dx = gameState.paddle.speed;
                }
            };
            
            const handleKeyUp = (e) => {
                keys[e.key] = false;
                
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    gameState.paddle.dx = 0;
                }
            };
            
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            startButton.addEventListener('click', startGame);
            
            // Initialize bricks
            initBricks();
            
            return {
                destroy() {
                    document.removeEventListener('keydown', handleKeyDown);
                    document.removeEventListener('keyup', handleKeyUp);
                    if (gameState.animationId) {
                        cancelAnimationFrame(gameState.animationId);
                    }
                    container.innerHTML = '';
                },
                pause() {
                    if (gameState.gameActive) {
                        gameState.gameActive = false;
                        if (gameState.animationId) {
                            cancelAnimationFrame(gameState.animationId);
                        }
                    }
                },
                resume() {
                    if (!gameState.gameActive) {
                        gameState.gameActive = true;
                        gameState.lastTime = performance.now();
                        gameState.update();
                    }
                },
                restart() {
                    endGame();
                    setTimeout(startGame, 100);
                }
            };
        }
    },
    
    // Reaction Time Game
    reaction: {
        id: 'reaction',
        name: 'Reaction Time',
        description: 'Test your reaction speed!',
        icon: '⏱️',
        init(container) {
            let gameState = 'ready'; // 'ready', 'wait', 'go', 'result'
            let startTime = 0;
            let attempts = 0;
            let bestTime = scores.reaction?.bestTime || null;

            // Create game elements
            const gameElement = create('div', { className: 'reaction-game' });
            
            const displayElement = create('div', {
                className: 'reaction-display reaction-ready',
                textContent: 'Click or tap when screen turns green!'
            });
            
            const resultElement = create('div', {
                className: 'reaction-result',
                textContent: ' '
            });
            
            const attemptsElement = create('div', {
                className: 'reaction-attempts',
                textContent: `Attempts: ${attempts} | Best: ${bestTime ? bestTime + 'ms' : '--'}`
            });
            
            gameElement.append(displayElement, resultElement, attemptsElement);
            container.appendChild(gameElement);
            
            // Handle display click
            displayElement.addEventListener('click', () => {
                if (gameState === 'ready') {
                    // Start waiting phase
                    gameState = 'wait';
                    displayElement.className = 'reaction-display reaction-wait';
                    displayElement.textContent = 'Wait for green...';
                    resultElement.textContent = ' ';
                    
                    // Random delay before green
                    const delay = Math.random() * 3000 + 2000; // 2-5 seconds
                    setTimeout(() => {
                        if (gameState === 'wait') {
                            gameState = 'go';
                            displayElement.className = 'reaction-display reaction-go';
                            displayElement.textContent = 'CLICK NOW!';
                            startTime = performance.now();
                        }
                    }, delay);
                    SoundManager.play('click');
                } else if (gameState === 'go') {
                    // Player clicked during green phase
                    const endTime = performance.now();
                    const reactionTime = Math.round(endTime - startTime);
                    
                    gameState = 'result';
                    displayElement.className = 'reaction-display reaction-ready';
                    displayElement.textContent = 'Click or tap when screen turns green!';
                    resultElement.textContent = `Reaction Time: ${reactionTime}ms`;
                    
                    attempts++;
                    
                    if (!bestTime || reactionTime < bestTime) {
                        bestTime = reactionTime;
                        updateScores('reaction', { bestTime });
                        Toast.show(`New Best Time: ${bestTime}ms!`, 'success');
                        checkAchievement('reaction_speed', bestTime < 200, { time: bestTime });
                    }
                    
                    attemptsElement.textContent = `Attempts: ${attempts} | Best: ${bestTime}ms`;
                    SoundManager.play('success');
                } else if (gameState === 'wait') {
                    // Player clicked too early
                    gameState = 'result';
                    displayElement.className = 'reaction-display reaction-ready';
                    displayElement.textContent = 'Too early! Click to try again.';
                    resultElement.textContent = 'You clicked too early!';
                    
                    attempts++;
                    attemptsElement.textContent = `Attempts: ${attempts} | Best: ${bestTime ? bestTime + 'ms' : '--'}`;
                    SoundManager.play('error');
                }
            });
            
            return {
                destroy() {
                    container.innerHTML = '';
                },
                pause() {
                    // Pause logic if needed
                },
                resume() {
                    // Resume logic if needed
                },
                restart() {
                    gameState = 'ready';
                    displayElement.className = 'reaction-display reaction-ready';
                    displayElement.textContent = 'Click or tap when screen turns green!';
                    resultElement.textContent = ' ';
                    attempts = 0;
                    attemptsElement.textContent = `Attempts: ${attempts} | Best: ${bestTime ? bestTime + 'ms' : '--'}`;
                }
            };
        }
    },
    
    // Space Invaders Game
    space: {
        id: 'space',
        name: 'Space Invaders',
        description: 'Defend Earth from alien invasion',
        icon: '👾',
        init(container) {
            let canvas, ctx;
            const gameState = {
                player: {
                    x: 185,
                    y: 180,
                    width: 30,
                    height: 20,
                    speed: 5
                },
                bullets: [],
                enemies: [],
                score: 0,
                lives: 3,
                gameActive: false,
                lastTime: 0,
                animationId: null,
                enemyDirection: 1,
                enemySpeed: 1,
                enemyDrop: 10
            };
            
            let highScore = scores.space?.highScore || 0;

            // Create game elements
            const gameElement = create('div', { className: 'space-game' });
            
            const canvasContainer = create('div', { className: 'space-canvas-container' });
            canvas = create('canvas', {
                className: 'space-canvas',
                width: 400,
                height: 200
            });
            ctx = canvas.getContext('2d');
            canvasContainer.appendChild(canvas);
            
            const scoreElement = create('div', {
                className: 'space-stat',
                textContent: `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore}`
            });
            
            const controlsElement = create('div', { className: 'space-controls' });
            const startButton = create('button', {
                className: 'btn btn-primary',
                textContent: 'Start Game'
            });
            
            controlsElement.appendChild(startButton);
            gameElement.append(canvasContainer, scoreElement, controlsElement);
            container.appendChild(gameElement);
            
            // Initialize enemies
            const initEnemies = () => {
                gameState.enemies = [];
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 8; col++) {
                        gameState.enemies.push({
                            x: col * 40 + 40,
                            y: row * 30 + 30,
                            width: 30,
                            height: 20
                        });
                    }
                }
            };
            
            // Draw player
            const drawPlayer = () => {
                ctx.fillStyle = '#2196F3';
                ctx.fillRect(
                    gameState.player.x,
                    gameState.player.y,
                    gameState.player.width,
                    gameState.player.height
                );
                
                // Draw simple ship details
                ctx.fillStyle = '#BBDEFB';
                ctx.fillRect(
                    gameState.player.x + 10,
                    gameState.player.y - 5,
                    10,
                    5
                );
            };
            
            // Draw bullets
            const drawBullets = () => {
                ctx.fillStyle = '#FFEB3B';
                gameState.bullets.forEach(bullet => {
                    ctx.fillRect(bullet.x, bullet.y, 3, 10);
                });
            };
            
            // Draw enemies
            const drawEnemies = () => {
                ctx.fillStyle = '#F44336';
                gameState.enemies.forEach(enemy => {
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    
                    // Draw simple enemy details
                    ctx.fillStyle = '#FFCDD2';
                    ctx.fillRect(enemy.x + 5, enemy.y + 5, 5, 5);
                    ctx.fillRect(enemy.x + 20, enemy.y + 5, 5, 5);
                    ctx.fillStyle = '#F44336';
                });
            };
            
            // Update game state
            gameState.update = (currentTime = 0) => {
                if (!gameState.gameActive) return;
                
                const deltaTime = currentTime - gameState.lastTime;
                gameState.lastTime = currentTime;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw stars
                ctx.fillStyle = '#FFF';
                for (let i = 0; i < 50; i++) {
                    const x = (i * 17) % canvas.width;
                    const y = (i * 23) % canvas.height;
                    ctx.fillRect(x, y, 1, 1);
                }
                
                // Update bullets
                for (let i = 0; i < gameState.bullets.length; i++) {
                    const bullet = gameState.bullets[i];
                    bullet.y -= 5;
                    
                    // Remove off-screen bullets
                    if (bullet.y < 0) {
                        gameState.bullets.splice(i, 1);
                        i--;
                        continue;
                    }
                    
                    // Check collision with enemies
                    for (let j = 0; j < gameState.enemies.length; j++) {
                        const enemy = gameState.enemies[j];
                        if (
                            bullet.x < enemy.x + enemy.width &&
                            bullet.x + 3 > enemy.x &&
                            bullet.y < enemy.y + enemy.height &&
                            bullet.y + 10 > enemy.y
                        ) {
                            // Hit!
                            gameState.bullets.splice(i, 1);
                            gameState.enemies.splice(j, 1);
                            gameState.score += 10;
                            scoreElement.textContent = `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore}`;
                            SoundManager.play('success');
                            i--;
                            break;
                        }
                    }
                }
                
                // Update enemies
                let shouldDrop = false;
                for (let i = 0; i < gameState.enemies.length; i++) {
                    const enemy = gameState.enemies[i];
                    enemy.x += gameState.enemySpeed * gameState.enemyDirection;
                    
                    // Check if enemy hits the edge
                    if (
                        (enemy.x <= 0 && gameState.enemyDirection < 0) ||
                        (enemy.x + enemy.width >= canvas.width && gameState.enemyDirection > 0)
                    ) {
                        shouldDrop = true;
                    }
                    
                    // Check if enemy reaches the bottom
                    if (enemy.y + enemy.height >= gameState.player.y) {
                        gameState.lives--;
                        scoreElement.textContent = `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore}`;
                        if (gameState.lives <= 0) {
                            endGame();
                            return;
                        }
                        // Remove the enemy that reached the bottom
                        gameState.enemies.splice(i, 1);
                        i--;
                    }
                }
                
                // Handle enemy direction change
                if (shouldDrop) {
                    gameState.enemyDirection *= -1;
                    for (const enemy of gameState.enemies) {
                        enemy.y += gameState.enemyDrop;
                    }
                }
                
                // Check if all enemies are defeated
                if (gameState.enemies.length === 0) {
                    // Level complete
                    gameState.enemySpeed += 0.5;
                    // Create new enemies
                    initEnemies();
                }
                
                // Draw game objects
                drawPlayer();
                drawBullets();
                drawEnemies();
                
                // Continue animation loop
                gameState.animationId = requestAnimationFrame((time) => gameState.update(time));
            };
            
            // Start game
            const startGame = () => {
                if (gameState.gameActive) return;
                
                gameState.player.x = 185;
                gameState.bullets = [];
                gameState.score = 0;
                gameState.lives = 3;
                gameState.gameActive = true;
                gameState.enemyDirection = 1;
                gameState.enemySpeed = 1;
                scoreElement.textContent = `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore}`;
                initEnemies();
                gameState.lastTime = performance.now();
                gameState.update();
                SoundManager.play('click');
            };
            
            // End game
            const endGame = () => {
                gameState.gameActive = false;
                if (gameState.animationId) {
                    cancelAnimationFrame(gameState.animationId);
                }
                
                if (gameState.score > highScore) {
                    highScore = gameState.score;
                    updateScores('space', { highScore });
                    scoreElement.textContent = `Score: ${gameState.score} | Lives: ${gameState.lives} | High Score: ${highScore} 🎉`;
                    Toast.show(`New High Score: ${highScore}!`, 'success');
                }
                
                SoundManager.play('error');
            };
            
            // Handle keyboard input
            const keys = {};
            const handleKeyDown = (e) => {
                keys[e.key] = true;
                
                // Move player
                if (e.key === 'ArrowLeft') {
                    gameState.player.x = Math.max(0, gameState.player.x - gameState.player.speed);
                } else if (e.key === 'ArrowRight') {
                    gameState.player.x = Math.min(
                        canvas.width - gameState.player.width,
                        gameState.player.x + gameState.player.speed
                    );
                }
                
                // Fire bullet on spacebar
                if (e.key === ' ' && gameState.gameActive) {
                    gameState.bullets.push({
                        x: gameState.player.x + gameState.player.width / 2 - 1.5,
                        y: gameState.player.y
                    });
                    SoundManager.play('click');
                    e.preventDefault();
                }
            };
            
            const handleKeyUp = (e) => {
                keys[e.key] = false;
            };
            
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            startButton.addEventListener('click', startGame);
            
            // Initialize enemies
            initEnemies();
            
            return {
                destroy() {
                    document.removeEventListener('keydown', handleKeyDown);
                    document.removeEventListener('keyup', handleKeyUp);
                    if (gameState.animationId) {
                        cancelAnimationFrame(gameState.animationId);
                    }
                    container.innerHTML = '';
                },
                pause() {
                    if (gameState.gameActive) {
                        gameState.gameActive = false;
                        if (gameState.animationId) {
                            cancelAnimationFrame(gameState.animationId);
                        }
                    }
                },
                resume() {
                    if (!gameState.gameActive) {
                        gameState.gameActive = true;
                        gameState.lastTime = performance.now();
                        gameState.update();
                    }
                },
                restart() {
                    endGame();
                    setTimeout(startGame, 100);
                }
            };
        }
    },
    
    // Snake Game
    snake: {
        id: 'snake',
        name: "Shaikh's Snake",
        description: 'Guide the snake to eat food and grow longer',
        icon: '🐍',
        init(container) {
            let canvas, ctx;
            let gameState = {
                snake: [{x: 10, y: 10}],
                food: {x: 5, y: 5},
                direction: 'right',
                nextDirection: 'right',
                score: 0,
                speed: 150, // ms
                gridSize: 20,
                canvasWidth: 400,
                canvasHeight: 400,
                paused: false,
                gameActive: false,
                lastUpdate: 0,
                interpolation: 0
            };
            let highScore = scores.snake?.highScore || 0;
            let animationId = null;

            // Create game elements
            const gameElement = create('div', { className: 'snake-game' });
            
            const canvasContainer = create('div', { className: 'snake-canvas-container' });
            canvas = create('canvas', {
                className: 'snake-canvas',
                width: gameState.canvasWidth,
                height: gameState.canvasHeight
            });
            ctx = canvas.getContext('2d');
            canvasContainer.appendChild(canvas);
            
            const scoreElement = create('div', {
                className: 'snake-stat',
                textContent: `Score: ${gameState.score} | High Score: ${highScore}`
            });
            
            const controlsElement = create('div', { className: 'snake-controls' });
            const startButton = create('button', {
                className: 'btn btn-primary',
                textContent: 'Start Game'
            });
            const pauseButton = create('button', {
                className: 'btn btn-secondary',
                textContent: 'Pause'
            });
            
            controlsElement.append(startButton, pauseButton);
            gameElement.append(canvasContainer, scoreElement, controlsElement);
            container.appendChild(gameElement);
            
            // Generate food at random position
            const generateFood = () => {
                const x = Math.floor(Math.random() * (gameState.canvasWidth / gameState.gridSize));
                const y = Math.floor(Math.random() * (gameState.canvasHeight / gameState.gridSize));
                return {x, y};
            };
            
            // Draw game
            const draw = () => {
                // Clear canvas
                const gradient = ctx.createLinearGradient(0, 0, 0, gameState.canvasHeight);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#E0F7FA');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, gameState.canvasWidth, gameState.canvasHeight);
                
                // Draw snake
                gameState.snake.forEach((segment, index) => {
                    ctx.fillStyle = index === 0 ? '#4CAF50' : '#8BC34A'; // Head is darker
                    ctx.fillRect(
                        segment.x * gameState.gridSize,
                        segment.y * gameState.gridSize,
                        gameState.gridSize - 1,
                        gameState.gridSize - 1
                    );
                });
                
                // Draw food
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(
                    gameState.food.x * gameState.gridSize,
                    gameState.food.y * gameState.gridSize,
                    gameState.gridSize - 1,
                    gameState.gridSize - 1
                );
            };
            
            // Update game state
            const update = (timestamp) => {
                if (!gameState.gameActive) return;
                
                // Calculate delta time for smooth movement
                if (!gameState.lastUpdate) gameState.lastUpdate = timestamp;
                const deltaTime = timestamp - gameState.lastUpdate;
                gameState.lastUpdate = timestamp;
                gameState.interpolation += deltaTime;
                
                // Process game updates at fixed intervals
                while (gameState.interpolation >= gameState.speed) {
                    gameState.direction = gameState.nextDirection;
                    
                    // Calculate new head position
                    const head = {...gameState.snake[0]};
                    switch (gameState.direction) {
                        case 'up': head.y -= 1; break;
                        case 'down': head.y += 1; break;
                        case 'left': head.x -= 1; break;
                        case 'right': head.x += 1; break;
                    }
                    
                    // Check collision with walls
                    if (
                        head.x < 0 ||
                        head.y < 0 ||
                        head.x >= gameState.canvasWidth / gameState.gridSize ||
                        head.y >= gameState.canvasHeight / gameState.gridSize
                    ) {
                        endGame();
                        return;
                    }
                    
                    // Check collision with self
                    for (let i = 0; i < gameState.snake.length; i++) {
                        if (gameState.snake[i].x === head.x && gameState.snake[i].y === head.y) {
                            endGame();
                            return;
                        }
                    }
                    
                    // Add new head
                    gameState.snake.unshift(head);
                    
                    // Check if food is eaten
                    if (head.x === gameState.food.x && head.y === gameState.food.y) {
                        gameState.score += 10;
                        gameState.food = generateFood();
                        SoundManager.play('success');
                        
                        // Increase speed slightly every 50 points
                        if (gameState.score % 50 === 0 && gameState.speed > 50) {
                            gameState.speed -= 5;
                        }
                        
                        // Check achievements
                        checkAchievement('snake_first_apple', gameState.score >= 10);
                        checkAchievement('snake_100_score', gameState.score >= 100);
                    } else {
                        // Remove tail if no food eaten
                        gameState.snake.pop();
                    }
                    
                    gameState.interpolation -= gameState.speed;
                }
                
                draw();
                animationId = requestAnimationFrame(update);
            };
            
            // Start game
            const startGame = () => {
                if (gameState.gameActive) return;
                
                // Reset game state
                gameState.snake = [{x: 10, y: 10}];
                gameState.food = generateFood();
                gameState.direction = 'right';
                gameState.nextDirection = 'right';
                gameState.score = 0;
                gameState.speed = 150;
                gameState.gameActive = true;
                gameState.paused = false;
                gameState.lastUpdate = 0;
                gameState.interpolation = 0;
                
                scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore}`;
                startButton.textContent = 'Restart Game';
                pauseButton.textContent = 'Pause';
                
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                animationId = requestAnimationFrame(update);
                SoundManager.play('click');
            };
            
            // End game
            const endGame = () => {
                gameState.gameActive = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                
                if (gameState.score > highScore) {
                    highScore = gameState.score;
                    updateScores('snake', { highScore });
                    scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore} 🎉`;
                    Toast.show(`New High Score: ${highScore}!`, 'success');
                } else {
                    scoreElement.textContent = `Score: ${gameState.score} | High Score: ${highScore}`;
                }
                SoundManager.play('error');
            };
            
            // Handle keyboard input
            const handleKeyDown = (e) => {
                switch(e.key) {
                    case 'ArrowUp':
                        if (gameState.direction !== 'down') gameState.nextDirection = 'up';
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        if (gameState.direction !== 'up') gameState.nextDirection = 'down';
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        if (gameState.direction !== 'right') gameState.nextDirection = 'left';
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        if (gameState.direction !== 'left') gameState.nextDirection = 'right';
                        e.preventDefault();
                        break;
                }
            };
            
            document.addEventListener('keydown', handleKeyDown);
            
            // Handle touch/swipe input
            let touchStartX = 0;
            let touchStartY = 0;
            
            canvas.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                if (!touchStartX || !touchStartY || !gameState.gameActive) return;
                
                const touchEndX = e.touches[0].clientX;
                const touchEndY = e.touches[0].clientY;
                
                const diffX = touchStartX - touchEndX;
                const diffY = touchStartY - touchEndY;
                
                // Determine swipe direction
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Horizontal swipe
                    if (diffX > 0 && gameState.direction !== 'right') {
                        gameState.nextDirection = 'left';
                    } else if (diffX < 0 && gameState.direction !== 'left') {
                        gameState.nextDirection = 'right';
                    }
                } else {
                    // Vertical swipe
                    if (diffY > 0 && gameState.direction !== 'down') {
                        gameState.nextDirection = 'up';
                    } else if (diffY < 0 && gameState.direction !== 'up') {
                        gameState.nextDirection = 'down';
                    }
                }
                
                touchStartX = 0;
                touchStartY = 0;
                e.preventDefault();
            }, { passive: false });
            
            // Button event listeners
            startButton.addEventListener('click', startGame);
            
            pauseButton.addEventListener('click', () => {
                if (!gameState.gameActive) return;
                
                if (gameState.paused) {
                    // Resume
                    gameState.paused = false;
                    pauseButton.textContent = 'Pause';
                    gameState.lastUpdate = performance.now();
                    animationId = requestAnimationFrame(update);
                } else {
                    // Pause
                    gameState.paused = true;
                    pauseButton.textContent = 'Resume';
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                }
            });
            
            return {
                destroy() {
                    document.removeEventListener('keydown', handleKeyDown);
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    container.innerHTML = '';
                },
                pause() {
                    if (gameState.gameActive && !gameState.paused) {
                        gameState.paused = true;
                        if (animationId) {
                            cancelAnimationFrame(animationId);
                        }
                    }
                },
                resume() {
                    if (gameState.gameActive && gameState.paused) {
                        gameState.paused = false;
                        gameState.lastUpdate = performance.now();
                        animationId = requestAnimationFrame(update);
                    }
                },
                restart() {
                    endGame();
                    setTimeout(startGame, 100);
                }
            };
        }
    }
};

// ===== Main Application =====
const ArcadeApp = {
    currentGame: null,
    currentView: null,
    
    init() {
        // Load saved data
        loadData();
        
        // Initialize managers
        SoundManager.init();
        Toast.init();
        Confetti.init();
        
        // Set initial theme
        this.setTheme(settings.theme);
        
        // Set sound state
        if (!settings.sound) {
            SoundManager.toggle();
        }
        
        // Setup event listeners
        this.setupEventListeners();
        
        // Populate games list
        this.populateGamesList();
        
        // Show home screen
        this.showHome();
    },
    
    setupEventListeners() {
        // Theme toggle
        const themeToggle = qs('#themeToggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                const newTheme = settings.theme === 'light' ? 'dark' : 'light';
                this.setTheme(newTheme);
                settings.theme = newTheme;
                saveData();
            });
        }
        
        // Sound toggle
        const soundToggle = qs('#soundToggle');
        if (soundToggle) {
            soundToggle.addEventListener('click', () => {
                const isSoundOn = SoundManager.toggle();
                settings.sound = isSoundOn;
                saveData();
            });
        }
        
        // Sidebar toggle
        const toggleSidebar = qs('#toggleSidebar');
        if (toggleSidebar) {
            toggleSidebar.addEventListener('click', () => {
                const sidebar = qs('#gameSidebar');
                sidebar.classList.toggle('hidden');
            });
        }
        
        // Close view buttons
        const closeButtons = qsa('[id^="close"][id$="View"]');
        closeButtons.forEach(button => {
            button.addEventListener('click', () => {
                const viewId = button.id.replace('close', '').toLowerCase();
                this.closeGameView(viewId);
            });
        });
    },
    
    setTheme(theme) {
        document.body.className = `theme-${theme}`;
        const themeToggle = qs('#themeToggle');
        if (themeToggle) {
            themeToggle.textContent = theme === 'light' ? '☀️' : '🌙';
        }
    },
    
    populateGamesList() {
        const gameList = qs('#gameList');
        const gamesGrid = qs('#gamesGrid');
        
        if (!gameList || !gamesGrid) return;
        
        gameList.innerHTML = '';
        gamesGrid.innerHTML = '';
        
        Object.values(games).forEach(game => {
            // Sidebar list item
            const listItem = create('li', {});
            const listLink = create('a', {
                href: '#',
                textContent: game.name
            });
            listLink.addEventListener('click', (e) => {
                e.preventDefault();
                this.openGameView(game.id);
            });
            listItem.appendChild(listLink);
            gameList.appendChild(listItem);
            
            // Grid tile
            const tile = create('div', { className: 'game-tile' });
            const icon = create('div', {
                className: 'game-icon',
                textContent: game.icon
            });
            const title = create('h3', { textContent: game.name });
            const description = create('p', { textContent: game.description });
            
            tile.append(icon, title, description);
            tile.addEventListener('click', () => {
                this.openGameView(game.id);
            });
            
            gamesGrid.appendChild(tile);
        });
    },
    
    showHome() {
        // Hide all game views
        qsa('.game-view').forEach(view => {
            view.classList.remove('active');
        });
        
        this.currentGame = null;
        this.currentView = null;
    },
    
    openGameView(gameId) {
        // Close current game if any
        if (this.currentGame) {
            this.closeCurrentGame();
        }
        
        // Hide home screen and show game view
        const gameView = qs(`#${gameId}View`);
        if (!gameView) return;
        
        // Hide all views
        qsa('.game-view').forEach(view => {
            view.classList.remove('active');
        });
        
        // Show selected view
        gameView.classList.add('active');
        this.currentView = gameId;
        
        // Initialize game
        const game = games[gameId];
        if (game) {
            const contentContainer = qs(`#${gameId}Content`);
            if (contentContainer) {
                contentContainer.innerHTML = '';
                this.currentGame = game.init(contentContainer);
            }
        }
        
        // Hide sidebar on mobile
        const sidebar = qs('#gameSidebar');
        if (sidebar && window.innerWidth <= 768) {
            sidebar.classList.add('hidden');
        }
    },
    
    closeGameView(viewId) {
        // Close current game
        this.closeCurrentGame();
        
        // Hide the view
        const gameView = qs(`#${viewId}View`);
        if (gameView) {
            gameView.classList.remove('active');
        }
        
        this.currentView = null;
        this.showHome();
    },
    
    closeCurrentGame() {
        if (this.currentGame && this.currentGame.destroy) {
            this.currentGame.destroy();
            this.currentGame = null;
        }
    },
    
    pauseCurrentGame() {
        if (this.currentGame && this.currentGame.pause) {
            this.currentGame.pause();
        }
    },
    
    resumeCurrentGame() {
        if (this.currentGame && this.currentGame.resume) {
            this.currentGame.resume();
        }
    }
};

// ===== Score Management =====
const updateScores = (gameId, newScores) => {
    if (!scores[gameId]) {
        scores[gameId] = {};
    }
    Object.assign(scores[gameId], newScores);
    saveData();
};

// ===== Initialize App =====
document.addEventListener('DOMContentLoaded', () => {
    ArcadeApp.init();
});

// ===== Handle Page Visibility =====
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        ArcadeApp.pauseCurrentGame();
    } else {
        ArcadeApp.resumeCurrentGame();
    }
});

// ===== Handle Window Resize =====
window.addEventListener('resize', () => {
    // Reinitialize current game to handle resize
    if (ArcadeApp.currentGame && ArcadeApp.currentGame.restart) {
        // For games that need resize handling, we could restart them
        // But for now, we'll just let them handle it internally
    }
});
</script>
</body>
</html>

   
