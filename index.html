<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shaikh's Arcade - Enhanced</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    /* ====== CSS Variables - Enhanced Theme ====== */
    :root {
      /* Light Theme (Default) */
      --color-primary: #6200ee;
      --color-on-primary: #ffffff;
      --color-secondary: #03dac6;
      --color-on-secondary: #000000;
      --color-surface: #ffffff;
      --color-on-surface: #000000;
      --color-background: #f5f5f5;
      --color-on-background: #212121;
      --color-error: #b00020;
      --color-on-error: #ffffff;
      --color-background-dark: #121212;
      --color-on-background-dark: #e0e0e0;
      --color-surface-dark: #1e1e1e;
      --color-on-surface-dark: #ffffff;
      --color-primary-dark: #bb86fc;
      --color-on-primary-dark: #000000;
      --color-secondary-dark: #03dac6;
      --color-on-secondary-dark: #000000;
      --color-error-dark: #cf6679;
      --color-on-error-dark: #000000;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
      --shadow-md: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
      --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);
      --shadow-focus: 0 0 0 3px rgba(98, 0, 238, 0.2);
      --transition-fast: 0.1s;
      --transition-normal: 0.2s;
      --transition-slow: 0.3s;
      --border-radius: 8px;
    }

    .theme-dark {
      --color-primary: var(--color-primary-dark);
      --color-on-primary: var(--color-on-primary-dark);
      --color-secondary: var(--color-secondary-dark);
      --color-on-secondary: var(--color-on-secondary-dark);
      --color-surface: var(--color-surface-dark);
      --color-on-surface: var(--color-on-surface-dark);
      --color-background: var(--color-background-dark);
      --color-on-background: var(--color-on-background-dark);
      --color-error: var(--color-error-dark);
      --color-on-error: var(--color-on-error-dark);
      --shadow-focus: 0 0 0 3px rgba(187, 134, 252, 0.2);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      background-color: var(--color-background);
      color: var(--color-on-background);
      line-height: 1.6;
      overflow-x: hidden;
      transition: background-color var(--transition-normal), color var(--transition-normal);
      position: relative;
    }

    /* ====== Base Styles ====== */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 16px;
      border: none;
      border-radius: var(--border-radius);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: relative;
      overflow: hidden;
      outline: none;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .btn:focus {
      box-shadow: var(--shadow-focus);
    }

    .btn-primary {
      background-color: var(--color-primary);
      color: var(--color-on-primary);
      box-shadow: var(--shadow-sm);
    }

    .btn-primary:hover {
      background-color: color-mix(in srgb, var(--color-primary) 80%, black);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .btn-secondary {
      background-color: var(--color-surface);
      color: var(--color-on-surface);
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: var(--shadow-sm);
    }

    .theme-dark .btn-secondary {
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .btn-secondary:hover {
      background-color: rgba(0, 0, 0, 0.05);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .theme-dark .btn-secondary:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .icon-button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color var(--transition-fast);
    }

    .icon-button:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .theme-dark .icon-button:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    /* ====== Header ====== */
    header {
      background-color: var(--color-surface);
      box-shadow: var(--shadow-sm);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
    }

    .logo {
      font-size: 24px;
      font-weight: 700;
      color: var(--color-primary);
      text-decoration: none;
      display: flex;
      align-items: center;
    }

    .logo span {
      margin-left: 8px;
    }

    .header-controls {
      display: flex;
      gap: 10px;
    }

    /* ====== Main Layout ====== */
    .main-layout {
      display: flex;
      min-height: calc(100vh - 80px);
    }

    /* ====== Sidebar ====== */
    .sidebar {
      width: 250px;
      background-color: var(--color-surface);
      box-shadow: var(--shadow-sm);
      padding: 20px 0;
      transition: transform var(--transition-normal);
      overflow-y: auto;
      height: calc(100vh - 80px);
      position: sticky;
      top: 80px;
    }

    .sidebar.hidden {
      transform: translateX(-100%);
      position: absolute;
    }

    .sidebar-header {
      padding: 0 20px 15px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      margin-bottom: 15px;
    }

    .theme-dark .sidebar-header {
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .sidebar-title {
      font-size: 18px;
      font-weight: 500;
      margin: 0;
    }

    .game-list {
      list-style: none;
    }

    .game-list-item {
      padding: 12px 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      transition: background-color var(--transition-fast);
      border-left: 3px solid transparent;
    }

    .game-list-item:hover {
      background-color: rgba(0, 0, 0, 0.03);
    }

    .theme-dark .game-list-item:hover {
      background-color: rgba(255, 255, 255, 0.03);
    }

    .game-list-item.active {
      background-color: rgba(98, 0, 238, 0.1);
      border-left: 3px solid var(--color-primary);
    }

    .game-list-icon {
      font-size: 20px;
      margin-right: 12px;
      width: 24px;
      text-align: center;
    }

    .game-list-text {
      font-size: 15px;
      font-weight: 400;
    }

    /* ====== Toggle Sidebar Button ====== */
    #toggleSidebar {
      display: none;
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 99;
    }

    /* ====== Main Content ====== */
    .main-content {
      flex: 1;
      padding: 20px;
    }

    .games-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .game-tile {
      background-color: var(--color-surface);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-sm);
      padding: 20px;
      cursor: pointer;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast);
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .game-tile:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-md);
    }

    .game-icon {
      font-size: 40px;
      margin-bottom: 15px;
    }

    .game-title {
      font-size: 18px;
      font-weight: 500;
      margin-bottom: 8px;
    }

    .game-description {
      font-size: 14px;
      color: var(--color-on-surface);
      opacity: 0.8;
      flex-grow: 1;
    }

    .game-preview {
      margin-top: 15px;
      height: 100px;
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: var(--color-on-surface);
      opacity: 0.7;
    }

    .theme-dark .game-preview {
      background-color: rgba(255, 255, 255, 0.05);
    }

    /* ====== Game View ====== */
    .game-view {
      display: none;
      background-color: var(--color-surface);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-sm);
      overflow: hidden;
      height: calc(100vh - 120px);
      flex-direction: column;
    }

    .game-view.active {
      display: flex;
    }

    .game-header {
      padding: 15px 20px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .theme-dark .game-header {
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .game-title-bar {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .game-title {
      font-size: 20px;
      font-weight: 500;
      margin: 0;
    }

    .game-controls {
      display: flex;
      gap: 10px;
    }

    .game-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      outline: none;
    }

    /* ====== Game Styles ====== */
    /* Snake Game */
    .snake-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .snake-canvas {
      background-color: #f0f0f0;
      border-radius: 4px;
      box-shadow: var(--shadow-sm);
    }

    .theme-dark .snake-canvas {
      background-color: #2a2a2a;
    }

    .snake-stats {
      display: flex;
      gap: 20px;
      font-size: 16px;
      font-weight: 500;
    }

    .snake-stat-item {
      background-color: rgba(0, 0, 0, 0.05);
      padding: 8px 12px;
      border-radius: 4px;
    }

    .theme-dark .snake-stat-item {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .snake-level-display {
      font-weight: 500;
      color: var(--color-primary);
    }

    .snake-announcer {
      min-height: 24px;
      font-weight: 500;
      text-align: center;
      color: var(--color-primary);
    }

    /* Tic-Tac-Toe Game */
    .tictactoe-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .tictactoe-status {
      font-size: 18px;
      font-weight: 500;
      text-align: center;
    }

    .tictactoe-board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .tictactoe-cell {
      width: 100px;
      height: 100px;
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      font-weight: 700;
      cursor: pointer;
      transition: background-color var(--transition-fast);
    }

    .theme-dark .tictactoe-cell {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .tictactoe-cell:hover {
      background-color: rgba(0, 0, 0, 0.1);
    }

    .theme-dark .tictactoe-cell:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .tictactoe-cell.win {
      background-color: rgba(76, 175, 80, 0.2);
    }

    .tictactoe-score {
      font-size: 16px;
      font-weight: 500;
    }

    .tictactoe-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    /* Memory Game */
    .memory-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .memory-stats {
      display: flex;
      gap: 20px;
      font-size: 16px;
      font-weight: 500;
    }

    .memory-stat-item {
      background-color: rgba(0, 0, 0, 0.05);
      padding: 8px 12px;
      border-radius: 4px;
    }

    .theme-dark .memory-stat-item {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .memory-board {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      max-width: 400px;
    }

    .memory-card {
      width: 80px;
      height: 80px;
      background-color: var(--color-primary);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 30px;
      cursor: pointer;
      transition: transform var(--transition-fast);
      box-shadow: var(--shadow-sm);
    }

    .memory-card.flipped {
      background-color: var(--color-surface);
      transform: rotateY(180deg);
    }

    .memory-card.matched {
      background-color: rgba(76, 175, 80, 0.2);
      cursor: default;
    }

    .memory-controls {
      margin-top: 10px;
    }

    /* Reaction Tester Game */
    .reaction-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .reaction-display {
      width: 300px;
      height: 150px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 500;
      text-align: center;
      cursor: pointer;
      transition: background-color var(--transition-fast);
      box-shadow: var(--shadow-sm);
    }

    .reaction-ready {
      background-color: var(--color-primary);
      color: var(--color-on-primary);
    }

    .reaction-wait {
      background-color: #ff9800;
      color: #000000;
    }

    .reaction-go {
      background-color: #4caf50;
      color: var(--color-on-primary);
    }

    .reaction-result {
      font-size: 18px;
      font-weight: 500;
      text-align: center;
      min-height: 27px;
    }

    .reaction-attempts {
      font-size: 16px;
      opacity: 0.8;
    }

    /* Whack-a-Doodle Game */
    .whack-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .whack-stats {
      display: flex;
      gap: 20px;
      font-size: 16px;
      font-weight: 500;
    }

    .whack-stat-item {
      background-color: rgba(0, 0, 0, 0.05);
      padding: 8px 12px;
      border-radius: 4px;
    }

    .theme-dark .whack-stat-item {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .whack-board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      max-width: 400px;
    }

    .whack-hole {
      width: 100px;
      height: 100px;
      background-color: #795548;
      border-radius: 50%;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.3);
    }

    .whack-doodle {
      position: absolute;
      width: 80px;
      height: 80px;
      background-color: #ffeb3b;
      border-radius: 50%;
      bottom: -80px;
      left: 10px;
      transition: bottom 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      cursor: pointer;
      box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
    }

    .whack-doodle.up {
      bottom: 0;
    }

    .whack-controls {
      margin-top: 10px;
    }

    /* Dice Game */
    .dice-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .dice-display {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }

    .dice {
      width: 80px;
      height: 80px;
      background-color: var(--color-surface);
      border: 2px solid var(--color-primary);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      font-weight: 700;
      box-shadow: var(--shadow-sm);
    }

    .dice-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      width: 100%;
      max-width: 300px;
    }

    .dice-guess {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
    }

    .dice-guess input {
      flex: 1;
      padding: 10px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      font-size: 16px;
      text-align: center;
    }

    .theme-dark .dice-guess input {
      border: 1px solid rgba(255, 255, 255, 0.2);
      background-color: var(--color-background);
      color: var(--color-on-background);
    }

    .dice-result {
      font-size: 18px;
      font-weight: 500;
      text-align: center;
      min-height: 27px;
    }

    .dice-stats {
      font-size: 16px;
      font-weight: 500;
      text-align: center;
    }

    /* Shaikh's Runner Game */
    .runner-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .runner-canvas {
      background-color: #e0e0e0;
      border-radius: 4px;
      box-shadow: var(--shadow-sm);
    }

    .theme-dark .runner-canvas {
      background-color: #333333;
    }

    .runner-stats {
      font-size: 16px;
      font-weight: 500;
    }

    .runner-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    /* ====== Modals ====== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-normal), visibility var(--transition-normal);
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background-color: var(--color-surface);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-lg);
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      transform: translateY(20px);
      transition: transform var(--transition-normal);
    }

    .modal-overlay.active .modal {
      transform: translateY(0);
    }

    .modal-header {
      padding: 20px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .theme-dark .modal-header {
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .modal-title {
      margin: 0;
      font-size: 20px;
      font-weight: 500;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color var(--transition-fast);
    }

    .modal-close:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .theme-dark .modal-close:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .modal-body {
      padding: 20px;
    }

    .modal-footer {
      padding: 15px 20px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .theme-dark .modal-footer {
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      font-size: 16px;
      background-color: var(--color-surface);
      color: var(--color-on-surface);
    }

    .theme-dark .form-group input,
    .theme-dark .form-group select {
      border: 1px solid rgba(255, 255, 255, 0.2);
      background-color: var(--color-background);
    }

    .form-group input[type="range"] {
      padding: 0;
    }

    .form-group .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .form-group .checkbox-group input {
      width: auto;
    }

    /* ====== Toasts ====== */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1100;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .toast {
      background-color: var(--color-surface);
      color: var(--color-on-surface);
      padding: 15px 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-lg);
      display: flex;
      align-items: center;
      gap: 10px;
      transform: translateX(100%);
      transition: transform var(--transition-normal);
      max-width: 350px;
    }

    .toast.show {
      transform: translateX(0);
    }

    .toast.success {
      border-left: 4px solid #4caf50;
    }

    .toast.error {
      border-left: 4px solid var(--color-error);
    }

    .toast.info {
      border-left: 4px solid var(--color-primary);
    }

    .toast-close {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      margin-left: auto;
    }

    /* ====== Responsive Design ====== */
    @media (max-width: 768px) {
      .main-layout {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        height: auto;
        position: relative;
        top: 0;
        box-shadow: none;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      }

      .theme-dark .sidebar {
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .sidebar.hidden {
        transform: none;
        position: relative;
      }

      #toggleSidebar {
        display: block;
      }

      .games-grid {
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      }

      .tictactoe-cell {
        width: 80px;
        height: 80px;
      }

      .memory-card {
        width: 70px;
        height: 70px;
      }

      .whack-hole {
        width: 80px;
        height: 80px;
      }

      .whack-doodle {
        width: 65px;
        height: 65px;
        left: 7.5px;
      }
    }

    @media (max-width: 480px) {
      .header-content {
        flex-direction: column;
        gap: 15px;
      }

      .games-grid {
        grid-template-columns: 1fr;
      }

      .tictactoe-cell {
        width: 70px;
        height: 70px;
      }

      .memory-card {
        width: 60px;
        height: 60px;
      }

      .whack-hole {
        width: 70px;
        height: 70px;
      }

      .whack-doodle {
        width: 55px;
        height: 55px;
        left: 7.5px;
      }

      .reaction-display {
        width: 250px;
        height: 120px;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header>
    <div class="header-content">
      <a href="#" class="logo" id="logo">
        <span>Shaikh's Arcade</span>
      </a>
      <div class="header-controls">
        <button class="icon-button" id="soundToggle" aria-label="Toggle sound">🔊</button>
        <button class="icon-button" id="themeToggle" aria-label="Toggle theme">☀️</button>
        <button class="icon-button" id="settingsButton" aria-label="Settings">⚙️</button>
        <button class="icon-button" id="profileButton" aria-label="Profile">👤</button>
      </div>
    </div>
  </header>

  <!-- Main Layout -->
  <div class="main-layout">
    <!-- Sidebar -->
    <aside class="sidebar" id="gameSidebar">
      <div class="sidebar-header">
        <h3 class="sidebar-title">Games</h3>
      </div>
      <ul class="game-list" id="gamesList">
        <!-- Game list items will be populated by JavaScript -->
      </ul>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <button class="btn btn-secondary" id="toggleSidebar">☰ Menu</button>
      <div class="games-grid" id="gamesGrid">
        <!-- Game tiles will be populated by JavaScript -->
      </div>
    </main>

    <!-- Game View -->
    <div class="game-view" id="gameView">
      <div class="game-header">
        <div class="game-title-bar">
          <button class="btn btn-secondary" id="backButton">← Back</button>
          <h2 class="game-title" id="currentGameTitle">Game Title</h2>
        </div>
        <div class="game-controls">
          <button class="icon-button" id="gameInfo" aria-label="Game information">ℹ️</button>
          <button class="icon-button" id="gameRestart" aria-label="Restart game">🔄</button>
          <button class="icon-button" id="gamePause" aria-label="Pause game">⏸️</button>
        </div>
      </div>
      <div class="game-content" id="gameContent" tabindex="-1">
        <!-- Game content will be populated by JavaScript -->
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Settings</h3>
        <button class="modal-close" id="closeSettings">✕</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="soundToggleSetting">Sound</label>
          <div class="checkbox-group">
            <input type="checkbox" id="soundToggleSetting">
            <label for="soundToggleSetting">Enable sound effects</label>
          </div>
        </div>
        <div class="form-group">
          <label for="volumeSlider">Volume</label>
          <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="0.5">
        </div>
        <div class="form-group">
          <label for="themeSelect">Theme</label>
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>
        </div>
        <div class="form-group">
          <label for="onboardingToggle">Onboarding</label>
          <div class="checkbox-group">
            <input type="checkbox" id="onboardingToggle" checked>
            <label for="onboardingToggle">Show onboarding on startup</label>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="resetProgress">Reset Progress</button>
        <button class="btn btn-primary" id="saveSettings">Save</button>
      </div>
    </div>
  </div>

  <!-- Profile Modal -->
  <div class="modal-overlay" id="profileModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Your Profile</h3>
        <button class="modal-close" id="closeProfile">✕</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <h4>Achievements</h4>
          <div id="achievementsList">
            <!-- Achievements will be populated by JavaScript -->
          </div>
        </div>
        <div class="form-group">
          <h4>High Scores</h4>
          <div id="highScoresList">
            <!-- High scores will be populated by JavaScript -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Onboarding Modal -->
  <div class="modal-overlay" id="onboardingModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Welcome to Shaikh's Arcade!</h3>
        <button class="modal-close" id="closeOnboarding">✕</button>
      </div>
      <div class="modal-body">
        <div style="text-align: center; margin-bottom: 20px;">
          <div style="font-size: 60px; margin-bottom: 15px;">🎉</div>
          <h3 style="margin-bottom: 15px;">Ready for Some Fun?</h3>
          <p>🕹️ Play 7 awesome mini-games</p>
          <p>🏆 Earn achievements and beat your high scores</p>
          <p>⚙️ Customize your experience in settings</p>
          <p>🌙 Try the new dark theme!</p>
          <p>✨ Experience the new theme and creative details!</p>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-primary" id="startPlaying">Start Playing</button>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer">
    <!-- Toasts will be added here by JavaScript -->
  </div>

  <script>
    /* ====== SCRIPTS - Enhanced with New Theme and Fixed Games ====== */
    (function() {
      'use strict';

      // Utility functions
      const qs = (selector, root = document) => root.querySelector(selector);
      const qsa = (selector, root = document) => Array.from(root.querySelectorAll(selector));
      const create = (tag, props = {}, children = []) => {
        const el = document.createElement(tag);
        Object.keys(props).forEach(key => {
          el[key] = props[key];
        });
        children.forEach(child => {
          if (typeof child === 'string') {
            el.appendChild(document.createTextNode(child));
          } else {
            el.appendChild(child);
          }
        });
        return el;
      };

      // App state
      let activeGame = null;
      let activeGameId = null;
      let gamesRegistry = {};
      let settings = {
        soundOn: true,
        volume: 0.5,
        theme: 'light', // Default to new light theme
        showOnboarding: true
      };
      let scores = {};
      let achievements = {};

      // Storage utilities
      const Storage = {
        get(key) {
          try {
            const item = localStorage.getItem(`shaikhArcadeEnhanced.${key}`);
            return item ? JSON.parse(item) : null;
          } catch (e) {
            console.error('Error reading from localStorage', e);
            return null;
          }
        },
        set(key, value) {
          try {
            localStorage.setItem(`shaikhArcadeEnhanced.${key}`, JSON.stringify(value));
          } catch (e) {
            console.error('Error writing to localStorage', e);
          }
        },
        remove(key) {
          try {
            localStorage.removeItem(`shaikhArcadeEnhanced.${key}`);
          } catch (e) {
            console.error('Error removing from localStorage', e);
          }
        }
      };

      // Load/Save data
      function loadData() {
        const savedSettings = Storage.get('settings');
        if (savedSettings) settings = { ...settings, ...savedSettings };

        const savedScores = Storage.get('scores');
        if (savedScores) scores = savedScores;

        const savedAchievements = Storage.get('achievements');
        if (savedAchievements) achievements = savedAchievements;

        applySettings();
      }

      function saveData() {
        Storage.set('settings', settings);
        Storage.set('scores', scores);
        Storage.set('achievements', achievements);
      }

      function updateScores(gameId, newScores) {
        if (!scores[gameId]) scores[gameId] = {};
        scores[gameId] = { ...scores[gameId], ...newScores };
        saveData();
      }

      function checkAchievement(id, condition, data = {}) {
        if (condition && !achievements[id]) {
          achievements[id] = {
            timestamp: Date.now(),
            ...data
          };
          saveData();
          let message = '';
          switch (id) {
            case 'first_game': message = 'Achievement Unlocked: First Game!'; break;
            case 'snake_master': message = 'Achievement Unlocked: Snake Master!'; break;
            case 'tic_master': message = 'Achievement Unlocked: Tic-Tac-Toe Master!'; break;
            case 'memory_champ': message = 'Achievement Unlocked: Memory Champion!'; break;
            case 'speed_demon': message = 'Achievement Unlocked: Speed Demon!'; break;
            case 'whack_streak': message = 'Achievement Unlocked: Whack-a-Doodle Streak!'; break;
            case 'lucky_roller': message = 'Achievement Unlocked: Lucky Roller!'; break;
            case 'runner_pro': message = 'Achievement Unlocked: Runner Pro!'; break;
          }
          if (message) Toast.show(message, 'success');
        }
      }

      // Toast notifications
      const Toast = {
        show(message, type = 'info') {
          const container = qs('#toastContainer');
          const toast = create('div', {
            className: `toast ${type}`,
            innerHTML: `
              <span>${message}</span>
              <button class="toast-close">×</button>
            `
          });

          const closeBtn = qs('.toast-close', toast);
          closeBtn.addEventListener('click', () => {
            toast.classList.remove('show');
            setTimeout(() => {
              container.removeChild(toast);
            }, 300);
          });

          container.appendChild(toast);
          setTimeout(() => toast.classList.add('show'), 10);

          setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
              if (container.contains(toast)) {
                container.removeChild(toast);
              }
            }, 300);
          }, 5000);
        }
      };

      // Sound Manager (Simplified version)
      const SoundManager = {
        audioContext: null,
        enabled: true,
        volume: 0.5,

        init() {
          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.enabled = true;
          } catch (e) {
            console.warn('Web Audio API is not supported in this browser');
            this.enabled = false;
          }
        },

        play(kind) {
          if (!this.enabled || !this.audioContext || !settings.soundOn) return;

          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);

          let frequency = 440;
          let duration = 0.1;

          switch (kind) {
            case 'click': frequency = 523.25; break;
            case 'success': frequency = 783.99; break;
            case 'error': frequency = 349.23; break;
            case 'eat': frequency = 659.25; duration = 0.05; break;
            case 'hit': frequency = 392; duration = 0.08; break;
          }

          gainNode.gain.value = this.volume;
          oscillator.frequency.value = frequency;
          oscillator.type = 'sine';
          oscillator.start();
          gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
        }
      };

      // Apply settings
      function applySettings() {
        // Theme
        if (settings.theme === 'dark') {
          document.body.classList.add('theme-dark');
          qs('#themeToggle').textContent = '🌙';
          qs('#themeSelect').value = 'dark';
        } else {
          document.body.classList.remove('theme-dark');
          qs('#themeToggle').textContent = '☀️';
          qs('#themeSelect').value = 'light';
        }

        // Sound
        qs('#soundToggle').textContent = settings.soundOn ? '🔊' : '🔇';
        qs('#soundToggleSetting').checked = settings.soundOn;
        qs('#volumeSlider').value = settings.volume;
        SoundManager.volume = settings.volume;

        // Onboarding
        qs('#onboardingToggle').checked = settings.showOnboarding;
      }

      // Ripple effect for buttons
      function addRippleEffect(element) {
        element.addEventListener('click', function(e) {
          const ripple = document.createElement('span');
          const rect = this.getBoundingClientRect();
          const size = Math.max(rect.width, rect.height);
          const x = e.clientX - rect.left - size / 2;
          const y = e.clientY - rect.top - size / 2;

          ripple.style.width = ripple.style.height = `${size}px`;
          ripple.style.left = `${x}px`;
          ripple.style.top = `${y}px`;
          ripple.classList.add('ripple');

          this.appendChild(ripple);

          setTimeout(() => {
            ripple.remove();
          }, 600);
        });
      }

      // Create game preview
      function createGamePreview(gameId) {
        const preview = create('div', { className: 'game-preview' });
        switch (gameId) {
          case 'snake':
            preview.textContent = '🐍 Eat food, avoid walls!';
            break;
          case 'tictactoe':
            preview.textContent = '⭕ Classic X and O game';
            break;
          case 'memory':
            preview.textContent = '🧠 Match pairs of cards';
            break;
          case 'reaction':
            preview.textContent = '⏱️ Test your reaction speed';
            break;
          case 'whack':
            preview.textContent = '🔨 Whack the doodles!';
            break;
          case 'dice':
            preview.textContent = '🎲 Guess numbers and roll dice';
            break;
          case 'runner':
            preview.textContent = '🏃 Endless runner game';
            break;
          default:
            preview.textContent = '🎮 Mini-game preview';
        }
        return preview;
      }

      // Render games grid (Home page)
      function renderGamesGrid() {
        gamesGrid.innerHTML = '';
        for (const gameId in gamesRegistry) {
          const game = gamesRegistry[gameId];
          const tile = create('div', {
            className: 'game-tile',
            onclick: () => openGame(gameId)
          }, [
            create('div', { className: 'game-icon', innerHTML: game.icon }),
            create('h3', { className: 'game-title', textContent: game.title }),
            create('p', { className: 'game-description', textContent: game.description }),
            createGamePreview(gameId)
          ]);
          gamesGrid.appendChild(tile);
          addRippleEffect(tile);
        }
      }

      // Render game list (Sidebar)
      function renderGameList() {
        gamesList.innerHTML = '';
        for (const gameId in gamesRegistry) {
          const game = gamesRegistry[gameId];
          const listItem = create('li', {
            className: 'game-list-item',
            onclick: () => openGame(gameId)
          }, [
            create('span', { className: 'game-list-icon', innerHTML: game.icon }),
            create('span', { className: 'game-list-text', textContent: game.title })
          ]);
          gamesList.appendChild(listItem);
          if (gameId === activeGameId) {
            listItem.classList.add('active');
          }
        }
      }

      // Update active game highlight in sidebar
      function updateActiveGameHighlight(gameId) {
        activeGameId = gameId;
        qsa('.game-list-item', gamesList).forEach(item => {
          item.classList.remove('active');
          if (item.querySelector('.game-list-text').textContent === gamesRegistry[gameId]?.title) {
            item.classList.add('active');
          }
        });
      }

      // Open a game
      function openGame(gameId) {
        const game = gamesRegistry[gameId];
        if (!game) return;

        if (activeGame) {
          activeGame.destroy();
          activeGame = null;
        }

        currentGameTitle.textContent = game.title;
        gameContent.innerHTML = '';
        gameView.classList.add('active');
        activeGame = game.init(gameContent);
        gameContent.setAttribute('tabindex', '-1');
        gameContent.focus();
        SoundManager.play('click');
        updateActiveGameHighlight(gameId);

        if (window.innerWidth <= 768) {
          gameSidebar.classList.add('hidden');
        }
      }

      // Close the current game
      function closeGame() {
        if (activeGame) {
          activeGame.destroy();
          activeGame = null;
        }
        gameView.classList.remove('active');
        gamesGrid.setAttribute('tabindex', '-1');
        gamesGrid.focus();
        activeGameId = null;
        updateActiveGameHighlight(null);
      }

      // Register games
      function registerGames() {
        gamesRegistry = {
          // Snake Game
          snake: {
            id: 'snake',
            title: 'Snake Game',
            description: 'Classic snake game. Eat food and grow without hitting walls or yourself!',
            icon: '🐍',
            init(container) {
              // Game state
              const gameState = {
                snake: [{ x: 10, y: 10 }],
                direction: 'right',
                nextDirection: 'right',
                food: { x: 5, y: 5 },
                score: 0,
                highScore: scores.snake?.highScore || 0,
                gameOver: false,
                paused: false,
                level: 1,
                baseSpeed: 150,
                speed: 150,
                foodEatenThisLevel: 0,
                lastUpdate: 0,
                interpolation: 0
              };

              // Create game elements
              const gameUI = create('div', { className: 'snake-game' });
              const canvas = create('canvas', {
                className: 'snake-canvas',
                width: 400,
                height: 400
              });
              const ctx = canvas.getContext('2d');
              const scoreAnnouncer = create('div', { className: 'snake-announcer' });

              // Stats display
              const statsDiv = create('div', { className: 'snake-stats' });
              const scoreSpan = create('span', { className: 'snake-stat-item', textContent: `Score: ${gameState.score}` });
              const highScoreSpan = create('span', { className: 'snake-stat-item', textContent: `High Score: ${gameState.highScore}` });
              const levelSpan = create('span', { className: 'snake-level-display', textContent: `Level: ${gameState.level}` });
              statsDiv.append(scoreSpan, highScoreSpan, levelSpan);

              gameUI.append(statsDiv, canvas, scoreAnnouncer);
              container.appendChild(gameUI);

              // Place food at random position
              const placeFood = () => {
                let newFood, overlapping;
                do {
                  newFood = {
                    x: Math.floor(Math.random() * 20),
                    y: Math.floor(Math.random() * 20)
                  };
                  overlapping = gameState.snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
                } while (overlapping);
                gameState.food = newFood;
              };

              // Check collision
              const checkCollision = (head) => {
                // Wall collision
                if (head.x < 0 || head.x >= 20 || head.y < 0 || head.y >= 20) {
                  return true;
                }
                // Self collision
                for (let i = 0; i < gameState.snake.length; i++) {
                  if (gameState.snake[i].x === head.x && gameState.snake[i].y === head.y) {
                    return true;
                  }
                }
                return false;
              };

              // Level up
              const levelUp = () => {
                gameState.level++;
                gameState.speed = Math.max(50, gameState.baseSpeed - (gameState.level - 1) * 10);
                gameState.foodEatenThisLevel = 0;
                levelSpan.textContent = `Level: ${gameState.level}`;
                scoreAnnouncer.textContent = `Level ${gameState.level}!`;
              };

              // Game loop
              const update = (timestamp) => {
                if (gameState.paused || gameState.gameOver) return;

                // Calculate delta time for smooth movement
                if (!gameState.lastUpdate) gameState.lastUpdate = timestamp;
                const deltaTime = timestamp - gameState.lastUpdate;
                gameState.lastUpdate = timestamp;
                gameState.interpolation += deltaTime;

                // Update game state at fixed intervals
                while (gameState.interpolation >= gameState.speed) {
                  // Update direction
                  gameState.direction = gameState.nextDirection;

                  // Calculate new head position
                  const head = { ...gameState.snake[0] };
                  switch (gameState.direction) {
                    case 'up': head.y--; break;
                    case 'down': head.y++; break;
                    case 'left': head.x--; break;
                    case 'right': head.x++; break;
                  }

                  // Check collision
                  if (checkCollision(head)) {
                    gameState.gameOver = true;
                    if (gameState.score > gameState.highScore) {
                      gameState.highScore = gameState.score;
                      updateScores('snake', { highScore: gameState.highScore });
                      highScoreSpan.textContent = `High Score: ${gameState.highScore}`;
                      checkAchievement('snake_master', gameState.highScore >= 50, { score: gameState.highScore });
                    }
                    scoreAnnouncer.textContent = 'Game Over! Press Space to restart';
                    return;
                  }

                  // Add new head
                  gameState.snake.unshift(head);

                  // Check food collision
                  if (head.x === gameState.food.x && head.y === gameState.food.y) {
                    // Increase score
                    gameState.score += 10 * gameState.level;
                    scoreSpan.textContent = `Score: ${gameState.score}`;
                    SoundManager.play('eat');

                    // Place new food
                    placeFood();

                    // Level progress
                    gameState.foodEatenThisLevel++;
                    if (gameState.foodEatenThisLevel >= 5) {
                      levelUp();
                    }
                  } else {
                    // Remove tail if no food eaten
                    gameState.snake.pop();
                  }

                  gameState.interpolation -= gameState.speed;
                }

                // Draw everything
                // Clear canvas
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-background');
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.lineWidth = 0.5;
                for (let i = 0; i <= 20; i++) {
                  ctx.beginPath();
                  ctx.moveTo(i * 20, 0);
                  ctx.lineTo(i * 20, 400);
                  ctx.stroke();
                  
                  ctx.beginPath();
                  ctx.moveTo(0, i * 20);
                  ctx.lineTo(400, i * 20);
                  ctx.stroke();
                }

                // Draw snake
                gameState.snake.forEach((segment, index) => {
                  ctx.fillStyle = index === 0 
                    ? getComputedStyle(document.body).getPropertyValue('--color-primary') 
                    : colorMix(getComputedStyle(document.body).getPropertyValue('--color-primary'), '#000000', 30);
                  ctx.fillRect(segment.x * 20, segment.y * 20, 20, 20);
                  
                  // Add rounded corners for head
                  if (index === 0) {
                    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-on-primary');
                    // Draw eyes based on direction
                    switch (gameState.direction) {
                      case 'right':
                        ctx.fillRect(segment.x * 20 + 14, segment.y * 20 + 5, 3, 3);
                        ctx.fillRect(segment.x * 20 + 14, segment.y * 20 + 12, 3, 3);
                        break;
                      case 'left':
                        ctx.fillRect(segment.x * 20 + 3, segment.y * 20 + 5, 3, 3);
                        ctx.fillRect(segment.x * 20 + 3, segment.y * 20 + 12, 3, 3);
                        break;
                      case 'up':
                        ctx.fillRect(segment.x * 20 + 5, segment.y * 20 + 3, 3, 3);
                        ctx.fillRect(segment.x * 20 + 12, segment.y * 20 + 3, 3, 3);
                        break;
                      case 'down':
                        ctx.fillRect(segment.x * 20 + 5, segment.y * 20 + 14, 3, 3);
                        ctx.fillRect(segment.x * 20 + 12, segment.y * 20 + 14, 3, 3);
                        break;
                    }
                  }
                });

                // Draw food
                ctx.fillStyle = '#ff5252';
                ctx.beginPath();
                ctx.arc(
                  gameState.food.x * 20 + 10,
                  gameState.food.y * 20 + 10,
                  8,
                  0,
                  Math.PI * 2
                );
                ctx.fill();

                // Draw game over text
                if (gameState.gameOver) {
                  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                  ctx.fillRect(0, 0, canvas.width, canvas.height);
                  
                  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-on-background');
                  ctx.font = 'bold 30px sans-serif';
                  ctx.textAlign = 'center';
                  ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2);
                  ctx.font = '20px sans-serif';
                  ctx.fillText(`Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 40);
                  ctx.fillText('Press Space to Restart', canvas.width / 2, canvas.height / 2 + 80);
                  ctx.textAlign = 'left';
                }

                // Continue animation loop
                requestAnimationFrame(update);
              };

              // Handle keyboard input
              const handleKeyDown = (e) => {
                if (gameState.gameOver && e.key === ' ') {
                  // Restart game
                  gameState.snake = [{ x: 10, y: 10 }];
                  gameState.direction = 'right';
                  gameState.nextDirection = 'right';
                  gameState.score = 0;
                  gameState.gameOver = false;
                  gameState.paused = false;
                  gameState.level = 1;
                  gameState.speed = gameState.baseSpeed;
                  gameState.foodEatenThisLevel = 0;
                  gameState.lastUpdate = 0;
                  gameState.interpolation = 0;
                  scoreSpan.textContent = `Score: ${gameState.score}`;
                  levelSpan.textContent = `Level: ${gameState.level}`;
                  placeFood();
                  scoreAnnouncer.textContent = 'Game restarted';
                  SoundManager.play('click');
                  requestAnimationFrame(update);
                  return;
                }

                if (e.key === ' ') {
                  gameState.paused = !gameState.paused;
                  if (!gameState.paused) {
                    gameState.lastUpdate = 0;
                    requestAnimationFrame(update);
                  }
                  return;
                }

                if (gameState.paused || gameState.gameOver) return;

                switch (e.key) {
                  case 'ArrowUp':
                  case 'w':
                  case 'W':
                    if (gameState.direction !== 'down') gameState.nextDirection = 'up';
                    break;
                  case 'ArrowDown':
                  case 's':
                  case 'S':
                    if (gameState.direction !== 'up') gameState.nextDirection = 'down';
                    break;
                  case 'ArrowLeft':
                  case 'a':
                  case 'A':
                    if (gameState.direction !== 'right') gameState.nextDirection = 'left';
                    break;
                  case 'ArrowRight':
                  case 'd':
                  case 'D':
                    if (gameState.direction !== 'left') gameState.nextDirection = 'right';
                    break;
                }
              };

              // Initialize game
              placeFood();
              requestAnimationFrame(update);
              document.addEventListener('keydown', handleKeyDown);

              // Helper function for color mixing
              function colorMix(color1, color2, percentage) {
                // Simple color mixing approximation
                const p = percentage / 100;
                const r1 = parseInt(color1.slice(1, 3), 16);
                const g1 = parseInt(color1.slice(3, 5), 16);
                const b1 = parseInt(color1.slice(5, 7), 16);
                
                const r2 = parseInt(color2.slice(1, 3), 16);
                const g2 = parseInt(color2.slice(3, 5), 16);
                const b2 = parseInt(color2.slice(5, 7), 16);
                
                const r = Math.round(r1 * (1 - p) + r2 * p);
                const g = Math.round(g1 * (1 - p) + g2 * p);
                const b = Math.round(b1 * (1 - p) + b2 * p);
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
              }

              return {
                destroy() {
                  document.removeEventListener('keydown', handleKeyDown);
                  container.innerHTML = '';
                },
                pause() {
                  gameState.paused = true;
                },
                resume() {
                  gameState.paused = false;
                  gameState.lastUpdate = 0;
                  requestAnimationFrame(update);
                },
                restart() {
                  gameState.snake = [{ x: 10, y: 10 }];
                  gameState.direction = 'right';
                  gameState.nextDirection = 'right';
                  gameState.score = 0;
                  gameState.gameOver = false;
                  gameState.paused = false;
                  gameState.level = 1;
                  gameState.speed = gameState.baseSpeed;
                  gameState.foodEatenThisLevel = 0;
                  gameState.lastUpdate = 0;
                  gameState.interpolation = 0;
                  scoreSpan.textContent = `Score: ${gameState.score}`;
                  levelSpan.textContent = `Level: ${gameState.level}`;
                  placeFood();
                  scoreAnnouncer.textContent = 'Game restarted';
                  SoundManager.play('click');
                }
              };
            }
          },

          // Enhanced Tic-Tac-Toe with Minimax AI and 2P Mode
          tictactoe: {
            id: 'tictactoe',
            title: 'Tic-Tac-Toe',
            description: 'Classic X and O game. Play against AI (Minimax) or a friend!',
            icon: '⭕',
            init(container) {
              let currentPlayer = 'X';
              let gameBoard = ['', '', '', '', '', '', '', '', ''];
              let gameActive = true;
              let isTwoPlayer = false; // Default to AI mode
              let playerScore = scores.tictactoe?.playerWins || 0;
              let aiScore = scores.tictactoe?.aiWins || 0;
              let draws = scores.tictactoe?.draws || 0;

              // Create game elements
              const gameElement = create('div', { className: 'tictactoe-game' });
              const statusElement = create('div', { 
                className: 'tictactoe-status', 
                textContent: isTwoPlayer ? `Player ${currentPlayer}'s turn` : `Player ${currentPlayer}'s turn` 
              });
              const boardElement = create('div', { className: 'tictactoe-board' });
              const scoreElement = create('div', { 
                className: 'tictactoe-score', 
                textContent: `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}` 
              });
              
              const controlsElement = create('div', { className: 'tictactoe-controls' });
              const modeButton = create('button', { 
                className: 'btn btn-secondary', 
                textContent: 'Mode: vs AI' 
              });
              const restartButton = create('button', { 
                className: 'btn btn-primary', 
                textContent: 'Restart' 
              });
              
              controlsElement.append(modeButton, restartButton);

              // Create cells
              const cells = [];
              for (let i = 0; i < 9; i++) {
                const cell = create('div', {
                  className: 'tictactoe-cell',
                  onclick: () => handleCellClick(i)
                });
                cells.push(cell);
                boardElement.appendChild(cell);
              }

              gameElement.append(statusElement, boardElement, scoreElement, controlsElement);
              container.appendChild(gameElement);

              // Handle cell click
              function handleCellClick(index) {
                if (!gameActive || gameBoard[index] !== '') return;

                // Make player move
                makeMove(index, currentPlayer);

                // Check game result
                const result = checkGameResult();
                if (result) {
                  handleGameEnd(result);
                  return;
                }

                // Switch player
                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                updateStatus();

                // If playing against AI and it's AI's turn
                if (!isTwoPlayer && currentPlayer === 'O' && gameActive) {
                  // AI makes a move after a short delay
                  setTimeout(() => {
                    if (gameActive) {
                      const aiMove = getBestMove(gameBoard);
                      makeMove(aiMove, 'O');
                      
                      // Check game result again
                      const result = checkGameResult();
                      if (result) {
                        handleGameEnd(result);
                        return;
                      }
                      
                      // Switch back to player
                      currentPlayer = 'X';
                      updateStatus();
                    }
                  }, 500);
                }
              }

              // Make a move on the board
              function makeMove(index, player) {
                gameBoard[index] = player;
                cells[index].textContent = player;
                SoundManager.play('click');
              }

              // Update status text
              function updateStatus() {
                if (gameActive) {
                  statusElement.textContent = isTwoPlayer 
                    ? `Player ${currentPlayer}'s turn` 
                    : `Player ${currentPlayer}'s turn`;
                }
              }

              // Check game result (win, draw, or ongoing)
              function checkGameResult() {
                // Winning combinations
                const winPatterns = [
                  [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                  [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                  [0, 4, 8], [2, 4, 6]             // diagonals
                ];

                // Check for win
                for (const pattern of winPatterns) {
                  const [a, b, c] = pattern;
                  if (gameBoard[a] && gameBoard[a] === gameBoard[b] && gameBoard[a] === gameBoard[c]) {
                    // Highlight winning cells
                    pattern.forEach(index => cells[index].classList.add('win'));
                    return gameBoard[a]; // Return the winning player
                  }
                }

                // Check for draw
                if (!gameBoard.includes('')) {
                  return 'draw';
                }

                // Game ongoing
                return null;
              }

              // Handle game end
              function handleGameEnd(result) {
                gameActive = false;
                
                if (result === 'draw') {
                  statusElement.textContent = "It's a draw!";
                  draws++;
                  updateScores('tictactoe', { draws });
                  checkAchievement('tic_master', draws >= 10, { draws });
                } else {
                  statusElement.textContent = `Player ${result} wins!`;
                  if (result === 'X') {
                    playerScore++;
                    updateScores('tictactoe', { playerWins: playerScore });
                  } else {
                    if (isTwoPlayer) {
                      playerScore++; // Player O in 2P mode
                      updateScores('tictactoe', { playerWins: playerScore });
                    } else {
                      aiScore++; // AI wins
                      updateScores('tictactoe', { aiWins: aiScore });
                    }
                  }
                  checkAchievement('tic_master', playerScore >= 10, { wins: playerScore });
                }
                
                scoreElement.textContent = `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}`;
                SoundManager.play(result === 'draw' ? 'error' : 'success');
              }

              // Minimax algorithm with alpha-beta pruning
              function minimax(board, depth, isMaximizing, alpha, beta) {
                // Check terminal states
                const result = checkWinner(board);
                if (result !== null) {
                  if (result === 'O') return 10 - depth; // AI wins
                  if (result === 'X') return depth - 10; // Human wins
                  if (result === 'draw') return 0; // Draw
                }

                if (isMaximizing) {
                  let bestScore = -Infinity;
                  for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                      board[i] = 'O';
                      const score = minimax(board, depth + 1, false, alpha, beta);
                      board[i] = ''; // Undo move
                      bestScore = Math.max(score, bestScore);
                      alpha = Math.max(alpha, score);
                      if (beta <= alpha) break; // Alpha-beta pruning
                    }
                  }
                  return bestScore;
                } else {
                  let bestScore = Infinity;
                  for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                      board[i] = 'X';
                      const score = minimax(board, depth + 1, true, alpha, beta);
                      board[i] = ''; // Undo move
                      bestScore = Math.min(score, bestScore);
                      beta = Math.min(beta, score);
                      if (beta <= alpha) break; // Alpha-beta pruning
                    }
                  }
                  return bestScore;
                }
              }

              // Find the best move for the AI
              function getBestMove(board) {
                let bestScore = -Infinity;
                let bestMove = null;
                for (let i = 0; i < 9; i++) {
                  if (board[i] === '') {
                    board[i] = 'O';
                    const score = minimax(board, 0, false, -Infinity, Infinity);
                    board[i] = ''; // Undo move
                    if (score > bestScore) {
                      bestScore = score;
                      bestMove = i;
                    }
                  }
                }
                return bestMove;
              }

              // Check winner for minimax
              function checkWinner(board) {
                // Winning combinations
                const winPatterns = [
                  [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                  [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                  [0, 4, 8], [2, 4, 6]             // diagonals
                ];

                // Check for win
                for (const pattern of winPatterns) {
                  const [a, b, c] = pattern;
                  if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a]; // Return the winning player
                  }
                }

                // Check for draw
                if (!board.includes('')) {
                  return 'draw';
                }

                // Game ongoing
                return null;
              }

              // Toggle game mode
              modeButton.addEventListener('click', () => {
                isTwoPlayer = !isTwoPlayer;
                modeButton.textContent = isTwoPlayer ? 'Mode: 2 Players' : 'Mode: vs AI';
                restartGame();
                SoundManager.play('click');
              });

              // Restart game
              function restartGame() {
                gameBoard = ['', '', '', '', '', '', '', '', ''];
                currentPlayer = 'X';
                gameActive = true;
                statusElement.textContent = isTwoPlayer 
                  ? `Player ${currentPlayer}'s turn` 
                  : `Player ${currentPlayer}'s turn`;
                cells.forEach(cell => {
                  cell.textContent = '';
                  cell.classList.remove('win');
                });
                scoreElement.textContent = `X: ${playerScore} | O: ${isTwoPlayer ? playerScore : aiScore} | Draws: ${draws}`;
                SoundManager.play('click');
              }

              restartButton.addEventListener('click', restartGame);

              return {
                destroy() {
                  container.innerHTML = '';
                },
                pause() {
                  // Pause logic if needed
                },
                resume() {
                  // Resume logic if needed
                },
                restart: restartGame
              };
            }
          },

          // Memory Game
          memory: {
            id: 'memory',
            title: 'Memory Game',
            description: 'Match pairs of cards in the least moves and time!',
            icon: '🧠',
            init(container) {
              const emojis = ['🚀', '🌟', '🎯', '🎨', '🎭', '🎬', '🎧', '🎮'];
              let gameCards = [...emojis, ...emojis].sort(() => 0.5 - Math.random());
              let flippedCards = [];
              let matchedPairs = 0;
              let moves = 0;
              let gameStarted = false;
              let seconds = 0;
              let timerInterval = null;
              let bestTime = scores.memory?.bestTime || null;

              // Create game elements
              const gameElement = create('div', { className: 'memory-game' });
              const boardElement = create('div', { className: 'memory-board' });
              const movesElement = create('div', { className: 'memory-stat-item', textContent: `Moves: ${moves}` });
              const timerElement = create('div', { className: 'memory-stat-item', textContent: `Time: ${seconds}s` });
              const bestTimeElement = create('div', { className: 'memory-stat-item', textContent: bestTime ? `Best: ${bestTime}s` : 'Best: --' });
              
              const statsElement = create('div', { className: 'memory-stats' });
              statsElement.append(movesElement, timerElement, bestTimeElement);
              
              const restartButton = create('button', { className: 'btn btn-secondary', textContent: 'Restart' });

              // Create cards
              const cards = gameCards.map((emoji, index) => {
                const card = create('div', {
                  className: 'memory-card',
                  textContent: '',
                  onclick: () => flipCard(card, index)
                });
                card.dataset.emoji = emoji;
                card.dataset.index = index;
                return card;
              });

              boardElement.append(...cards);
              gameElement.append(statsElement, boardElement, restartButton);
              container.appendChild(gameElement);

              // Start timer
              function startTimer() {
                if (!gameStarted) {
                  gameStarted = true;
                  timerInterval = setInterval(() => {
                    seconds++;
                    timerElement.textContent = `Time: ${seconds}s`;
                  }, 1000);
                }
              }

              // Flip card
              function flipCard(card, index) {
                if (!gameStarted) startTimer();
                if (flippedCards.length < 2 && !card.classList.contains('flipped') && !card.classList.contains('matched')) {
                  card.classList.add('flipped');
                  card.textContent = card.dataset.emoji;
                  flippedCards.push({ card, index });
                  SoundManager.play('click');

                  if (flippedCards.length === 2) {
                    moves++;
                    movesElement.textContent = `Moves: ${moves}`;
                    
                    const card1 = flippedCards[0];
                    const card2 = flippedCards[1];
                    
                    if (card1.card.dataset.emoji === card2.card.dataset.emoji) {
                      // Match found
                      card1.card.classList.add('matched');
                      card2.card.classList.add('matched');
                      matchedPairs++;
                      flippedCards = [];
                      SoundManager.play('success');
                      
                      // Check for win
                      if (matchedPairs === emojis.length) {
                        clearInterval(timerInterval);
                        if (bestTime === null || seconds < bestTime) {
                          bestTime = seconds;
                          updateScores('memory', { bestTime });
                          bestTimeElement.textContent = `Best: ${bestTime}s`;
                          checkAchievement('memory_champ', bestTime <= 30, { time: bestTime });
                        }
                        setTimeout(() => {
                          Toast.show(`You won in ${moves} moves and ${seconds} seconds!`, 'success');
                        }, 500);
                      }
                    } else {
                      // No match
                      setTimeout(() => {
                        card1.card.classList.remove('flipped');
                        card2.card.classList.remove('flipped');
                        card1.card.textContent = '';
                        card2.card.textContent = '';
                        flippedCards = [];
                        SoundManager.play('error');
                      }, 1000);
                    }
                  }
                }
              }

              // Restart game
              function restartGame() {
                clearInterval(timerInterval);
                gameCards = [...emojis, ...emojis].sort(() => 0.5 - Math.random());
                flippedCards = [];
                matchedPairs = 0;
                moves = 0;
                gameStarted = false;
                seconds = 0;
                movesElement.textContent = `Moves: ${moves}`;
                timerElement.textContent = `Time: ${seconds}s`;
                cards.forEach((card, index) => {
                  card.classList.remove('flipped', 'matched');
                  card.textContent = '';
                  card.dataset.emoji = gameCards[index];
                });
                SoundManager.play('click');
              }

              restartButton.addEventListener('click', restartGame);

              return {
                destroy() {
                  clearInterval(timerInterval);
                  container.innerHTML = '';
                },
                pause() {
                  if (gameStarted && matchedPairs < emojis.length) {
                    clearInterval(timerInterval);
                  }
                },
                resume() {
                  if (gameStarted && matchedPairs < emojis.length) {
                    timerInterval = setInterval(() => {
                      seconds++;
                      timerElement.textContent = `Time: ${seconds}s`;
                    }, 1000);
                  }
                },
                restart: restartGame
              };
            }
          },

          // Reaction Tester Game
          reaction: {
            id: 'reaction',
            title: 'Reaction Tester',
            description: 'Test your reaction speed',
            icon: '⏱️',
            init(container) {
              let state = 'ready'; // 'ready', 'wait', 'go', 'result'
              let startTime, endTime;
              let bestTime = scores.reaction?.bestTime !== undefined ? scores.reaction.bestTime : null;
              let attempts = scores.reaction?.attempts || 0;

              // Create game elements
              const gameElement = create('div', { className: 'reaction-game' });
              const displayElement = create('div', {
                className: 'reaction-display reaction-ready',
                textContent: 'Click to Start'
              });
              const resultElement = create('div', {
                className: 'reaction-result',
                textContent: bestTime ? `Best: ${bestTime.toFixed(3)}s` : 'Best: --'
              });
              const attemptsElement = create('div', {
                className: 'reaction-attempts',
                textContent: `Attempts: ${attempts}`
              });

              displayElement.addEventListener('click', handleClick);
              gameElement.append(displayElement, resultElement, attemptsElement);
              container.appendChild(gameElement);

              function handleClick() {
                if (state === 'ready') {
                  state = 'wait';
                  displayElement.className = 'reaction-display reaction-wait';
                  displayElement.textContent = 'Wait...';
                  const delay = Math.random() * 3000 + 1000;
                  setTimeout(() => {
                    if (state === 'wait') {
                      state = 'go';
                      startTime = Date.now();
                      displayElement.className = 'reaction-display reaction-go';
                      displayElement.textContent = 'CLICK NOW!';
                    }
                  }, delay);
                  SoundManager.play('click');
                } else if (state === 'wait') {
                  state = 'ready';
                  displayElement.className = 'reaction-display reaction-ready';
                  displayElement.textContent = 'Too Early! Click to Restart';
                  SoundManager.play('error');
                } else if (state === 'go') {
                  endTime = Date.now();
                  const reactionTime = (endTime - startTime) / 1000;
                  state = 'result';
                  displayElement.className = 'reaction-display reaction-ready';
                  displayElement.textContent = 'Click to Restart';
                  resultElement.textContent = `Reaction Time: ${reactionTime.toFixed(3)}s`;
                  attempts++;
                  attemptsElement.textContent = `Attempts: ${attempts}`;
                  
                  if (bestTime === null || reactionTime < bestTime) {
                    bestTime = reactionTime;
                    updateScores('reaction', { bestTime: bestTime, attempts: attempts });
                    resultElement.textContent += ' (New Best!)';
                    checkAchievement('speed_demon', bestTime < 0.2, { time: bestTime });
                  } else {
                    updateScores('reaction', { attempts: attempts });
                  }
                  SoundManager.play('success');
                } else if (state === 'result') {
                  state = 'ready';
                  displayElement.className = 'reaction-display reaction-ready';
                  displayElement.textContent = 'Click to Start';
                  resultElement.textContent = bestTime ? `Best: ${bestTime.toFixed(3)}s` : 'Best: --';
                  SoundManager.play('click');
                }
              }

              return {
                destroy() {
                  container.innerHTML = '';
                },
                pause() {
                  // Pause logic
                },
                resume() {
                  // Resume logic
                },
                restart() {
                  state = 'ready';
                  displayElement.className = 'reaction-display reaction-ready';
                  displayElement.textContent = 'Click to Start';
                  resultElement.textContent = bestTime ? `Best: ${bestTime.toFixed(3)}s` : 'Best: --';
                  SoundManager.play('click');
                }
              };
            }
          },

          // Whack-a-Doodle Game
          whack: {
            id: 'whack',
            title: 'Whack-a-Doodle',
            description: 'Whack the doodles as they appear',
            icon: '🔨',
            init(container) {
              let score = 0;
              let timeLeft = 30;
              let gameActive = false;
              let timerInterval = null;
              let popInterval = null;
              const highScore = scores.whack?.highScore || 0;

              // Create game elements
              const gameElement = create('div', { className: 'whack-game' });
              const boardElement = create('div', { className: 'whack-board' });
              const scoreElement = create('div', { className: 'whack-stat-item', textContent: `Score: ${score}` });
              const timeElement = create('div', { className: 'whack-stat-item', textContent: `Time: ${timeLeft}s` });
              const highScoreElement = create('div', { className: 'whack-stat-item', textContent: `High Score: ${highScore}` });
              
              const statsElement = create('div', { className: 'whack-stats' });
              statsElement.append(scoreElement, timeElement, highScoreElement);
              
              const startButton = create('button', { className: 'btn btn-primary', textContent: 'Start Game' });

              // Create holes
              const holes = [];
              for (let i = 0; i < 9; i++) {
                const hole = create('div', { className: 'whack-hole' });
                const doodle = create('div', { className: 'whack-doodle' });
                doodle.addEventListener('click', () => whackDoodle(doodle));
                hole.appendChild(doodle);
                boardElement.appendChild(hole);
                holes.push(hole);
              }

              gameElement.append(statsElement, boardElement, startButton);
              container.appendChild(gameElement);

              // Start game
              function startGame() {
                if (gameActive) return;
                gameActive = true;
                score = 0;
                timeLeft = 30;
                scoreElement.textContent = `Score: ${score}`;
                timeElement.textContent = `Time: ${timeLeft}s`;
                startButton.disabled = true;
                startButton.textContent = 'Game Running...';

                timerInterval = setInterval(() => {
                  timeLeft--;
                  timeElement.textContent = `Time: ${timeLeft}s`;
                  if (timeLeft <= 0) {
                    endGame();
                  }
                }, 1000);

                popInterval = setInterval(popDoodle, 800);
                SoundManager.play('click');
              }

              // Pop a doodle
              function popDoodle() {
                if (!gameActive) return;
                const randomHole = holes[Math.floor(Math.random() * holes.length)];
                const doodle = randomHole.querySelector('.whack-doodle');
                if (!doodle.classList.contains('up')) {
                  doodle.classList.add('up');
                  setTimeout(() => {
                    if (gameActive) {
                      doodle.classList.remove('up');
                    }
                  }, 600);
                }
              }

              // Whack a doodle
              function whackDoodle(doodle) {
                if (!gameActive || !doodle.classList.contains('up')) return;
                score++;
                scoreElement.textContent = `Score: ${score}`;
                doodle.classList.remove('up');
                SoundManager.play('success');
                checkAchievement('whack_streak', score >= 30, { score });
              }

              // End game
              function endGame() {
                gameActive = false;
                clearInterval(timerInterval);
                clearInterval(popInterval);
                startButton.disabled = false;
                startButton.textContent = 'Start Game';
                
                holes.forEach(hole => {
                  const doodle = hole.querySelector('.whack-doodle');
                  doodle.classList.remove('up');
                });
                
                if (score > highScore) {
                  updateScores('whack', { highScore: score });
                  highScoreElement.textContent = `High Score: ${score}`;
                  Toast.show(`New High Score: ${score}!`, 'success');
                }
                SoundManager.play('click');
              }

              startButton.addEventListener('click', startGame);

              return {
                destroy() {
                  clearInterval(timerInterval);
                  clearInterval(popInterval);
                  container.innerHTML = '';
                },
                pause() {
                  if (gameActive) {
                    clearInterval(timerInterval);
                    clearInterval(popInterval);
                  }
                },
                resume() {
                  if (gameActive) {
                    timerInterval = setInterval(() => {
                      timeLeft--;
                      timeElement.textContent = `Time: ${timeLeft}s`;
                      if (timeLeft <= 0) {
                        endGame();
                      }
                    }, 1000);
                    popInterval = setInterval(popDoodle, 800);
                  }
                },
                restart() {
                  if (gameActive) {
                    endGame();
                  }
                  setTimeout(startGame, 100);
                }
              };
            }
          },

          // Dice Game
          dice: {
            id: 'dice',
            title: 'Guess & Dice',
            description: 'Guess numbers and roll dice',
            icon: '🎲',
            init(container) {
              let totalScore = scores.dice?.totalScore || 0;
              let rolls = scores.dice?.rolls || 0;
              let correctGuesses = scores.dice?.correctGuesses || 0;

              // Create game elements
              const gameElement = create('div', { className: 'dice-game' });
              const displayElement = create('div', { className: 'dice-display' });
              const dice1 = create('div', { className: 'dice', textContent: '?' });
              const dice2 = create('div', { className: 'dice', textContent: '?' });
              displayElement.append(dice1, dice2);

              const controlsElement = create('div', { className: 'dice-controls' });
              const guessElement = create('div', { className: 'dice-guess' });
              const guessLabel = create('span', { textContent: 'Guess (2-12):' });
              const guessInput = create('input', { 
                type: 'number', 
                min: '2', 
                max: '12', 
                value: '7' 
              });
              guessElement.append(guessLabel, guessInput);

              const rollButton = create('button', { 
                className: 'btn btn-primary', 
                textContent: 'Roll Dice' 
              });

              const resultElement = create('div', { 
                className: 'dice-result', 
                textContent: 'Roll the dice!' 
              });
              const statsElement = create('div', { 
                className: 'dice-stats', 
                textContent: `Total Score: ${totalScore} | Rolls: ${rolls} | Correct: ${correctGuesses}` 
              });

              controlsElement.append(guessElement, rollButton, resultElement);
              gameElement.append(displayElement, controlsElement, statsElement);
              container.appendChild(gameElement);

              // Roll dice
              function rollDice() {
                const guess = parseInt(guessInput.value);
                if (isNaN(guess) || guess < 2 || guess > 12) {
                  resultElement.textContent = 'Please enter a valid guess between 2 and 12';
                  return;
                }

                // Rolling animation
                dice1.textContent = '?';
                dice2.textContent = '?';
                resultElement.textContent = 'Rolling...';
                SoundManager.play('click');

                setTimeout(() => {
                  const die1 = Math.floor(Math.random() * 6) + 1;
                  const die2 = Math.floor(Math.random() * 6) + 1;
                  const sum = die1 + die2;

                  dice1.textContent = die1;
                  dice2.textContent = die2;

                  rolls++;
                  let roundScore = 0;
                  let message = `You rolled ${sum}. `;

                  if (sum === guess) {
                    roundScore += 10;
                    correctGuesses++;
                    message += 'Correct guess! +10 points. ';
                    SoundManager.play('success');
                    checkAchievement('lucky_roller', correctGuesses >= 5, { correct: correctGuesses });
                  } else {
                    message += 'Wrong guess. ';
                    SoundManager.play('error');
                  }

                  if (sum === 7) {
                    roundScore += 5;
                    message += 'Lucky 7! +5 points.';
                    SoundManager.play('success');
                  }

                  totalScore += roundScore;
                  resultElement.textContent = message;
                  statsElement.textContent = `Total Score: ${totalScore} | Rolls: ${rolls} | Correct: ${correctGuesses}`;
                  updateScores('dice', { totalScore, rolls, correctGuesses });
                }, 1000);
              }

              rollButton.addEventListener('click', rollDice);

              return {
                destroy() {
                  container.innerHTML = '';
                },
                pause() {
                  // Pause logic
                },
                resume() {
                  // Resume logic
                },
                restart() {
                  guessInput.value = '7';
                  dice1.textContent = '?';
                  dice2.textContent = '?';
                  resultElement.textContent = 'Roll the dice!';
                  SoundManager.play('click');
                }
              };
            }
          },

          // Enhanced Shaikh's Runner Game
          runner: {
            id: 'runner',
            title: 'Shaikh\'s Runner',
            description: 'Endless runner game. Jump over obstacles!',
            icon: '🏃',
            init(container) {
              // Create game elements
              const gameElement = create('div', { className: 'runner-game' });
              const canvas = create('canvas', {
                className: 'runner-canvas',
                width: 600,
                height: 300
              });
              const statsElement = create('div', { 
                className: 'runner-stats', 
                textContent: 'Score: 0 | High Score: 0' 
              });
              
              const controlsElement = create('div', { className: 'runner-controls' });
              const startButton = create('button', { 
                className: 'btn btn-primary', 
                textContent: 'Start / Jump' 
              });
              const pauseButton = create('button', { 
                className: 'btn btn-secondary', 
                textContent: 'Pause' 
              });
              controlsElement.append(startButton, pauseButton);

              gameElement.append(canvas, statsElement, controlsElement);
              container.appendChild(gameElement);

              // Initialize the runner game logic
              const RunnerGame = {
                canvas: canvas,
                ctx: canvas.getContext('2d'),
                player: {
                  x: 50,
                  y: 250,
                  width: 40,
                  height: 40,
                  velocityY: 0,
                  jumping: false
                },
                gravity: 0.5,
                jumpForce: -12,
                obstacles: [],
                score: 0,
                highScore: scores.runner?.highScore || 0,
                gameSpeed: 5,
                obstacleSpawnTimer: 0,
                gameActive: false,
                lastTime: 0,
                
                init() {
                  this.reset();
                  this.gameActive = true;
                  this.lastTime = performance.now();
                  this.update();
                },
                
                reset() {
                  this.player.y = 250;
                  this.player.velocityY = 0;
                  this.player.jumping = false;
                  this.obstacles = [];
                  this.score = 0;
                  this.gameSpeed = 5;
                  this.obstacleSpawnTimer = 0;
                  this.gameActive = true;
                  statsElement.textContent = `Score: ${this.score} | High Score: ${this.highScore}`;
                },
                
                jump() {
                  if (!this.gameActive) {
                    this.reset();
                    this.gameActive = true;
                    this.lastTime = performance.now();
                    this.update(); // Restart animation loop
                    return;
                  }
                  
                  if (!this.player.jumping) {
                    this.player.velocityY = this.jumpForce;
                    this.player.jumping = true;
                    SoundManager.play('click');
                  }
                },
                
                update(currentTime = 0) {
                  if (!this.gameActive) return;
                  
                  const deltaTime = currentTime - this.lastTime;
                  this.lastTime = currentTime;
                  
                  // Clear canvas
                  this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                  
                  // Draw background
                  this.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-background');
                  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                  
                  // Update player
                  this.player.velocityY += this.gravity;
                  this.player.y += this.player.velocityY;
                  
                  // Ground collision
                  if (this.player.y > this.canvas.height - this.player.height) {
                    this.player.y = this.canvas.height - this.player.height;
                    this.player.velocityY = 0;
                    this.player.jumping = false;
                  }
                  
                  // Spawn obstacles
                  this.obstacleSpawnTimer += deltaTime;
                  if (this.obstacleSpawnTimer > 1500 - (this.score / 100) * 200) { // Increase frequency with score
                    this.obstacles.push({
                      x: this.canvas.width,
                      y: this.canvas.height - 40,
                      width: 20,
                      height: 40
                    });
                    this.obstacleSpawnTimer = 0;
                  }
                  
                  // Update obstacles
                  for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.x -= this.gameSpeed;
                    
                    // Remove off-screen obstacles
                    if (obstacle.x + obstacle.width < 0) {
                      this.obstacles.splice(i, 1);
                      this.score += 1;
                      if (this.score > this.highScore) {
                        this.highScore = this.score;
                        updateScores('runner', { highScore: this.highScore });
                        statsElement.textContent = `Score: ${this.score} | High Score: ${this.highScore}`;
                        checkAchievement('runner_pro', this.highScore >= 100, { score: this.highScore });
                      }
                      statsElement.textContent = `Score: ${this.score} | High Score: ${this.highScore}`;
                    }
                    
                    // Collision detection
                    if (
                      this.player.x < obstacle.x + obstacle.width &&
                      this.player.x + this.player.width > obstacle.x &&
                      this.player.y < obstacle.y + obstacle.height &&
                      this.player.y + this.player.height > obstacle.y
                    ) {
                      // Game over
                      this.gameActive = false;
                      this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                      
                      this.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-on-background');
                      this.ctx.font = 'bold 30px sans-serif';
                      this.ctx.textAlign = 'center';
                      this.ctx.fillText('Game Over!', this.canvas.width / 2, this.canvas.height / 2);
                      this.ctx.font = '20px sans-serif';
                      this.ctx.fillText(`Score: ${this.score} | High Score: ${this.highScore}`, this.canvas.width / 2, this.canvas.height / 2 + 40);
                      this.ctx.fillText('Click or Press Space to Restart', this.canvas.width / 2, this.canvas.height / 2 + 80);
                      this.ctx.textAlign = 'left';
                      return;
                    }
                  }
                  
                  // Increase game speed over time
                  this.gameSpeed = 5 + Math.floor(this.score / 10) * 0.5;
                  
                  // Draw player
                  this.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-primary');
                  this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                  
                  // Draw obstacles
                  this.ctx.fillStyle = '#ff5252';
                  this.obstacles.forEach(obstacle => {
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                  });
                  
                  // Draw ground
                  this.ctx.fillStyle = '#795548';
                  this.ctx.fillRect(0, this.canvas.height - 20, this.canvas.width, 20);
                  
                  // Draw score
                  this.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-on-background');
                  this.ctx.font = '20px sans-serif';
                  this.ctx.fillText(`Score: ${this.score}`, 20, 30);
                  
                  // Continue animation loop
                  requestAnimationFrame((time) => this.update(time));
                },
                
                destroy() {
                  this.gameActive = false;
                }
              };

              // Update stats display periodically
              const updateStatsDisplay = () => {
                if (RunnerGame.gameActive) {
                  statsElement.textContent = `Score: ${RunnerGame.score} | High Score: ${RunnerGame.highScore}`;
                }
              };
              
              const statsInterval = setInterval(updateStatsDisplay, 100); // Update every 100ms

              startButton.addEventListener('click', () => {
                RunnerGame.jump();
              });

              pauseButton.addEventListener('click', () => {
                RunnerGame.gameActive = !RunnerGame.gameActive;
                pauseButton.textContent = RunnerGame.gameActive ? 'Pause' : 'Resume';
                if (RunnerGame.gameActive) {
                  RunnerGame.lastTime = performance.now();
                  RunnerGame.update(RunnerGame.lastTime);
                }
              });

              // Handle keyboard controls
              const handleKeyDown = (e) => {
                if ((e.key === ' ' || e.key === 'ArrowUp') && RunnerGame.gameActive) {
                  RunnerGame.jump();
                }
                
                if (e.key === 'p' || e.key === 'P') {
                  RunnerGame.gameActive = !RunnerGame.gameActive;
                  pauseButton.textContent = RunnerGame.gameActive ? 'Pause' : 'Resume';
                  if (RunnerGame.gameActive) {
                    RunnerGame.lastTime = performance.now();
                    RunnerGame.update(RunnerGame.lastTime);
                  }
                }
              };

              document.addEventListener('keydown', handleKeyDown);

              return {
                destroy() {
                  clearInterval(statsInterval);
                  RunnerGame.destroy();
                  document.removeEventListener('keydown', handleKeyDown);
                  container.innerHTML = '';
                },
                pause() {
                  RunnerGame.gameActive = false;
                  pauseButton.textContent = 'Resume';
                },
                resume() {
                  if (!RunnerGame.gameActive) { // Only resume if it was paused
                    RunnerGame.gameActive = true;
                    pauseButton.textContent = 'Pause';
                    RunnerGame.lastTime = performance.now();
                    RunnerGame.update(RunnerGame.lastTime);
                  }
                },
                restart() {
                  RunnerGame.reset();
                  RunnerGame.gameActive = true;
                  pauseButton.textContent = 'Pause';
                  RunnerGame.lastTime = performance.now();
                  RunnerGame.update(RunnerGame.lastTime);
                  SoundManager.play('click');
                }
              };
            }
          }
        };
      }

      // DOM elements
      const gamesGrid = qs('#gamesGrid');
      const gamesList = qs('#gamesList');
      const gameSidebar = qs('#gameSidebar');
      const toggleSidebar = qs('#toggleSidebar');
      const gameView = qs('#gameView');
      const gameContent = qs('#gameContent');
      const currentGameTitle = qs('#currentGameTitle');
      const gameSearch = qs('#gameSearch');
      const backButton = qs('#backButton');
      const soundToggle = qs('#soundToggle');
      const themeToggle = qs('#themeToggle');
      const settingsButton = qs('#settingsButton');
      const profileButton = qs('#profileButton');
      const gamePause = qs('#gamePause');
      const gameRestart = qs('#gameRestart');
      const gameInfo = qs('#gameInfo');

      // Modals
      const settingsModal = qs('#settingsModal');
      const profileModal = qs('#profileModal');
      const onboardingModal = qs('#onboardingModal');
      const closeSettings = qs('#closeSettings');
      const closeProfile = qs('#closeProfile');
      const closeOnboarding = qs('#closeOnboarding');
      const soundToggleSetting = qs('#soundToggleSetting');
      const volumeSlider = qs('#volumeSlider');
      const themeSelect = qs('#themeSelect');
      const onboardingToggle = qs('#onboardingToggle');
      const resetProgress = qs('#resetProgress');
      const saveSettings = qs('#saveSettings');
      const startPlaying = qs('#startPlaying');

      // Event listeners
      toggleSidebar.addEventListener('click', () => {
        gameSidebar.classList.toggle('hidden');
        SoundManager.play('click');
      });

      backButton.addEventListener('click', () => {
        closeGame();
        SoundManager.play('click');
      });

      soundToggle.addEventListener('click', () => {
        settings.soundOn = !settings.soundOn;
        applySettings();
        saveData();
        SoundManager.play('click');
      });

      themeToggle.addEventListener('click', () => {
        settings.theme = settings.theme === 'light' ? 'dark' : 'light';
        applySettings();
        saveData();
        SoundManager.play('click');
      });

      settingsButton.addEventListener('click', () => {
        settingsModal.classList.add('active');
        SoundManager.play('click');
      });

      profileButton.addEventListener('click', () => {
        // Populate achievements
        const achievementsList = qs('#achievementsList');
        achievementsList.innerHTML = '';
        let hasAchievements = false;
        
        for (const [id, achievement] of Object.entries(achievements)) {
          hasAchievements = true;
          const achievementEl = create('div', { className: 'achievement-item' });
          achievementEl.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
              <span style="font-size: 24px; margin-right: 10px;">🏆</span>
              <div>
                <strong>${id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</strong>
                <p>Unlocked on ${new Date(achievement.timestamp).toLocaleDateString()}</p>
              </div>
            </div>
          `;
          achievementsList.appendChild(achievementEl);
        }
        
        if (!hasAchievements) {
          achievementsList.innerHTML = '<p>No achievements yet. Start playing!</p>';
        }
        
        // Populate high scores
        const highScoresList = qs('#highScoresList');
        highScoresList.innerHTML = '';
        let hasScores = false;
        
        for (const [gameId, gameScores] of Object.entries(scores)) {
          hasScores = true;
          const scoreEl = create('div', { className: 'score-item' });
          scoreEl.innerHTML = `
            <h5>${gameId.replace(/\b\w/g, l => l.toUpperCase())}</h5>
            <pre style="white-space: pre-wrap;">${JSON.stringify(gameScores, null, 2)}</pre>
          `;
          highScoresList.appendChild(scoreEl);
        }
        
        if (!hasScores) {
          highScoresList.innerHTML = '<p>No scores recorded yet.</p>';
        }
        
        profileModal.classList.add('active');
        SoundManager.play('click');
      });

      gamePause.addEventListener('click', () => {
        if (activeGame && activeGame.pause) {
          activeGame.pause();
          SoundManager.play('click');
        }
      });

      gameRestart.addEventListener('click', () => {
        if (activeGame && activeGame.restart) {
          activeGame.restart();
          SoundManager.play('click');
        }
      });

      gameInfo.addEventListener('click', () => {
        Toast.show('Game information would appear here', 'info');
        SoundManager.play('click');
      });

      closeSettings.addEventListener('click', () => {
        settingsModal.classList.remove('active');
        SoundManager.play('click');
      });

      closeProfile.addEventListener('click', () => {
        profileModal.classList.remove('active');
        SoundManager.play('click');
      });

      closeOnboarding.addEventListener('click', () => {
        onboardingModal.classList.remove('active');
        SoundManager.play('click');
      });

      startPlaying.addEventListener('click', () => {
        onboardingModal.classList.remove('active');
        SoundManager.play('click');
      });

      // Settings form events
      soundToggleSetting.addEventListener('change', () => {
        settings.soundOn = soundToggleSetting.checked;
        applySettings();
        saveData();
      });

      volumeSlider.addEventListener('input', () => {
        settings.volume = parseFloat(volumeSlider.value);
        SoundManager.volume = settings.volume;
        saveData();
      });

      themeSelect.addEventListener('change', () => {
        settings.theme = themeSelect.value;
        applySettings();
        saveData();
      });

      onboardingToggle.addEventListener('change', () => {
        settings.showOnboarding = onboardingToggle.checked;
        saveData();
      });

      resetProgress.addEventListener('click', () => {
        if (confirm('Are you sure you want to reset all your progress?')) {
          scores = {};
          achievements = {};
          saveData();
          Toast.show('Progress reset', 'info');
          SoundManager.play('success');
        }
      });

      saveSettings.addEventListener('click', () => {
        settings.soundOn = soundToggleSetting.checked;
        settings.volume = parseFloat(volumeSlider.value);
        settings.theme = themeSelect.value;
        settings.showOnboarding = onboardingToggle.checked;
        applySettings();
        saveData();
        settingsModal.classList.remove('active');
        Toast.show('Settings saved', 'success');
        SoundManager.play('success');
      });

      // Search functionality
      gameSearch?.addEventListener('input', () => {
        const searchTerm = gameSearch.value.toLowerCase();
        const tiles = qsa('.game-tile');
        tiles.forEach(tile => {
          const title = tile.querySelector('.game-title').textContent.toLowerCase();
          const description = tile.querySelector('.game-description').textContent.toLowerCase();
          tile.style.display = title.includes(searchTerm) || description.includes(searchTerm) ? 'flex' : 'none';
        });
        
        const listItems = qsa('.game-list-item');
        listItems.forEach(item => {
          const title = item.querySelector('.game-list-text').textContent.toLowerCase();
          item.style.display = title.includes(searchTerm) ? 'flex' : 'none';
        });
      });

      // Visibility change handler
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && activeGame && activeGame.pause) {
          activeGame.pause();
        } else if (!document.hidden && activeGame && activeGame.resume) {
          activeGame.resume();
        }
      });

      // Reduced motion handling
      const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (reducedMotion) {
        document.documentElement.style.setProperty('--transition-fast', '0.01s');
        document.documentElement.style.setProperty('--transition-normal', '0.01s');
        document.documentElement.style.setProperty('--transition-slow', '0.01s');
      }

      // Check onboarding
      function checkOnboarding() {
        if (settings.showOnboarding) {
          onboardingModal.classList.add('active');
        }
      }

      // Initialize
      function init() {
        SoundManager.init();
        loadData();
        registerGames();
        renderGamesGrid();
        renderGameList();
        checkOnboarding();
        // Add first game achievement
        checkAchievement('first_game', true);
      }

      // Start the app
      init();
    })();
  </script>
</body>
</html>
